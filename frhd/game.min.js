'use strict';
!function e(t, n, r) {
  function s(o, s) {
    if (!n[o]) {
      if (!t[o]) {
        var i = "function" == typeof require && require;
        if (!s && i) {
          return i(o, true);
        }
        if (a) {
          return a(o, true);
        }
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }
      var u = n[o] = {
        exports : {}
      };
      t[o][0].call(u.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, u, u.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var a = "function" == typeof require && require;
  var o = 0;
  for (; o < r.length; o++) {
    s(r[o]);
  }
  return s;
}({
  1 : [function(canCreateDiscussions, module) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || void 0;
    }
    function isFunction(arg) {
      return "function" == typeof arg;
    }
    function isNumber(val) {
      return "number" == typeof val;
    }
    function isObject(arg) {
      return "object" == typeof arg && null !== arg;
    }
    function isUndefined(val) {
      return void 0 === val;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || 0 > n || isNaN(n)) {
        throw TypeError("n must be a positive number");
      }
      return this._maxListeners = n, this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er;
      var handler;
      var l;
      var args;
      var i;
      var n;
      if (this._events || (this._events = {}), "error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
        if (er = arguments[1], er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      if (handler = this._events[type], isUndefined(handler)) {
        return false;
      }
      if (isFunction(handler)) {
        switch(arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            i = 1;
            for (; l > i; i++) {
              args[i - 1] = arguments[i];
            }
            handler.apply(this, args);
        }
      } else {
        if (isObject(handler)) {
          l = arguments.length;
          args = new Array(l - 1);
          i = 1;
          for (; l > i; i++) {
            args[i - 1] = arguments[i];
          }
          n = handler.slice();
          l = n.length;
          i = 0;
          for (; l > i; i++) {
            n[i].apply(this, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener)) {
        throw TypeError("listener must be a function");
      }
      if (this._events || (this._events = {}), this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener), this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener, isObject(this._events[type]) && !this._events[type].warned) {
        m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners;
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
          if ("function" == typeof console.trace) {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      function g() {
        this.removeListener(type, g);
        if (!n) {
          n = true;
          listener.apply(this, arguments);
        }
      }
      if (!isFunction(listener)) {
        throw TypeError("listener must be a function");
      }
      var n = false;
      return g.listener = listener, this.on(type, g), this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list;
      var n;
      var length;
      var i;
      if (!isFunction(listener)) {
        throw TypeError("listener must be a function");
      }
      if (!this._events || !this._events[type]) {
        return this;
      }
      if (list = this._events[type], length = list.length, n = -1, list === listener || isFunction(list.listener) && list.listener === listener) {
        delete this._events[type];
        if (this._events.removeListener) {
          this.emit("removeListener", type, listener);
        }
      } else {
        if (isObject(list)) {
          i = length;
          for (; i-- > 0;) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              n = i;
              break;
            }
          }
          if (0 > n) {
            return this;
          }
          if (1 === list.length) {
            list.length = 0;
            delete this._events[type];
          } else {
            list.splice(n, 1);
          }
          if (this._events.removeListener) {
            this.emit("removeListener", type, listener);
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key;
      var listeners;
      if (!this._events) {
        return this;
      }
      if (!this._events.removeListener) {
        return 0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type], this;
      }
      if (0 === arguments.length) {
        for (key in this._events) {
          if ("removeListener" !== key) {
            this.removeAllListeners(key);
          }
        }
        return this.removeAllListeners("removeListener"), this._events = {}, this;
      }
      if (listeners = this._events[type], isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else {
        for (; listeners.length;) {
          this.removeListener(type, listeners[listeners.length - 1]);
        }
      }
      return delete this._events[type], this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var e;
      return e = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : [];
    };
    EventEmitter.listenerCount = function(emitter, type) {
      var i;
      return i = emitter._events && emitter._events[type] ? isFunction(emitter._events[type]) ? 1 : emitter._events[type].length : 0;
    };
  }, {}],
  2 : [function(require) {
    !function(window) {
      function init(error, assets, options) {
        this.assets = assets;
        this.settings = options;
        this.initCanvas();
        this.initStage();
        this.setSize();
        this.switchScene(error);
        this.setSize();
        this.startTicker();
      }
      require("../libs/createjs/easeljs-0.8");
      require("../libs/performance");
      var Editor = require("./scenes/editor");
      var Main = require("./scenes/main");
      var s = {
        Editor : Editor,
        Main : Main
      };
      init.prototype = {
        gameContainer : null,
        tickCount : 0,
        currentScene : null,
        assets : null,
        stage : null,
        canvas : null,
        stats : null,
        width : 0,
        height : 0,
        fullscreen : false,
        onStateChange : null,
        initCanvas : function() {
          var canvas = document.createElement("canvas");
          var panFrame = document.getElementById(this.settings.defaultContainerID);
          panFrame.appendChild(canvas);
          this.gameContainer = panFrame;
          this.canvas = canvas;
        },
        initStage : function() {
          var stage = new createjs.Stage(this.canvas);
          stage.autoClear = false;
          createjs.Touch.enable(stage);
          stage.enableMouseOver(30);
          stage.mouseMoveOutside = true;
          stage.preventSelection = false;
          this.stage = stage;
        },
        setSize : function() {
          var h = window.innerHeight;
          var w = window.innerWidth;
          if (!this.settings.fullscreen && !this.settings.isStandalone) {
            var scrollRoot = this.gameContainer;
            h = scrollRoot.clientHeight;
            w = scrollRoot.clientWidth;
          }
          if (this.currentScene) {
            var c = this.currentScene.getCanvasOffset();
            h = h - c.height;
          }
          var ratio = 1;
          if (void 0 !== window.devicePixelRatio) {
            ratio = window.devicePixelRatio;
          }
          if (this.settings.lowQualityMode) {
            ratio = 1;
          }
          var width = w * ratio;
          var height = h * ratio;
          if (width !== this.width || height !== this.height) {
            this.width = width;
            this.height = height;
            this.canvas.width = width;
            this.canvas.height = height;
          }
          this.pixelRatio = ratio;
          this.canvas.style.width = w + "px";
          this.canvas.style.height = h + "px";
          if (this.currentScene) {
            this.currentScene.command("resize");
          }
        },
        startTicker : function() {
          createjs.Ticker.timingMode = createjs.Ticker.RAF_SYNCED;
          createjs.Ticker.frameRate = this.settings.drawFPS;
          createjs.Ticker.on("tick", this.update.bind(this));
        },
        update : function() {
          this.currentScene.update();
          this.tickCount++;
        },
        switchScene : function(transition) {
          if (null !== this.currentScene) {
            this.currentScene.close();
          }
          this.currentScene = new s[transition](this);
        },
        command : function() {
          this.currentScene.command.apply(this.currentScene, arguments);
        },
        close : function() {
          createjs.Ticker.reset();
          createjs.Ticker.removeAllEventListeners();
          this.currentScene.close();
          this.currentScene = null;
          this.assets = null;
          this.settings = null;
          this.stage.autoClear = true;
          this.stage.removeAllChildren();
          this.stage.update();
          this.stage.enableDOMEvents(false);
          this.stage.removeAllEventListeners();
          this.stage = null;
          this.canvas.parentNode.removeChild(this.canvas);
          this.canvas = null;
          this.tickCount = null;
          this.height = null;
          this.width = null;
        }
      };
      window.Game = init;
    }(window = window || {});
  }, {
    "../libs/createjs/easeljs-0.8" : 89,
    "../libs/performance" : 91,
    "./scenes/editor" : 16,
    "./scenes/main" : 17
  }],
  3 : [function(__webpack_require__, mixin) {
    function event() {
    }
    var can = __webpack_require__("../../libs/lodash-3.10.1.js");
    var self = event.prototype;
    self.defaultControlOptions = {
      visible : true
    };
    self.name = null;
    self.controlsSpriteSheetData = null;
    self.controlData = null;
    self.game = null;
    self.scene = null;
    self.settings = null;
    self.stage = null;
    self.controlsContainer = null;
    self.controlsSprite = null;
    self.gamepad = null;
    self.initialize = function(options) {
      this.scene = options;
      this.game = options.game;
      this.assets = options.assets;
      this.settings = options.settings;
      this.stage = options.game.stage;
      this.mouse = options.mouse;
      this.playerManager = options.playerManager;
      this.createSprite();
      this.addControls();
      this.resize();
    };
    self.addControls = function() {
    };
    self.createSprite = function() {
      var n = this.scene.assets.getResult(this.name);
      var data = this.controlsSpriteSheetData;
      data.images = [n];
      var image = new createjs.SpriteSheet(data);
      var module = new createjs.Sprite(image);
      this.controlsSprite = module;
    };
    self.isVisible = function() {
      return this.controlsContainer.visible;
    };
    self.hide = function() {
      this.controlsContainer.visible = false;
    };
    self.show = function() {
      this.controlsContainer.visible = true;
    };
    self.setVisibility = function(isVisible) {
      this.controlsContainer.visible = isVisible;
    };
    self.createControl = function(name) {
      var postLi = this.controlsSprite;
      var options = can.extend({}, this.defaultControlOptions, this.controlData[name]);
      var self = postLi.clone();
      self.gotoAndStop(name);
      self.buttonDetails = options;
      self.cursor = "pointer";
      self.on("mousedown", this.controlDown.bind(this));
      self.on("pressup", this.controlUp.bind(this));
      self.on("mouseover", this.mouseOver.bind(this));
      self.on("mouseout", this.mouseOut.bind(this));
      var cssChanges = self.getBounds();
      if (self.regX = cssChanges.width / 2, self.regY = cssChanges.height / 2, self.alpha = 0.5, self.name = name, self.visible = options.visible, options.hitArea) {
        var point = options.hitArea;
        var shape = new createjs.Shape;
        if (point.radius) {
          shape.graphics.beginFill("#000").drawCircle(point.x, point.y, point.radius);
        } else {
          shape.graphics.beginFill("#000").drawRect(point.x, point.y, point.width, point.height);
        }
        self.hitArea = shape;
      }
      return self;
    };
    self.mouseOver = function(event) {
      var e = event.target;
      e.alpha = 0.8;
      this.mouse.enabled = false;
    };
    self.mouseOut = function(event) {
      var e = event.target;
      e.alpha = 0.5;
      this.mouse.enabled = true;
    };
    self.controlDown = function(dependency) {
      var child = dependency.target;
      var parent = child.buttonDetails;
      var player = this.playerManager.firstPlayer.getGamepad();
      if (parent.key) {
        var result = parent.key;
        player.setButtonDown(result);
      }
      if (parent.keys) {
        var arr = parent.keys;
        var len = arr.length;
        var i = 0;
        for (; len > i; i++) {
          result = arr[i];
          player.setButtonDown(result);
        }
      }
      if (parent.downCallback) {
        parent.downCallback(dependency);
      }
      if (this.settings.mobile) {
        this.mouse.enabled = false;
      }
      child.alpha = 1;
    };
    self.controlUp = function(ownerContext) {
      var context = ownerContext.target;
      var me = context.buttonDetails;
      var player = this.playerManager.firstPlayer.getGamepad();
      if (me.key) {
        var key = me.key;
        player.setButtonUp(key);
      }
      if (me.keys) {
        var keys = me.keys;
        var i = keys.length;
        var l = 0;
        for (; i > l; l++) {
          key = keys[l];
          player.setButtonUp(key);
        }
      }
      if (me.upCallback) {
        me.upCallback(ownerContext);
      }
      if (this.settings.mobile) {
        this.mouse.enabled = true;
        context.alpha = 0.5;
      } else {
        context.alpha = 0.8;
      }
    };
    self.close = function() {
    };
    self.update = function() {
    };
    self.resize = function() {
      var data = this.scene.game;
      var x = (this.scene.screen, data.width);
      var y = data.height;
      var height = data.pixelRatio;
      var a = this.controlsContainer.children;
      var key;
      for (key in a) {
        var me = a[key];
        var result = me.buttonDetails;
        if (result.bottom) {
          me.y = y - result.bottom * (height / 2);
        }
        if (result.left) {
          me.x = result.left * (height / 2);
        }
        if (result.right) {
          me.x = x - result.right * (height / 2);
        }
        if (result.top) {
          me.y = result.top * (height / 2);
        }
        me.scaleX = me.scaleY = height / 2;
      }
    };
    mixin.exports = event;
  }, {
    "../../libs/lodash-3.10.1.js" : 90
  }],
  4 : [function(require, module) {
    function Model(obj) {
      this.initialize(obj);
    }
    var Observable = require("./controls");
    var self = Model.prototype = new Observable;
    self.name = "fullscreen_controls";
    self.fullscreenControl = null;
    self.fullscreen = false;
    self.controlsSpriteSheetData = {
      frames : [[230, 2, 76, 76], [154, 2, 76, 76], [78, 2, 76, 76], [2, 2, 76, 76]],
      animations : {
        "exit_fullscreen_btn-hover" : [0],
        exit_fullscreen_btn : [1],
        "fullscreen_btn-hover" : [2],
        fullscreen_btn : [3]
      }
    };
    self.controlData = {
      "fullscreen_btn-hover" : {
        top : 60,
        right : 150,
        key : "fullscreen"
      }
    };
    self.update = function() {
      var fullscreen = this.scene.settings.fullscreen;
      if (this.fullscreen !== fullscreen) {
        this.fullscreenControl.gotoAndStop(fullscreen ? "exit_fullscreen_btn-hover" : "fullscreen_btn-hover");
        this.fullscreen = fullscreen;
      }
    };
    self.addControls = function() {
      var child = new createjs.Container;
      child.addChild(this.createControl("fullscreen_btn-hover"));
      this.controlsContainer = child;
      this.fullscreenControl = child.getChildByName("fullscreen_btn-hover");
      this.stage.addChild(child);
    };
    module.exports = Model;
  }, {
    "./controls" : 3
  }],
  5 : [function(require, module) {
    function Model(obj) {
      this.initialize(obj);
    }
    var Observable = require("./controls");
    var self = Model.prototype = new Observable;
    self.name = "pause_controls";
    self.pauseControl = null;
    self.paused = false;
    self.controlsSpriteSheetData = {
      frames : [[230, 2, 76, 76], [154, 2, 76, 76], [78, 2, 76, 76], [2, 2, 76, 76]],
      animations : {
        "pause_btn-hover" : [0],
        pause_btn : [1],
        "play_btn-hover" : [2],
        play_btn : [3]
      }
    };
    self.controlData = {
      "pause_btn-hover" : {
        key : "pause",
        top : 60,
        right : 70
      }
    };
    self.update = function() {
      var paused = this.scene.state.paused;
      if (this.paused !== paused) {
        if (paused) {
          this.pauseControl.gotoAndStop("play_btn-hover");
          this.paused = true;
        } else {
          this.pauseControl.gotoAndStop("pause_btn-hover");
          this.paused = false;
        }
      }
    };
    self.addControls = function() {
      var child = new createjs.Container;
      child.addChild(this.createControl("pause_btn-hover"));
      this.controlsContainer = child;
      this.pauseControl = child.getChildByName("pause_btn-hover");
      this.stage.addChild(child);
    };
    module.exports = Model;
  }, {
    "./controls" : 3
  }],
  6 : [function(require, module) {
    function Model(obj) {
      this.initialize(obj);
    }
    var Observable = require("./controls");
    var self = Model.prototype = new Observable;
    self.name = "phone_controls";
    self.mainResize = self.resize;
    self.zoomControlsContainer = null;
    self.lastCheckpointButton = null;
    self.replayButton = null;
    self.controlsSpriteSheetData = {
      frames : [[782, 2, 128, 128], [652, 2, 128, 128], [522, 2, 128, 128], [912, 78, 75, 75], [392, 2, 128, 128], [912, 2, 75, 75], [262, 2, 128, 128], [132, 2, 128, 128], [2, 2, 128, 128]],
      animations : {
        accelerate : [0],
        brake : [1],
        direction : [2],
        last_checkpoint : [3],
        left : [4],
        replay : [5],
        right : [6],
        zoom_in : [7],
        zoom_out : [8]
      }
    };
    self.controlData = {
      brake : {
        key : "down",
        bottom : 100,
        left : 100,
        hitArea : {
          width : 250,
          height : 200,
          x : -30,
          y : -15
        }
      },
      direction : {
        key : "z",
        bottom : 250,
        right : 100,
        hitArea : {
          width : 200,
          height : 200,
          x : -20,
          y : -65
        }
      },
      forward : {
        key : "up",
        bottom : 250,
        left : 100,
        hitArea : {
          width : 250,
          height : 200,
          x : -30,
          y : -65
        }
      },
      last_checkpoint : {
        key : "enter",
        top : 60,
        left : 160
      },
      left : {
        key : "left",
        bottom : 100,
        right : 250,
        hitArea : {
          width : 230,
          height : 230,
          x : -100,
          y : -65
        }
      },
      right : {
        key : "right",
        bottom : 100,
        right : 100,
        hitArea : {
          width : 200,
          height : 200,
          x : -10,
          y : -15
        }
      },
      replay : {
        key : "restart",
        top : 60,
        left : 80
      },
      zoom_in : {
        key : "zoom_increase",
        bottom : 100,
        right : 100
      },
      zoom_out : {
        key : "zoom_decrease",
        bottom : 100,
        left : 100
      }
    };
    self.addControls = function() {
      var def = this.createControl("last_checkpoint");
      var control = this.createControl("replay");
      var c = this.createControl("zoom_in");
      var r = this.createControl("zoom_out");
      var self = new createjs.Container;
      self.addChild(this.createControl("left"));
      self.addChild(this.createControl("right"));
      self.addChild(this.createControl("forward"));
      self.addChild(this.createControl("brake"));
      self.addChild(this.createControl("direction"));
      self.addChild(def);
      self.addChild(control);
      self.addChild(c);
      self.addChild(r);
      var target = new createjs.Container;
      target.addChild(c);
      target.addChild(r);
      target.visibility = false;
      this.lastCheckpointButton = def;
      this.replayButton = control;
      this.controlsContainer = self;
      this.zoomControlsContainer = target;
      this.stage.addChild(self);
      this.stage.addChild(target);
    };
    self.resize = function() {
      var data = this.scene.game;
      var x = (this.scene.screen, data.width);
      var y = data.height;
      var height = data.pixelRatio;
      var a = this.zoomControlsContainer.children;
      var key;
      for (key in a) {
        var me = a[key];
        var result = me.buttonDetails;
        if (result.bottom) {
          me.y = y - result.bottom * (height / 2);
        }
        if (result.left) {
          me.x = result.left * (height / 2);
        }
        if (result.right) {
          me.x = x - result.right * (height / 2);
        }
        if (result.top) {
          me.y = result.top * (height / 2);
        }
        me.scaleX = me.scaleY = height / 2;
      }
      this.mainResize();
    };
    self.setZoomControlsVisibilty = function(value) {
      this.zoomControlsContainer.visible = value;
    };
    self.update = function() {
      var children = this.scene;
      this.lastCheckpointButton.visible = children.playerManager.firstPlayer.hasCheckpoints() ? true : false;
    };
    module.exports = Model;
  }, {
    "./controls" : 3
  }],
  7 : [function(require, module) {
    function Model(obj) {
      this.initialize(obj);
    }
    var Observable = require("./controls");
    var self = Model.prototype = new Observable;
    self.name = "redo_undo_controls";
    self.controlsSpriteSheetData = {
      frames : [[78, 2, 76, 76], [2, 2, 76, 76]],
      animations : {
        redo : [0],
        undo : [1]
      }
    };
    self.controlData = {
      redo : {
        keys : ["ctrl", "y"],
        top : 60,
        right : 160
      },
      undo : {
        keys : ["ctrl", "z"],
        top : 60,
        right : 240
      }
    };
    self.addControls = function() {
      var top = new createjs.Container;
      top.addChild(this.createControl("redo"));
      top.addChild(this.createControl("undo"));
      this.controlsContainer = top;
      this.stage.addChild(top);
    };
    self.update = function() {
      var model = this.scene;
      var visible = this.scene.state.paused;
      if (model.controls && this.controlsContainer.visible !== visible) {
        this.controlsContainer.visible = visible;
      }
    };
    module.exports = Model;
  }, {
    "./controls" : 3
  }],
  8 : [function(require, module) {
    function Controller(obj) {
      var settings = obj.settings;
      if (settings.fullscreenAvailable === false) {
        var horizonMargin = this.controlData["settings_btn-hover"];
        horizonMargin.top = 60;
        horizonMargin.right = 150;
      }
      this.initialize(obj);
    }
    var EventManager = require("./controls");
    var self = Controller.prototype = new EventManager;
    self.name = "settings_controls";
    self.controlsSpriteSheetData = {
      frames : [[78, 2, 76, 76], [2, 2, 76, 76]],
      animations : {
        "settings_btn-hover" : [0],
        settings_btn : [1]
      }
    };
    self.controlData = {
      "settings_btn-hover" : {
        top : 60,
        right : 230,
        key : "settings"
      }
    };
    self.update = function() {
    };
    self.addControls = function() {
      var top = new createjs.Container;
      top.addChild(this.createControl("settings_btn-hover"));
      this.controlsContainer = top;
      this.stage.addChild(top);
    };
    module.exports = Controller;
  }, {
    "./controls" : 3
  }],
  9 : [function(require, module) {
    function Model(obj) {
      this.initialize(obj);
    }
    var Observable = require("./controls");
    var self = Model.prototype = new Observable;
    self.name = "tablet_controls";
    self.mainResize = self.resize;
    self.zoomControlsContainer = null;
    self.lastCheckpointButton = null;
    self.controlsSpriteSheetData = {
      frames : [[154, 306, 150, 150], [154, 154, 150, 150], [382, 154, 75, 75], [306, 2, 150, 150], [154, 2, 150, 150], [306, 154, 75, 75], [2, 306, 150, 150], [2, 154, 150, 150], [2, 2, 150, 150]],
      animations : {
        accelerate : [0],
        brake : [1],
        last_checkpoint : [2],
        direction : [3],
        left : [4],
        replay : [5],
        right : [6],
        zoom_in : [7],
        zoom_out : [8]
      }
    };
    self.controlData = {
      brake : {
        key : "down",
        bottom : 120,
        left : 285,
        hitArea : {
          radius : 150,
          x : 75,
          y : 90
        }
      },
      direction : {
        key : "z",
        bottom : 285,
        right : 450,
        hitArea : {
          radius : 150,
          x : 40,
          y : 40
        }
      },
      forward : {
        key : "up",
        bottom : 285,
        left : 140,
        hitArea : {
          radius : 150,
          x : 75,
          y : 75
        }
      },
      last_checkpoint : {
        key : "enter",
        top : 60,
        left : 160
      },
      left : {
        key : "left",
        bottom : 120,
        right : 285,
        hitArea : {
          radius : 150,
          x : 75,
          y : 75
        }
      },
      right : {
        key : "right",
        bottom : 285,
        right : 140,
        hitArea : {
          radius : 150,
          x : 100,
          y : 40
        }
      },
      replay : {
        key : "restart",
        top : 60,
        left : 80
      },
      zoom_in : {
        key : "zoom_increase",
        bottom : 285,
        right : 140
      },
      zoom_out : {
        key : "zoom_decrease",
        bottom : 285,
        left : 140
      }
    };
    self.resize = function() {
      var data = this.scene.game;
      var x = (this.scene.screen, data.width);
      var y = data.height;
      var height = data.pixelRatio;
      var a = this.zoomControlsContainer.children;
      var key;
      for (key in a) {
        var me = a[key];
        var result = me.buttonDetails;
        if (result.bottom) {
          me.y = y - result.bottom * (height / 2);
        }
        if (result.left) {
          me.x = result.left * (height / 2);
        }
        if (result.right) {
          me.x = x - result.right * (height / 2);
        }
        if (result.top) {
          me.y = result.top * (height / 2);
        }
        me.scaleX = me.scaleY = height / 2;
      }
      this.mainResize();
    };
    self.setZoomControlsVisibilty = function(value) {
      this.zoomControlsContainer.visible = value;
    };
    self.addControls = function() {
      var c = this.createControl("zoom_in");
      var bc = this.createControl("zoom_out");
      var self = new createjs.Container;
      self.addChild(this.createControl("left"));
      self.addChild(this.createControl("right"));
      self.addChild(this.createControl("forward"));
      self.addChild(this.createControl("brake"));
      self.addChild(this.createControl("direction"));
      self.addChild(this.createControl("last_checkpoint"));
      self.addChild(this.createControl("replay"));
      var path = new createjs.Container;
      path.addChild(c);
      path.addChild(bc);
      path.visible = false;
      this.lastCheckpointButton = self.getChildByName("last_checkpoint");
      this.controlsContainer = self;
      this.zoomControlsContainer = path;
      this.stage.addChild(self);
      this.stage.addChild(path);
    };
    self.update = function() {
      var children = this.scene;
      this.lastCheckpointButton.visible = children.playerManager.firstPlayer.hasCheckpoints() ? true : false;
    };
    module.exports = Model;
  }, {
    "./controls" : 3
  }],
  10 : [function(canCreateDiscussions, module, extra) {
    !function() {
      function data(value) {
        this.drawAngle = 0;
        this.colors = value;
        this.createVersion();
      }
      var Promise = GameInventoryManager.HeadClass;
      var m = Math.max;
      var elements = {};
      var o = 0;
      var a = 0;
      var h = 2.2;
      var l = 1;
      var value = 115;
      var height = 112;
      var dx = 0.17;
      var self = data.prototype = new Promise;
      self.versionName = "";
      self.dirty = true;
      self.getVersions = function() {
        return elements;
      };
      self.cache = function(c) {
        var obj = elements[this.versionName];
        obj.dirty = false;
        c = m(c, 1);
        var tempW = value * c * dx;
        var _rulerThickness = height * c * dx;
        var canvas = obj.canvas;
        canvas.width = tempW;
        canvas.height = _rulerThickness;
        o = canvas.width / 2;
        a = canvas.height / 2;
        var context = canvas.getContext("2d");
        var x = dx * c;
        var s = this.colors;
        context.save();
        context.scale(x, x);
        context.translate(0, 0);
        context.beginPath();
        context.strokeStyle = "rgba(0,0,0,0)";
        context.lineCap = "butt";
        context.lineJoin = "miter";
        context.miterLimit = 4;
        context.save();
        context.fillStyle = "#ffffff";
        context.beginPath();
        context.arc(42.4, 52.5, 30.3, 0, 6.283185307179586, true);
        context.closePath();
        context.fill();
        context.stroke();
        context.restore();
        context.save();
        context.fillStyle = s.back;
        context.beginPath();
        context.moveTo(71.624, 44.496);
        context.bezierCurveTo(68.112, 31.647, 56.363, 22.2, 42.4, 22.2);
        context.bezierCurveTo(25.665999999999997, 22.2, 12.099999999999998, 35.765, 12.099999999999998, 52.5);
        context.bezierCurveTo(12.099999999999998, 55.771, 12.623999999999999, 58.916, 13.582999999999998, 61.867000000000004);
        context.lineTo(71.624, 44.496);
        context.closePath();
        context.fill();
        context.stroke();
        context.restore();
        if (s.front) {
          context.save();
          context.beginPath();
          context.moveTo(76.917, 38.393);
          context.bezierCurveTo(71.677, 25.617, 59.54900000000001, 16.371000000000002, 45.172, 15.309000000000001);
          context.bezierCurveTo(47.57899999999999, 22.559, 50.918, 33.862, 52.501, 44.894999999999996);
          context.bezierCurveTo(60.643, 42.731, 68.775, 40.566, 76.917, 38.393);
          context.closePath();
          context.fillStyle = s.front;
          context.fill();
          context.stroke();
          context.restore();
        }
        context.save();
        context.beginPath();
        context.moveTo(42.4, 22.2);
        context.bezierCurveTo(59.134, 22.2, 72.7, 35.765, 72.7, 52.5);
        context.bezierCurveTo(72.7, 69.235, 59.135, 82.8, 42.4, 82.8);
        context.bezierCurveTo(25.665, 82.8, 12.1, 69.234, 12.1, 52.5);
        context.bezierCurveTo(12.1, 35.766000000000005, 25.666, 22.2, 42.4, 22.2);
        context.moveTo(42.4, 15.2);
        context.bezierCurveTo(21.833, 15.2, 5.100000000000001, 31.932, 5.100000000000001, 52.5);
        context.bezierCurveTo(5.100000000000001, 73.068, 21.832, 89.8, 42.4, 89.8);
        context.bezierCurveTo(62.967999999999996, 89.8, 79.69999999999999, 73.068, 79.69999999999999, 52.5);
        context.bezierCurveTo(79.69999999999999, 31.932000000000002, 62.968, 15.2, 42.4, 15.2);
        context.lineTo(42.4, 15.2);
        context.closePath();
        context.fill();
        context.stroke();
        context.restore();
        context.save();
        context.beginPath();
        context.moveTo(16.3, 66.85);
        context.bezierCurveTo(41.8, 60.148999999999994, 67.2, 53.449999999999996, 92.601, 46.648999999999994);
        context.bezierCurveTo(96.201, 45.648999999999994, 99.8, 44.748999999999995, 103.5, 43.748999999999995);
        context.bezierCurveTo(111, 41.748999999999995, 107.8, 30.148999999999994, 100.3, 32.148999999999994);
        context.bezierCurveTo(74.901, 38.94899999999999, 49.400999999999996, 45.748999999999995, 24, 52.449);
        context.bezierCurveTo(20.4, 53.449, 16.8, 54.349, 13.101, 55.349);
        context.bezierCurveTo(5.7, 57.35, 8.9, 68.85, 16.3, 66.85);
        context.lineTo(16.3, 66.85);
        context.closePath();
        context.fill();
        context.stroke();
        context.restore();
      };
      self.setDirty = function() {
        elements[this.versionName].dirty = true;
      };
      self.getBaseWidth = function() {
        return value;
      };
      self.getBaseHeight = function() {
        return height;
      };
      self.getDrawOffsetX = function() {
        return h;
      };
      self.getDrawOffsetY = function() {
        return l;
      };
      self.getScale = function() {
        return dx;
      };
      if (GameInventoryManager) {
        GameInventoryManager.register("forward_cap", data);
      }
      if ("undefined" != typeof extra) {
        if ("undefined" != typeof module && module.exports) {
          extra = module.exports = data;
        }
        extra.Forward_Cap = data;
      }
    }();
  }, {}],
  11 : [function(saveNotifs, module) {
    function ChatBuffer() {
    }
    saveNotifs("../inventorymanager");
    var me = (Math.atan2, ChatBuffer.prototype);
    me.createVersion = function() {
      var prefixes = this.colors;
      var versions = this.getVersions();
      var name = "";
      var p;
      for (p in prefixes) {
        if (prefixes.hasOwnProperty(p)) {
          name = name + prefixes[p];
        }
      }
      this.versionName = name;
      if (!versions[name]) {
        versions[name] = {
          dirty : true,
          canvas : document.createElement("canvas")
        };
      }
    };
    me.draw = function(ctx, x, y, a, value, css) {
      var data = this.getCache(value);
      var unitValue = this.getBaseWidth();
      var rescaleSlope = this.getBaseHeight();
      var factor = this.getScale();
      var i = this.getDrawOffsetX();
      var yy = this.getDrawOffsetY();
      var width = unitValue * value * factor;
      var height = rescaleSlope * value * factor;
      var imageOffsetX = i * value - width / 2;
      var imageOffsetY = yy * value - height / 2;
      var isCSS = -1 === css;
      ctx.translate(x, y);
      ctx.rotate(a);
      if (isCSS) {
        ctx.scale(1, -1);
      }
      ctx.drawImage(data, imageOffsetX, imageOffsetY, width, height);
      if (isCSS) {
        ctx.scale(1, -1);
      }
      ctx.rotate(-a);
      ctx.translate(-x, -y);
    };
    me.getCache = function(options) {
      var objects = this.getVersions();
      return objects[this.versionName].dirty && this.cache(options), objects[this.versionName].canvas;
    };
    me.setDirty = function() {
      var lines = this.getVersions();
      lines[this.versionName].dirty = true;
    };
    module.exports = ChatBuffer;
    if (GameInventoryManager) {
      GameInventoryManager.HeadClass = ChatBuffer;
    }
  }, {
    "../inventorymanager" : 12
  }],
  12 : [function(canCreateDiscussions, module) {
    function List() {
    }
    var classes = {};
    var sounds = {};
    var utilReqPaths = {};
    var self = List.prototype;
    self.getItem = function(options) {
      var name = options.classname;
      var url = options.script;
      var obj = options.options;
      var feedType = options.type;
      if (!classes[name]) {
        if ("1" === feedType) {
          name = "forward_cap";
          obj = {
            back : "white"
          };
        }
        if (!utilReqPaths[url]) {
          utilReqPaths[url] = true;
          GameManager.loadFile(url);
        }
      }
      var key = this.generateID(feedType, name, obj);
      return sounds[key] || (sounds[key] = new classes[name](obj)), sounds[key];
    };
    self.redraw = function() {
      var i;
      for (i in sounds) {
        if (sounds.hasOwnProperty(i)) {
          sounds[i].setDirty();
        }
      }
    };
    self.generateID = function(prefix, str, key) {
      str = prefix + str;
      if (key) {
        var name;
        for (name in key) {
          if (key.hasOwnProperty(name)) {
            str = str + key[name];
          }
        }
      }
      return str;
    };
    self.register = function(type, obj) {
      classes[type] = obj;
    };
    self.clear = function() {
    };
    window.GameInventoryManager = new List;
    module.exports = List;
  }, {}],
  13 : [function(saveNotifs, module) {
    function debug(t, c, v, b, s) {
      var str = [];
      var i = t;
      var g = c;
      var a = (b - c) / (v - t);
      var startHour = v > t ? 1 : -1;
      var strokeSize = b > c ? 1 : -1;
      var d = 0;
      str.push(t, c);
      do {
        var reverseIsSingle = floor(i / s) == floor(v / s);
        var reverseValue = floor(g / s) == floor(b / s);
        if (reverseIsSingle && reverseValue) {
          break;
        }
        var y = 0;
        var p = 0;
        y = get(floor(i / s + startHour) * s);
        if (0 > startHour) {
          y = get(ceil((i + 1) / s + startHour) * s) - 1;
        }
        p = get(c + (y - t) * a);
        var w = 0;
        var x = 0;
        x = get(floor(g / s + strokeSize) * s);
        if (0 > strokeSize) {
          x = get(ceil((g + 1) / s + strokeSize) * s) - 1;
        }
        w = get(t + (x - c) / a);
        if (r(y - t, 2) + r(p - c, 2) < r(w - t, 2) + r(x - c, 2)) {
          i = y;
          g = p;
          str.push(y, p);
        } else {
          i = w;
          g = x;
          str.push(w, x);
        }
      } while (d++ < 5e3);
      return str;
    }
    var get = (saveNotifs("./cartesian"), Math.round);
    var floor = Math.floor;
    var ceil = Math.ceil;
    var r = Math.pow;
    module.exports = debug;
  }, {
    "./cartesian" : 14
  }],
  14 : [function(canCreateDiscussions, module) {
    function Vector(x, data) {
      this.x = x;
      this.y = data;
    }
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var addBounded = (Math.round, Math.atan2);
    var ang = Math.PI;
    Vector.prototype = {
      x : 0,
      y : 0,
      toReal : function(game) {
        var camera = game.camera;
        var screen = game.screen;
        var vertexCount = (this.x - screen.center.x) / camera.zoom + camera.position.x;
        var y = (this.y - screen.center.y) / camera.zoom + camera.position.y;
        return new Vector(vertexCount, y);
      },
      toScreen : function(options) {
        var camera = options.camera;
        var screen = options.screen;
        var vertexCount = (this.x - camera.position.x) * camera.zoom + screen.center.x;
        var y = (this.y - camera.position.y) * camera.zoom + screen.center.y;
        return new Vector(vertexCount, y);
      },
      lenSqr : function() {
        return pow(this.x, 2) + pow(this.y, 2);
      },
      len : function() {
        return sqrt(pow(this.x, 2) + pow(this.y, 2));
      },
      dot : function(v) {
        return this.x * v.x + this.y * v.y;
      },
      factor : function(s) {
        return new Vector(this.x * s, this.y * s);
      },
      factorSelf : function(s) {
        this.x = this.x * s;
        this.y = this.y * s;
      },
      factorOut : function(scalar, dst) {
        dst.x = this.x * scalar;
        dst.y = this.y * scalar;
      },
      add : function(value) {
        return new Vector(this.x + value.x, this.y + value.y);
      },
      inc : function(v) {
        this.x += v.x;
        this.y += v.y;
      },
      addOut : function(obj, source) {
        source.x = this.x + obj.x;
        source.y = this.y + obj.y;
      },
      sub : function(b) {
        return new Vector(this.x - b.x, this.y - b.y);
      },
      subOut : function(value, result) {
        result.x = this.x - value.x;
        result.y = this.y - value.y;
      },
      subSelf : function(a) {
        this.x = this.x - a.x;
        this.y = this.y - a.y;
      },
      equ : function(val) {
        this.x = val.x;
        this.y = val.y;
      },
      normalize : function() {
        var m = sqrt(pow(this.x, 2) + pow(this.y, 2));
        return new Vector(this.x / m, this.y / m);
      },
      getAngleInDegrees : function(towardsPos) {
        var current = towardsPos.sub(this);
        var blockWidth = addBounded(current.x, -current.y);
        var entry_x = blockWidth * (180 / ang);
        return 0 > entry_x && (entry_x = entry_x + 360), entry_x;
      },
      getAngleInRadians : function(towardsPos) {
        var current = towardsPos.sub(this);
        return addBounded(current.x, -current.y);
      }
    };
    module.exports = Vector;
  }, {}],
  15 : [function(canCreateDiscussions, module) {
    function render(props, a, val) {
      function b(b, s, key, e, xml, data) {
        result.push(b, s);
        callback(b, s, key, e, xml, data, 0);
        result.push(xml, data);
      }
      function callback(d, start, f, value, e, v, r) {
        if (!(r > MIN_HEIGHT)) {
          var root = (d + f) / 2;
          var p = (start + value) / 2;
          var files = (f + e) / 2;
          var result = (value + v) / 2;
          var x = (root + files) / 2;
          var i = (p + result) / 2;
          var a = e - d;
          var b = v - start;
          var rr = $((f - e) * b - (value - v) * a);
          if (rr > MAX_INT32) {
            if (PCdotN * (a * a + b * b) >= rr * rr) {
              if (mY > pY) {
                return void result.push(x, i);
              }
              var p = $(abs(v - value, e - f) - abs(value - start, f - d));
              if (p >= ang && (p = 2 * ang - p), pY > p) {
                return void result.push(x, i);
              }
            }
          } else {
            if (a = x - (d + e) / 2, b = i - (start + v) / 2, PCdotN >= a * a + b * b) {
              return void result.push(x, i);
            }
          }
          callback(d, start, root, p, x, i, r + 1);
          callback(x, i, files, result, e, v, r + 1);
        }
      }
      var value = props.x;
      var n = props.y;
      var x2 = a.x;
      var y2 = a.y;
      var x = val.x;
      var y = val.y;
      var result = [];
      var PCdotN = 0.25;
      var MIN_HEIGHT = 10;
      var MAX_INT32 = 1e-30;
      var pY = 0;
      var mY = 0.01;
      return b(value, n, x2, y2, x, y), result;
    }
    var $ = Math.abs;
    var abs = Math.atan2;
    var ang = Math.PI;
    module.exports = render;
  }, {}],
  16 : [function(require, context) {
    function init(options) {
      this.game = options;
      this.assets = options.assets;
      this.stage = options.stage;
      this.settings = options.settings;
      this.sound = new Duplicity(this);
      this.mouse = new Vec2(this);
      this.mouse.disableContextMenu();
      this.message = new Queue(this);
      this.camera = new Camera(this);
      this.screen = new Screen(this);
      this.createTrack();
      this.loadingcircle = new PortalDeleteDialog(this);
      this.playerManager = new WindowRenderer(this);
      this.vehicleTimer = new AppContainerView(this);
      this.score = new User_GameScore(this);
      this.createMainPlayer();
      this.createControls();
      this.registerTools();
      this.state = this.setStateDefaults();
      this.oldState = this.setStateDefaults();
      this.restart();
      this.initializeAnalytics();
      this.stage.addEventListener("stagemousedown", this.tapToStartOrRestart.bind(this));
    }
    {
      var Vec2 = (require("../math/cartesian"), require("../utils/mousehandler"));
      var Camera = require("../view/camera");
      var Screen = require("../view/screen");
      var WindowRenderer = require("../vehicles/player_manager");
      var AppContainerView = require("../utils/vehicletimer");
      var EventDispatcher = require("../tools/toolhandler");
      var u = require("../tools/cameratool");
      var c = require("../tools/curvetool");
      var p = require("../tools/straightlinetool");
      var f = require("../tools/brushtool");
      var d = require("../tools/selecttool");
      var g = require("../tools/erasertool");
      var v = require("../tools/poweruptool");
      var type = require("../tools/vehiclepoweruptool");
      var Scope = require("../tracks/track");
      var PortalDeleteDialog = (require("../utils/gamepad"), require("../utils/loadingcircle"));
      var User_GameScore = require("../utils/score");
      var Controls = require("../controls/tablet");
      var TrackballControls = require("../controls/phone");
      var Joystick = require("../controls/pause");
      var TagHourlyStat = require("../controls/redoundo");
      var Duplicity = require("../utils/soundmanager");
      var Queue = require("../utils/messagemanager");
      var that = Application.Helpers.GoogleAnalyticsHelper;
      Math.round;
    }
    init.prototype = {
      game : null,
      assets : null,
      stage : null,
      canvas : null,
      settings : null,
      camera : null,
      screen : null,
      mouse : null,
      track : null,
      player : null,
      players : null,
      ticks : 0,
      state : null,
      oldState : null,
      stateDirty : true,
      onStateChange : null,
      vehicle : "Mtb",
      showDialog : false,
      dialogOptions : false,
      importCode : false,
      clear : false,
      redoundoControls : null,
      pauseControls : null,
      inFocus : true,
      controls : null,
      verified : false,
      getCanvasOffset : function() {
        var myConfig = {
          height : 90,
          width : 0
        };
        return this.settings.isStandalone && (myConfig = {
          height : 202,
          width : 0
        }), myConfig;
      },
      tapToStartOrRestart : function() {
        if (this.settings.mobile) {
          var ctrl = this.playerManager.firstPlayer;
          if (ctrl && ctrl._crashed && !this.state.paused) {
            var player = ctrl.getGamepad();
            player.setButtonDown("enter");
          } else {
            this.play();
          }
        }
      },
      analytics : null,
      initializeAnalytics : function() {
        this.analytics = {
          deaths : 0,
          mouseEvents : 0
        };
        this.trackAction("editor-open", "open");
      },
      createMainPlayer : function() {
        var self = this.playerManager;
        var p3 = self.createPlayer(this, this.settings.user);
        var action = p3.getGamepad();
        action.setKeyMap(this.settings.editorHotkeys);
        action.onButtonDown = this.buttonDown.bind(this);
        action.listen();
        this.playerManager.firstPlayer = p3;
        this.playerManager.addPlayer(p3);
      },
      createControls : function() {
        if ("tablet" === this.settings.controls) {
          this.controls = new Controls(this);
          this.controls.hide();
        }
        if ("phone" === this.settings.controls) {
          this.controls = new TrackballControls(this);
          this.controls.hide();
        }
        this.redoundoControls = new TagHourlyStat(this);
        this.pauseControls = new Joystick(this);
      },
      createTrack : function() {
        if (this.track) {
          this.track.close();
        }
        var scope = new Scope(this);
        var partial = this.getAvailableTrackCode();
        if (0 != partial) {
          scope.read(partial);
          this.track = scope;
          this.state.preloading = false;
          this.state.loading = false;
        } else {
          scope.addDefaultLine();
        }
        this.importCode = false;
        this.restartTrack = true;
        this.clear = false;
        this.track = scope;
      },
      updateControls : function() {
        if (this.controls) {
          var visible = this.state.paused;
          if (this.controls.isVisible() === visible) {
            if (!visible) {
              this.state.playing = false;
              this.camera.focusOnMainPlayer();
              this.toolHandler.setTool("camera");
            }
            this.controls.setVisibility(!visible);
            this.updateState();
          }
          this.controls.update();
        }
        this.pauseControls.update();
      },
      registerTools : function() {
        var self = new EventDispatcher(this);
        self.enableGridUse();
        this.toolHandler = self;
        self.registerTool(u);
        self.registerTool(c);
        self.registerTool(p);
        self.registerTool(f);
        self.registerTool(d);
        self.registerTool(g);
        self.registerTool(v);
        self.registerTool(type);
        self.setTool(this.settings.startTool);
      },
      updateToolHandler : function() {
        if (!(this.controls && this.controls.isVisible() !== false)) {
          this.toolHandler.update();
        }
      },
      play : function() {
        this.state.playing = true;
      },
      update : function() {
        this.updateToolHandler();
        this.mouse.update();
        if (!this.state.showDialog) {
          this.updateGamepads();
          this.checkGamepads();
        }
        this.screen.update();
        this.updateControls();
        this.camera.update();
        this.sound.update();
        if (this.restartTrack) {
          this.restart();
        }
        if (!this.state.paused && this.state.playing) {
          this.message.update();
          this.updatePlayers();
          this.score.update();
          if (this.playerManager.firstPlayer.complete) {
            this.trackComplete();
          } else {
            this.ticks++;
          }
        }
        this.vehicleTimer.update();
        if (this.importCode || this.clear) {
          this.createTrack();
        }
        if (this.isStateDirty()) {
          this.updateState();
        }
        this.stage.clear();
        this.draw();
        this.stage.update();
        this.camera.updateZoom();
      },
      isStateDirty : function() {
        var proto = this.oldState;
        var obj = this.state;
        var i = false;
        var prop;
        for (prop in obj) {
          if (obj[prop] !== proto[prop]) {
            i = true;
            this.oldState[prop] = obj[prop];
          }
        }
        return i;
      },
      updateGamepads : function() {
        this.playerManager.updateGamepads();
      },
      checkGamepads : function() {
        this.playerManager.checkKeys();
      },
      stopAudio : function() {
        createjs.Sound.stop();
      },
      restart : function() {
        this.verified = !this.settings.requireTrackVerification;
        this.track.dirty = false;
        this.track.resetPowerups();
        this.message.hide();
        this.restartTrack = false;
        this.state.playing = false;
        this.ticks = 0;
        this.playerManager.reset();
        this.camera.focusOnPlayer();
        this.camera.fastforward();
        this.score.update();
      },
      buttonDown : function(event) {
        var camera = this.camera;
        switch(this.state.playing = true, event) {
          case "up":
          case "down":
          case "left":
          case "right":
            camera.focusOnMainPlayer();
            break;
          case "change_camera":
            camera.focusOnNextPlayer();
            break;
          case "pause":
            this.state.paused = !this.state.paused;
            break;
          case "settings":
            this.command("dialog", "settings");
            break;
          case "change_vehicle":
            this.toggleVehicle();
            this.stateChanged();
            break;
          case "zoom_increase":
            camera.increaseZoom();
            this.stateChanged();
            break;
          case "zoom_decrease":
            camera.decreaseZoom();
            this.stateChanged();
            break;
          case "fullscreen":
            this.toggleFullscreen();
            this.stateChanged();
        }
      },
      toggleFullscreen : function() {
        if (this.settings.embedded) {
          var options = this.settings;
          var facebookString = options.basePlatformUrl + "/t/" + options.track.url;
          window.open(facebookString);
        } else {
          if (this.settings.fullscreenAvailable) {
            this.settings.fullscreen = this.state.fullscreen = !this.settings.fullscreen;
          }
        }
      },
      updatePlayers : function() {
        this.playerManager.update();
      },
      drawPlayers : function() {
        this.playerManager.draw();
      },
      draw : function() {
        this.toolHandler.drawGrid();
        this.track.draw();
        this.drawPlayers();
        if (!(this.controls && this.controls.isVisible() !== false)) {
          this.toolHandler.draw();
        }
        if (this.state.loading) {
          this.loadingcircle.draw();
        }
        this.message.draw();
      },
      getAvailableTrackCode : function() {
        var attrs = this.settings;
        var isoOptions = false;
        return attrs.importCode && "false" !== attrs.importCode ? (isoOptions = attrs.importCode, attrs.importCode = null) : this.importCode && (isoOptions = this.importCode, this.importCode = null), isoOptions;
      },
      redraw : function() {
        this.track.undraw();
        GameInventoryManager.redraw();
        this.toolHandler.resize();
      },
      resize : function() {
        this.pauseControls.resize();
        this.redoundoControls.resize();
        if (this.controls) {
          this.controls.resize();
        }
      },
      updateState : function() {
        if (null !== this.game.onStateChange) {
          var data = this.state;
          data.tool = this.toolHandler.currentTool;
          data.toolOptions = this.toolHandler.getToolOptions();
          data.grid = this.toolHandler.options.grid;
          data.cameraLocked = this.toolHandler.options.cameraLocked;
          data.zoomPercentage = this.camera.zoomPercentage;
          data.vehicle = this.vehicle;
          this.game.onStateChange(this.state);
        }
      },
      stateChanged : function() {
        this.updateState();
      },
      setStateDefaults : function() {
        var self = {};
        return self.paused = this.settings.mobile ? true : this.settings.startPaused, self.loading = false, self.playing = this.settings.waitForKeyPress, self.tool = this.toolHandler.currentTool, self.toolOptions = this.toolHandler.getToolOptions(), self.grid = this.toolHandler.options.grid, self.cameraLocked = this.toolHandler.options.cameraLocked, self.zoomPercentage = this.camera.zoomPercentage, self.vehicle = this.vehicle, self.showDialog = false, self.dialogOptions = false, self.preloading = 
        false, self.fullscreen = this.settings.fullscreen, self.inFocus = true, this.controls && (self.hideMenus = this.controls.isVisible()), self;
      },
      toggleVehicle : function() {
        var format = this.track.allowedVehicles;
        var l = format.length;
        var separator = this.state.vehicle;
        var separatorIndex = format.indexOf(separator);
        separatorIndex++;
        if (separatorIndex >= l) {
          separatorIndex = 0;
        }
        separator = format[separatorIndex];
        this.selectVehicle(separator);
      },
      selectVehicle : function(separator) {
        var element = this.track.allowedVehicles;
        var separtorDimension = element.indexOf(separator);
        if (-1 !== separtorDimension) {
          this.settings.track.vehicle = separator;
          this.vehicle = separator;
          this.playerManager.firstPlayer.setBaseVehicle(separator);
          this.restartTrack = true;
        }
      },
      trackAction : function(action, name) {
        var actions = this.toolHandler.analytics.actions;
        var actionName = this.mouse.analytics.clicks;
        var spritename = actions + actionName;
        var types = {
          category : "create",
          action : action,
          label : name,
          value : spritename,
          non_interaction : true
        };
        that.track_event(types);
      },
      openDialog : function(name) {
        switch(this.state.dialogOptions = {}, name) {
          case "import":
            break;
          case "export":
            setTimeout(this.getTrackCode.bind(this), 750);
            break;
          case "upload":
            if ("undefined" == typeof isChromeApp) {
              setTimeout(this.getTrackCode.bind(this), 750);
            }
        }
        this.state.playing = false;
        this.state.showDialog = name;
      },
      getTrackCode : function() {
        this.state.dialogOptions = {};
        this.state.dialogOptions.verified = this.verified;
        this.state.dialogOptions.code = this.track.getCode();
      },
      trackComplete : function() {
        this.verified = this.track.dirty ? false : true;
      },
      hideControlPlanel : function() {
      },
      showControlPlanel : function() {
      },
      command : function() {
        var m = Array.prototype.slice.call(arguments, 0);
        var key = m.shift();
        switch(key) {
          case "change tool":
            var type = m[0];
            this.toolHandler.setTool(type);
            break;
          case "change tool option":
            var an = m[0];
            var a4 = m[1];
            if ("undefined" != typeof m[2]) {
              this.toolHandler.setToolOption(an, a4, m[2]);
            } else {
              this.toolHandler.setToolOption(an, a4);
            }
            break;
          case "snap":
            this.toolHandler.toggleSnap();
            break;
          case "add track":
            this.track.read(demo.code);
            track = null;
            break;
          case "redraw":
            this.redraw();
            break;
          case "fullscreen":
            this.settings.fullscreen = this.state.fullscreen = !this.settings.fullscreen;
            break;
          case "grid":
            this.toolHandler.toggleGrid();
            break;
          case "lock camera":
            this.toolHandler.toggleCameraLock();
            break;
          case "toggle vehicle":
            this.toggleVehicle();
            this.stateChanged();
            break;
          case "reset zoom":
            this.camera.resetZoom();
            break;
          case "increase zoom":
            this.camera.increaseZoom();
            break;
          case "decrease zoom":
            this.camera.decreaseZoom();
            break;
          case "change lineType":
            var lineType = m[0];
            this.toolHandler.options.lineType = lineType;
            this.stateChanged();
            break;
          case "resize":
            this.resize();
            break;
          case "dialog":
            var iframe = m[0];
            if (iframe === false) {
              this.listen();
            } else {
              this.unlisten();
            }
            this.openDialog(iframe);
            break;
          case "focused":
            var is_block = m[0];
            if (is_block === true) {
              this.state.inFocus = true;
              if (this.state.showDialog === false) {
                this.listen();
              }
            } else {
              this.state.inFocus = false;
              this.unlisten();
              this.state.playing = false;
            }
            break;
          case "clear track":
            this.trackAction("editor-action", "clear");
            this.clear = true;
            break;
          case "import":
            var args = m[0];
            if (args.length <= 0) {
              args = false;
            }
            this.importCode = args;
            this.clear = m[1];
            this.command("dialog", false);
        }
      },
      listen : function() {
        var controller = this.playerManager.firstPlayer;
        var destServer = controller.getGamepad();
        destServer.listen();
      },
      unlisten : function() {
        var controller = this.playerManager.firstPlayer;
        var comm = controller.getGamepad();
        comm.unlisten();
      },
      stopAudio : function() {
        createjs.Sound.stop();
      },
      close : function() {
        this.trackAction("editor-exit", "exit");
        this.pauseControls = null;
        this.mouse.close();
        this.mouse = null;
        this.camera.close();
        this.camera = null;
        this.screen.close();
        this.screen = null;
        this.vehicleTimer.close();
        this.vehicleTimer = null;
        this.playerManager.close();
        this.playerManager = null;
        this.sound.close();
        this.sound = null;
        this.track.close();
        this.toolHandler.close();
        this.game = null;
        this.assets = null;
        this.settings = null;
        this.stage = null;
        this.track = null;
        this.state = null;
        this.stopAudio();
      }
    };
    context.exports = init;
  }, {
    "../controls/pause" : 5,
    "../controls/phone" : 6,
    "../controls/redoundo" : 7,
    "../controls/tablet" : 9,
    "../math/cartesian" : 14,
    "../tools/brushtool" : 34,
    "../tools/cameratool" : 35,
    "../tools/curvetool" : 36,
    "../tools/erasertool" : 37,
    "../tools/poweruptool" : 38,
    "../tools/selecttool" : 47,
    "../tools/straightlinetool" : 48,
    "../tools/toolhandler" : 50,
    "../tools/vehiclepoweruptool" : 51,
    "../tracks/track" : 56,
    "../utils/gamepad" : 60,
    "../utils/loadingcircle" : 61,
    "../utils/messagemanager" : 62,
    "../utils/mousehandler" : 63,
    "../utils/score" : 66,
    "../utils/soundmanager" : 68,
    "../utils/vehicletimer" : 69,
    "../vehicles/player_manager" : 80,
    "../view/camera" : 87,
    "../view/screen" : 88
  }],
  17 : [function(require, context) {
    function init(options) {
      this.game = options;
      this.assets = options.assets;
      this.stage = options.stage;
      this.settings = options.settings;
      this.sound = new Duplicity(this);
      this.mouse = new Vec2(this);
      this.initalizeCamera();
      this.screen = new Screen(this);
      this.createTrack();
      this.score = new WindowRenderer(this);
      this.raceTimes = new AppContainerView(this);
      this.message = new Queue(this);
      if (this.settings.isCampaign) {
        this.campaignScore = new r(this);
      }
      this.loadingcircle = new KeyboardEventListener(this);
      this.loading = false;
      this.ready = false;
      this.playerManager = new PortalDeleteDialog(this);
      this.vehicleTimer = new newNotebookListMenu(this);
      this.races = [];
      this.state = this.setStateDefaults();
      this.oldState = this.setStateDefaults();
      this.createMainPlayer();
      this.createControls();
      this.registerTools();
      this.setStartingVehicle();
      this.restart();
      this.initializeAnalytics();
      this.stage.addEventListener("stagemousedown", this.tapToStartOrRestart.bind(this));
    }
    var Vec2 = (require("../math/cartesian"), require("../utils/mousehandler"));
    var WindowRenderer = require("../utils/score");
    var r = require("../utils/campaignscore");
    var AppContainerView = require("../utils/racetimes");
    var that = Application.Helpers.GoogleAnalyticsHelper;
    var Camera = require("../view/camera");
    var Screen = require("../view/screen");
    var EventDispatcher = require("../tools/toolhandler");
    var type = require("../tools/cameratool");
    var PortalDeleteDialog = require("../vehicles/player_manager");
    var newNotebookListMenu = require("../utils/vehicletimer");
    var Scope = require("../tracks/track");
    var _Grips_CSS = (require("../utils/gamepad"), {});
    _Grips_CSS.MTB = require("../vehicles/mtb");
    _Grips_CSS.BMX = require("../vehicles/bmx");
    var KeyboardEventListener = require("../utils/loadingcircle");
    var Controls = require("../controls/tablet");
    var TrackballControls = require("../controls/phone");
    var Joystick = require("../controls/pause");
    var Duplicity = require("../utils/soundmanager");
    var Queue = require("../utils/messagemanager");
    var ScrollView = require("../controls/fullscreen");
    var Popup = require("../controls/settings");
    var round = Math.round;
    var _ = require("../../libs/lodash-3.10.1");
    var CryptoJS = require("../utils/sha256");
    var normalize = require("../utils/formatnumber");
    init.prototype = {
      game : null,
      assets : null,
      stage : null,
      settings : null,
      camera : null,
      score : null,
      screen : null,
      mouse : null,
      track : null,
      player : null,
      players : null,
      ticks : 0,
      races : null,
      state : null,
      oldState : null,
      stateDirty : true,
      onStateChange : null,
      playing : false,
      ready : false,
      vehicle : "Mtb",
      showDialog : false,
      importCode : false,
      preloading : true,
      loading : true,
      pauseControls : null,
      fullscreenControls : null,
      settingsControls : null,
      controls : null,
      message : null,
      showSkip : false,
      getCanvasOffset : function() {
        var finalSizeCropProperties = {
          height : 0,
          width : 0
        };
        return finalSizeCropProperties;
      },
      tapToStartOrRestart : function() {
        if (this.settings.mobile) {
          var ctrl = this.playerManager.firstPlayer;
          if (ctrl && ctrl._crashed && !this.state.paused) {
            var player = ctrl.getGamepad();
            player.setButtonDown("enter");
          } else {
            this.play();
          }
        }
      },
      analytics : null,
      initializeAnalytics : function() {
        this.analytics = {
          deaths : 0
        };
      },
      createControls : function() {
        if ("tablet" === this.settings.controls) {
          this.controls = new Controls(this);
          this.controls.hide();
        }
        if ("phone" === this.settings.controls) {
          this.controls = new TrackballControls(this);
          this.controls.hide();
        }
        this.pauseControls = new Joystick(this);
        if (this.settings.fullscreenAvailable) {
          this.fullscreenControls = new ScrollView(this);
        }
        this.settingsControls = new Popup(this);
      },
      play : function() {
        if (!this.state.playing) {
          this.state.playing = true;
          this.hideControlPlanel();
        }
      },
      buttonDown : function(type) {
        if (!this.state.showDialog) {
          var camera = this.camera;
          switch(type) {
            case "change_camera":
              camera.focusOnNextPlayer();
              break;
            case "pause":
              this.state.paused = !this.state.paused;
              break;
            case "settings":
              this.openDialog("settings");
              break;
            case "exit_fullscreen":
              this.exitFullscreen();
              break;
            case "change_vehicle":
              this.toggleVehicle();
              break;
            case "zoom_increase":
              camera.increaseZoom();
              break;
            case "zoom_decrease":
              camera.decreaseZoom();
              break;
            case "fullscreen":
              this.toggleFullscreen();
          }
        }
      },
      exitFullscreen : function() {
        if (this.settings.fullscreenAvailable) {
          this.settings.fullscreen = false;
          this.state.fullscreen = false;
          this.trackEvent("game-ui", "game-fullscreen-toggle", "game-out-fullscreen");
        }
      },
      toggleFullscreen : function() {
        if (this.settings.embedded) {
          var options = this.settings;
          var facebookString = options.basePlatformUrl + "/t/" + options.track.url;
          window.open(facebookString);
        } else {
          if (this.settings.fullscreenAvailable) {
            this.settings.fullscreen = !this.settings.fullscreen;
            this.state.fullscreen = !this.settings.fullscreen;
            if (this.settings.fullscreen) {
              this.trackEvent("game-ui", "game-fullscreen-toggle", "game-into-fullscreen");
            } else {
              this.trackEvent("game-ui", "game-fullscreen-toggle", "game-out-fullscreen");
            }
          }
        }
      },
      trackEvent : function(name, val, type) {
        var types = {
          category : name,
          action : val,
          label : type,
          value : 0,
          non_interaction : true
        };
        that.track_event(types);
      },
      getAvailableTrackCode : function() {
        var attrs = this.settings;
        var isoOptions = false;
        return attrs.importCode && "false" !== attrs.importCode ? (isoOptions = attrs.importCode, attrs.importCode = null) : this.importCode && (isoOptions = this.importCode, this.importCode = null), isoOptions;
      },
      createMainPlayer : function() {
        var self = this.playerManager;
        var p3 = self.createPlayer(this, this.settings.user);
        var action = p3.getGamepad();
        action.setKeyMap(this.settings.playHotkeys);
        action.recordKeys(this.settings.keysToRecord);
        action.onButtonDown = this.buttonDown.bind(this);
        action.listen();
        this.playerManager.firstPlayer = p3;
        this.playerManager.addPlayer(p3);
      },
      createTrack : function() {
        if (this.track) {
          this.track.close();
        }
        var scope = new Scope(this);
        var partial = this.getAvailableTrackCode();
        if (0 != partial) {
          scope.read(partial);
          this.track = scope;
          this.setTrackAllowedVehicles();
          this.state.preloading = false;
          this.loading = false;
          this.restartTrack = true;
          this.ready = true;
        }
        this.track = scope;
      },
      setTrackAllowedVehicles : function() {
        var vehicleObj = this.track;
        var data = this.settings.track;
        if (data) {
          vehicleObj.allowedVehicles = data.vehicles;
        }
      },
      initalizeCamera : function() {
        this.camera = new Camera(this);
      },
      updateControls : function() {
        if (this.controls) {
          var value = this.state.paused;
          if (this.controls.isVisible() === value) {
            if (!value) {
              this.state.playing = false;
              this.camera.focusOnMainPlayer();
              this.toolHandler.setTool("camera");
            }
            this.controls.setVisibility(!value);
            this.controls.setZoomControlsVisibilty(value);
            this.updateState();
          }
          this.controls.update();
        }
        this.pauseControls.update();
        if (this.settings.fullscreenAvailable) {
          this.fullscreenControls.update();
        }
      },
      registerTools : function() {
        var self = new EventDispatcher(this);
        this.toolHandler = self;
        self.registerTool(type);
        self.setTool("Camera");
      },
      updateToolHandler : function() {
        if (!(this.controls && this.controls.isVisible() !== false)) {
          this.toolHandler.update();
        }
      },
      update : function() {
        if (this.ready) {
          this.updateToolHandler();
          this.mouse.update();
          if (!(this.state.paused || this.state.showDialog)) {
            this.updateGamepads();
            this.checkGamepads();
          }
          this.screen.update();
          this.updateControls();
          this.camera.update();
          this.sound.update();
          if (this.restartTrack) {
            this.restart();
          }
          if (!this.state.paused && this.state.playing) {
            this.message.update();
            this.updatePlayers();
            if (this.playerManager.firstPlayer.complete) {
              this.trackComplete();
            } else {
              this.ticks++;
            }
          }
          this.updateScore();
          this.vehicleTimer.update();
          if (this.isStateDirty()) {
            this.updateState();
          }
          this.stage.clear();
          this.draw();
          this.stage.update();
          this.camera.updateZoom();
        } else {
          if (this.importCode) {
            this.createTrack();
          }
        }
      },
      isStateDirty : function() {
        var evalContextV1 = this.oldState;
        var state = this.state;
        if (state.fullscreen != GameSettings.fullscreen) {
          state.fullscreen = GameSettings.fullscreen;
        }
        var i = false;
        var prop;
        for (prop in state) {
          if (state[prop] !== evalContextV1[prop]) {
            i = true;
            this.oldState[prop] = state[prop];
          }
        }
        return i;
      },
      updateScore : function() {
        this.score.update();
        if (this.campaignScore) {
          this.campaignScore.update();
        }
        this.raceTimes.update();
      },
      restart : function() {
        if (this.settings.mobile) {
          this.message.show("Press Any Button To Start", 1, "#333333");
        } else {
          this.message.show("Press Any Key To Start", 1, "#333333", "#FFFFFF");
        }
        this.track.resetPowerups();
        this.restartTrack = false;
        this.state.paused = false;
        this.state.playing = !this.settings.waitForKeyPress;
        this.ticks = 0;
        this.playerManager.reset();
        if (this.playerManager.getPlayerCount() > 0) {
          this.camera.focusIndex = 1;
        }
        this.camera.focusOnPlayer();
        this.camera.fastforward();
        this.showControlPlanel("main");
      },
      listen : function() {
        var controller = this.playerManager.firstPlayer;
        var destServer = controller.getGamepad();
        destServer.listen();
      },
      unlisten : function() {
        var controller = this.playerManager.firstPlayer;
        var comm = controller.getGamepad();
        comm.unlisten();
      },
      stopAudio : function() {
        createjs.Sound.stop();
      },
      setStartingVehicle : function() {
        var data = this.settings;
        var vehicles = data.startVehicle;
        if (data.track) {
          vehicles = data.track.vehicle;
        }
        this.vehicle = vehicles;
      },
      updateGamepads : function() {
        this.playerManager.updateGamepads();
      },
      checkGamepads : function() {
        this.playerManager.checkKeys();
      },
      updatePlayers : function() {
        this.playerManager.update();
      },
      drawPlayers : function() {
        this.playerManager.draw();
      },
      hideControlPlanel : function() {
        if (this.state.showSkip) {
          this.state.showSkip = false;
        }
        if (this.state.showControls !== false) {
          this.state.showControls = false;
        }
      },
      showControlPlanel : function(val) {
        if (this.settings.isCampaign && !this.settings.mobile && this.settings.campaignData.can_skip && this.analytics && this.analytics.deaths > 5) {
          this.state.showSkip = true;
        }
        if (this.stateshowControls !== val && this.settings.showHelpControls) {
          this.state.showControls = val;
        }
      },
      draw : function() {
        this.toolHandler.drawGrid();
        this.track.draw();
        this.drawPlayers();
        if (!(this.controls && this.controls.isVisible() !== false)) {
          this.toolHandler.draw();
        }
        if (this.loading) {
          this.loadingcircle.draw();
        }
        this.message.draw();
      },
      redraw : function() {
        this.track.undraw();
        GameInventoryManager.redraw();
        this.toolHandler.resize();
      },
      resize : function() {
        this.pauseControls.resize();
        if (this.settings.fullscreenAvailable) {
          this.fullscreenControls.resize();
        }
        this.settingsControls.resize();
        if (this.controls) {
          this.controls.resize();
        }
      },
      updateState : function() {
        if (null !== this.game.onStateChange) {
          this.game.onStateChange(this.state);
        }
      },
      stateChanged : function() {
        this.updateState();
      },
      setStateDefaults : function() {
        var settings = {};
        return settings.playing = !this.settings.waitForKeyPress, settings.paused = false, settings.playerAlive = true, settings.inFocus = true, settings.preloading = true, settings.fullscreen = this.settings.fullscreen, settings.showControls = false, settings.showSkip = false, settings.showDialog = false, settings.dialogOptions = false, settings;
      },
      toggleVehicle : function() {
        var format = this.track.allowedVehicles;
        var l = format.length;
        var separator = this.vehicle;
        var separatorIndex = format.indexOf(separator);
        separatorIndex++;
        if (separatorIndex >= l) {
          separatorIndex = 0;
        }
        separator = format[separatorIndex];
        this.selectVehicle(separator);
      },
      selectVehicle : function(separator) {
        var element = this.track.allowedVehicles;
        var separtorDimension = element.indexOf(separator);
        if (-1 !== separtorDimension) {
          this.settings.track.vehicle = separator;
          this.vehicle = separator;
          this.playerManager.firstPlayer.setBaseVehicle(separator);
          this.restartTrack = true;
        }
      },
      openDialog : function(name) {
        this.state.playing = false;
        this.state.showDialog = name;
      },
      command : function() {
        var v = Array.prototype.slice.call(arguments, 0);
        var type = v.shift();
        switch(type) {
          case "resize":
            this.resize();
            break;
          case "dialog":
            var cb = v[0];
            if (cb === false) {
              this.listen();
            } else {
              this.unlisten();
            }
            this.openDialog(cb);
            break;
          case "focused":
            var blobId = v[0];
            if (blobId === true) {
              this.state.inFocus = true;
              if (this.state.showDialog === false) {
                this.listen();
              }
            } else {
              this.state.inFocus = false;
              this.unlisten();
              this.state.playing = false;
            }
            break;
          case "add track":
            var min = v[0];
            this.importCode = min.code;
            break;
          case "clear race":
            this.races = [];
            this.restartTrack = true;
            this.raceTimes.clear();
            break;
          case "add race":
            var versions = v[0];
            var timeSignDenom = v[1];
            this.addRaces(versions);
            if (timeSignDenom) {
              this.state.dialogOptions = {
                races : this.races
              };
              this.command("dialog", "race_dialog");
            }
            break;
          case "change vehicle":
            var x = v[0];
            this.selectVehicle(x);
            break;
          case "restart":
            this.command("dialog", false);
            this.restartTrack = true;
            break;
          case "resume":
            this.state.paused = false;
            break;
          case "fullscreen":
            this.toggleFullscreen();
            break;
          case "exit_fullscreen":
            this.exitFullscreen();
        }
      },
      addRaces : function(type) {
        this.mergeRaces(type);
        this.sortRaces();
        this.formatRaces();
        this.addRaceTimes();
        this.addPlayers();
        this.restartTrack = true;
      },
      addRaceTimes : function() {
        var pieBackgroundColor = this.settings.raceColors;
        var pBCL = pieBackgroundColor.length;
        var mqs = this.races;
        var s = this.raceTimes;
        s.clear();
        var i;
        for (i in mqs) {
          var val = mqs[i];
          val.user.color = pieBackgroundColor[i % pBCL];
          s.addRace(val, i);
        }
      },
      addPlayers : function() {
        var defined = this.races;
        var game = this.playerManager;
        game.clear();
        var i = this.settings.keysToRecord;
        var id;
        for (id in defined) {
          var e = defined[id];
          var x = e.user;
          var data = e.race;
          var value = data.code;
          if ("string" == typeof value) {
            value = JSON.parse(value);
          }
          var p1 = game.createPlayer(this, x);
          p1.setBaseVehicle(data.vehicle);
          p1.setAsGhost();
          var harParser = p1.getGamepad();
          harParser.loadPlayback(value, i);
          game.addPlayer(p1);
        }
      },
      formatRaces : function() {
        var bookIDs = this.races;
        var bookIdIndex;
        for (bookIdIndex in bookIDs) {
          var msg = bookIDs[bookIdIndex].race;
          var data = msg.code;
          if ("string" == typeof data) {
            data = JSON.parse(data);
            var i;
            for (i in data) {
              var result = data[i];
              var parsed = _.countBy(result, _.identity);
              data[i] = parsed;
            }
            msg.code = data;
          }
        }
      },
      removeDuplicateRaces : function() {
        var t = _.uniq(this.races, this.uniqesByUserIdIterator.bind(this));
        this.races = t;
      },
      uniqesByUserIdIterator : function(htmlAndUser) {
        var user = htmlAndUser.user;
        return user.u_id;
      },
      sortRaces : function() {
        var t = _.sortBy(this.races, this.sortByRunTicksIterator.bind(this));
        this.races = t;
      },
      mergeRaces : function(attrValues) {
        var e = this.races;
        _.each(attrValues, function(object) {
          var i = _.find(e, function($scope) {
            return $scope.user.u_id === object.user.u_id;
          });
          if (i) {
            _.extend(i, object);
          } else {
            e.push(object);
          }
        });
      },
      sortByRunTicksIterator : function(q) {
        var s = this.settings;
        var i = parseInt(q.race.run_ticks);
        var n = normalize(i / s.drawFPS * 1e3);
        return q.runTime = n, i;
      },
      verifyComplete : function() {
        var THIS = this.playerManager.firstPlayer;
        var targets = THIS._powerupsConsumed.targets;
        var radius = this.track.targets;
        var s = true;
        var side;
        for (side in radius) {
          var r = radius[side];
          var source = r.id;
          if (-1 === targets.indexOf(source)) {
            s = false;
          }
        }
        return s;
      },
      trackComplete : function() {
        if (this.verifyComplete()) {
          this.sound.play("victory_sound");
          var $scope = this.playerManager;
          $scope.mutePlayers();
          var ctrl = $scope.firstPlayer;
          var applyViewModelsSpy = ctrl.getGamepad();
          var aerisCode = applyViewModelsSpy.getReplayString();
          var metadata = this.settings;
          var encoderPadding = this.ticks;
          var time = normalize(encoderPadding / metadata.drawFPS * 1e3);
          var a = $("#track-data").data("t_id");
          var data = {
            t_id : a,
            u_id : metadata.user.u_id,
            code : aerisCode,
            vehicle : ctrl._baseVehicleType,
            run_ticks : encoderPadding,
            fps : 25,
            time : time
          };
          var value = data.t_id + "|" + data.u_id + "|" + data.code + "|" + data.run_ticks + "|" + data.vehicle + "|" + data.fps + "|erxrHHcksIHHksktt8933XhwlstTekz";
          var uid = CryptoJS.SHA256(value).toString();
          data.sig = uid;
          var candidate_globals = this.races;
          var xmax = candidate_globals.length;
          var betterBeans = [];
          if (xmax > 0) {
            var x = 0;
            for (; xmax > x; x++) {
              betterBeans.push(candidate_globals[x].user.u_id);
            }
            data.races = betterBeans;
          }
          if (metadata.isCampaign) {
            data.is_campaign = true;
          }
          this.state.dialogOptions = {
            postData : data,
            analytics : this.analytics
          };
          if (metadata.isCampaign) {
            this.command("dialog", "campaign_complete");
          } else {
            this.command("dialog", "track_complete");
          }
          applyViewModelsSpy.reset(true);
          this.listen();
        }
      },
      drawFPS : function() {
        var total = createjs.Ticker.getMeasuredFPS();
        var i = this.game.pixelRatio;
        var ctx = this.game.canvas.getContext("2d");
        var thickness = 5;
        var labelsY = this.screen.height - 12 * i;
        var m = round(10 * total) / 10;
        var recordText = "FPS : " + m;
        ctx.save();
        ctx.fillStyle = "#000000";
        ctx.font = 8 * i + "pt arial";
        ctx.fillText(recordText, thickness * i, labelsY);
        ctx.restore();
      },
      close : function() {
        this.fullscreenControls = null;
        this.settingsControls = null;
        this.pauseControls = null;
        this.raceTimes = null;
        this.score = null;
        this.campaignScore = null;
        this.mouse.close();
        this.mouse = null;
        this.camera.close();
        this.camera = null;
        this.screen.close();
        this.screen = null;
        this.vehicleTimer.close();
        this.vehicleTimer = null;
        this.playerManager.close();
        this.playerManager = null;
        this.sound.close();
        this.sound = null;
        this.track.close();
        this.toolHandler.close();
        this.game = null;
        this.assets = null;
        this.settings = null;
        this.stage = null;
        this.track = null;
        this.state = null;
        this.stopAudio();
      }
    };
    context.exports = init;
  }, {
    "../../libs/lodash-3.10.1" : 90,
    "../controls/fullscreen" : 4,
    "../controls/pause" : 5,
    "../controls/phone" : 6,
    "../controls/settings" : 8,
    "../controls/tablet" : 9,
    "../math/cartesian" : 14,
    "../tools/cameratool" : 35,
    "../tools/toolhandler" : 50,
    "../tracks/track" : 56,
    "../utils/campaignscore" : 57,
    "../utils/formatnumber" : 59,
    "../utils/gamepad" : 60,
    "../utils/loadingcircle" : 61,
    "../utils/messagemanager" : 62,
    "../utils/mousehandler" : 63,
    "../utils/racetimes" : 65,
    "../utils/score" : 66,
    "../utils/sha256" : 67,
    "../utils/soundmanager" : 68,
    "../utils/vehicletimer" : 69,
    "../vehicles/bmx" : 72,
    "../vehicles/mtb" : 78,
    "../vehicles/player_manager" : 80,
    "../view/camera" : 87,
    "../view/screen" : 88
  }],
  18 : [function(__webpack_require__, context) {
    function init(value, data, options, name) {
      var u = new User(value, data);
      var t = new User(options, name);
      var b = t.sub(u);
      this.p1 = u;
      this.p2 = t;
      this.pp = b;
      this.len = b.len();
      this.sectors = [];
      this.collided = false;
      this.remove = false;
      this.highlight = false;
      this.recorded = false;
    }
    var User = __webpack_require__("../math/cartesian");
    var m = Math.sqrt;
    var pow = Math.pow;
    var floor = (Math.round, Math.floor);
    init.prototype = {
      sectors : null,
      p1 : null,
      p2 : null,
      pp : null,
      len : 0,
      collided : false,
      remove : false,
      highlight : false,
      recorded : false,
      getCode : function(e) {
        this.recorded = true;
        var p = this.p2;
        var msg = " " + p.x.toString(32) + " " + p.y.toString(32);
        var x = this.checkForConnectedLine(e, p);
        return x && (msg = msg + x.getCode(e)), msg;
      },
      checkForConnectedLine : function(c, e) {
        var h = c.settings.physicsSectorSize;
        var HuffTab = c.sectors.physicsSectors;
        var i = floor(e.x / h);
        var j = floor(e.y / h);
        return HuffTab[i][j].searchForLine("physicsLines", e);
      },
      addSectorReference : function(t) {
        this.sectors.push(t);
      },
      removeAllReferences : function() {
        this.remove = true;
        var objects = this.sectors;
        var l = objects.length;
        var i = 0;
        for (; l > i; i++) {
          objects[i].drawn = false;
          objects[i].dirty = true;
        }
        this.sectors = [];
      },
      erase : function(s, start) {
        var instance = false;
        if (!this.remove) {
          var p1 = this.p1;
          var p2 = this.p2;
          var d = s;
          var tca = start;
          var u = p2.sub(p1);
          var v1 = p1.sub(d);
          var a = u.dot(u);
          var roundDistance = 2 * v1.dot(u);
          var sampleWidth = v1.dot(v1) - tca * tca;
          var e = roundDistance * roundDistance - 4 * a * sampleWidth;
          if (e > 0) {
            e = m(e);
            var f = (-roundDistance - e) / (2 * a);
            var v = (-roundDistance + e) / (2 * a);
            if (f >= 0 && 1 >= f) {
              instance = true;
              this.removeAllReferences();
            }
            if (v >= 0 && 1 >= v) {
              instance = true;
              this.removeAllReferences();
            }
          }
          if (this.intersects(this.p1.x, this.p1.y, s.x, s.y, start)) {
            instance = true;
            this.removeAllReferences();
          } else {
            if (this.intersects(this.p2.x, this.p2.y, s.x, s.y, start)) {
              instance = true;
              this.removeAllReferences();
            }
          }
        }
        return instance;
      },
      intersects : function(height, top, width, y, left) {
        var lightI = height - width;
        var lightJ = top - y;
        return left * left >= lightI * lightI + lightJ * lightJ;
      },
      collide : function(obj) {
        if (!this.collided) {
          this.collided = true;
          var pos = obj.pos;
          var scale = obj.vel;
          var h = obj.radius;
          var x = 0;
          var y = 0;
          var w = 0;
          var p1 = this.p1;
          var p2 = this.p2;
          var width = pos.x - p1.x;
          var height = pos.y - p1.y;
          var me = this.pp;
          var n = this.len;
          var value = (width * me.x + height * me.y) / n / n;
          if (value >= 0 && 1 >= value) {
            var z = (width * me.y - height * me.x) * ((width - scale.x) * me.y - (height - scale.y) * me.x) < 0 ? -1 : 1;
            x = width - me.x * value;
            y = height - me.y * value;
            if (w = m(pow(x, 2) + pow(y, 2)), 0 === w && (w = 1), h > w || 0 > z) {
              var ratio = (h * z - w) / w;
              return pos.x += x * ratio, pos.y += y * ratio, void obj.drive(-y / w, x / w);
            }
          }
          if (!(-h > value * n || value * n > n + h)) {
            var p = value > 0 ? p2 : p1;
            if (x = pos.x - p.x, y = pos.y - p.y, w = m(pow(x, 2) + pow(y, 2)), 0 === w && (w = 1), h > w) {
              ratio = (h - w) / w;
              return pos.x += x * ratio, pos.y += y * ratio, void obj.drive(-y / w, x / w);
            }
          }
        }
      }
    };
    context.exports = init;
  }, {
    "../math/cartesian" : 14
  }],
  19 : [function(saveNotifs, context) {
    function block() {
    }
    var sqrt = (saveNotifs("../math/cartesian"), Math.PI, Math.sqrt);
    var square = Math.pow;
    var c = block.prototype;
    c.init = function(node) {
      this.game = node.scene.game;
      this.scene = node.scene;
      this.settings = this.game.settings;
      this.remove = false;
    };
    c.scene = null;
    c.angle = 0;
    c.x = 0;
    c.y = 0;
    c.name = null;
    c.sector = null;
    c.settings = null;
    c.remove = false;
    c.getCode = function() {
    };
    c.draw = function() {
    };
    c.erase = function(obj, start) {
      var instance = false;
      if (!this.remove) {
        var len = sqrt(square(obj.x - this.x, 2) + square(obj.y - this.y, 2));
        if (start >= len) {
          instance = [this];
          this.removeAllReferences();
        }
      }
      return instance;
    };
    c.removeAllReferences = function() {
      this.remove = true;
      if (this.sector) {
        this.sector.powerupCanvasDrawn = false;
        this.sector.dirty = true;
        this.sector = null;
      }
      this.scene.track.cleanPowerups();
    };
    c.collide = function(other) {
      var dx = other.pos.x - this.x;
      var dy = other.pos.y - this.y;
      var expected = sqrt(square(dx, 2) + square(dy, 2));
      if (!this.hit && 26 > expected) {
        this.hit = true;
        this.sector.powerupCanvasDrawn = false;
      }
    };
    c.addSectorReference = function(sector) {
      this.sector = sector;
    };
    context.exports = block;
  }, {
    "../math/cartesian" : 14
  }],
  20 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.init(obj);
    }
    var Observable = require("../powerup");
    var square = (Math.max, Math.sqrt, Math.pow);
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 25,
      height : 25
    };
    var me = Entity.prototype = new Observable;
    me.x = 0;
    me.y = 0;
    me.name = "antigravity";
    me.getCode = function() {
      return "A " + this.x.toString(32) + " " + this.y.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var m = canvas.width / 2;
      var uboard = canvas.height / 2;
      this.drawPowerup(m, uboard, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(color, x, r, b) {
      if (options.dirty) {
        this.recache(r);
      }
      var w = options.width * r;
      var d = options.height * r;
      var halfWidth = w / 2;
      var h = d / 2;
      var c = color;
      var y = x;
      b.translate(c, y);
      b.drawImage(options.canvas, -halfWidth, -h, w, d);
      b.translate(-c, -y);
    };
    me.drawPowerup = function(strategy, e, size, ctx) {
      size = size * 0.5;
      ctx.save();
      ctx.beginPath();
      ctx.scale(size, size);
      ctx.moveTo(0, 0);
      ctx.lineTo(50, 0);
      ctx.lineTo(50, 50);
      ctx.lineTo(0, 50);
      ctx.closePath();
      ctx.clip();
      ctx.translate(0, 0);
      ctx.translate(0, 0);
      ctx.scale(1, 1);
      ctx.translate(0, 0);
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = 1;
      ctx.translate(-726, -131);
      ctx.save();
      ctx.translate(726, 131);
      ctx.save();
      ctx.fillStyle = "#08faf3";
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(25, 36);
      ctx.bezierCurveTo(18.9251591, 36, 14, 31.0751824, 14, 25);
      ctx.bezierCurveTo(14, 18.9248176, 18.9251591, 14, 25, 14);
      ctx.bezierCurveTo(31.0751824, 14, 36, 18.9248176, 36, 25);
      ctx.bezierCurveTo(36, 31.0751824, 31.0751824, 36, 25, 36);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(25, 35);
      ctx.bezierCurveTo(30.5228976, 35, 35, 30.5228976, 35, 25);
      ctx.bezierCurveTo(35, 19.4771024, 30.5228976, 15, 25, 15);
      ctx.bezierCurveTo(19.4773211, 15, 15, 19.4772251, 15, 25);
      ctx.bezierCurveTo(15, 30.5227749, 19.4773211, 35, 25, 35);
      ctx.closePath();
      ctx.moveTo(25, 37);
      ctx.bezierCurveTo(18.3727612, 37, 13, 31.627354, 13, 25);
      ctx.bezierCurveTo(13, 18.372646, 18.3727612, 13, 25, 13);
      ctx.bezierCurveTo(31.6274671, 13, 37, 18.3725329, 37, 25);
      ctx.bezierCurveTo(37, 31.6274671, 31.6274671, 37, 25, 37);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(1.0370609, 29.702878);
      ctx.lineTo(0.571767448, 27.3196417);
      ctx.lineTo(10.8190136, 27.3196417);
      ctx.lineTo(11.2235626, 28.7886215);
      ctx.bezierCurveTo(12.5553335, 33.6244869, 16.3752072, 37.4442862, 21.2110994, 38.7761385);
      ctx.lineTo(22.6800518, 39.1807024);
      ctx.lineTo(22.6800518, 49.4279421);
      ctx.lineTo(20.2968028, 48.9626301);
      ctx.bezierCurveTo(10.5816525, 47.0658182, 2.93381735, 39.4180779, 1.0370609, 29.702878);
      ctx.closePath();
      ctx.moveTo(48.9629391, 20.297122);
      ctx.lineTo(49.4282326, 22.6803583);
      ctx.lineTo(39.1809639, 22.6803583);
      ctx.lineTo(38.7764299, 21.2113511);
      ctx.bezierCurveTo(37.4446547, 16.3752014, 33.624798, 12.5554192, 28.7886215, 11.2235626);
      ctx.lineTo(27.3196417, 10.8190136);
      ctx.lineTo(27.3196417, 0.571783441);
      ctx.lineTo(29.7028653, 1.03705842);
      ctx.bezierCurveTo(39.418382, 2.93381152, 47.0661305, 10.5816549, 48.9629391, 20.297122);
      ctx.closePath();
      ctx.moveTo(11.2235701, 21.2113511);
      ctx.lineTo(10.8190361, 22.6803583);
      ctx.lineTo(0.571767448, 22.6803583);
      ctx.lineTo(1.0370609, 20.297122);
      ctx.bezierCurveTo(2.93380373, 10.5819918, 10.5815702, 2.93422536, 20.2967378, 1.03707606);
      ctx.lineTo(22.6800518, 0.571669532);
      ctx.lineTo(22.6800518, 10.8189911);
      ctx.lineTo(21.2110994, 11.223555);
      ctx.bezierCurveTo(16.3751604, 12.5554202, 12.5553324, 16.3752482, 11.2235701, 21.2113511);
      ctx.closePath();
      ctx.moveTo(29.7028653, 48.9626351);
      ctx.lineTo(27.3196417, 49.4279101);
      ctx.lineTo(27.3196417, 39.1806799);
      ctx.lineTo(28.7886215, 38.7761309);
      ctx.bezierCurveTo(33.6247513, 37.4442873, 37.4446537, 33.6245336, 38.7764374, 28.7886215);
      ctx.lineTo(39.1809864, 27.3196417);
      ctx.lineTo(49.4282326, 27.3196417);
      ctx.lineTo(48.9629391, 29.702878);
      ctx.bezierCurveTo(47.0661446, 39.4182726, 39.4184545, 47.0658678, 29.7028653, 48.9626351);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#08faf3";
      ctx.beginPath();
      ctx.moveTo(3, 29.3196417);
      ctx.bezierCurveTo(4.74079001, 38.2359804, 11.7640196, 45.2589035, 20.6800518, 46.9996935);
      ctx.lineTo(20.6800518, 40.7043471);
      ctx.bezierCurveTo(15.1649961, 39.1854465, 10.814247, 34.8350039, 9.29534642, 29.3196417);
      ctx.lineTo(3, 29.3196417);
      ctx.closePath();
      ctx.moveTo(47, 20.6803583);
      ctx.bezierCurveTo(45.25921, 11.7640196, 38.2362869, 4.74079001, 29.3196417, 3);
      ctx.lineTo(29.3196417, 9.29534642);
      ctx.bezierCurveTo(34.8350039, 10.814247, 39.185753, 15.1646897, 40.7046536, 20.6803583);
      ctx.lineTo(47, 20.6803583);
      ctx.closePath();
      ctx.moveTo(9.29534642, 20.6803583);
      ctx.bezierCurveTo(10.814247, 15.1646897, 15.1649961, 10.814247, 20.6800518, 9.29534642);
      ctx.lineTo(20.6800518, 3);
      ctx.bezierCurveTo(11.7640196, 4.74109649, 4.74079001, 11.7640196, 3, 20.6803583);
      ctx.lineTo(9.29534642, 20.6803583);
      ctx.closePath();
      ctx.moveTo(29.3196417, 46.9996935);
      ctx.bezierCurveTo(38.2362869, 45.2589035, 45.25921, 38.2359804, 47, 29.3196417);
      ctx.lineTo(40.7046536, 29.3196417);
      ctx.bezierCurveTo(39.185753, 34.8350039, 34.8350039, 39.1854465, 29.3196417, 40.7043471);
      ctx.lineTo(29.3196417, 46.9996935);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
    };
    me.collide = function(that) {
      {
        var e = that.parent;
        var target = e.player;
        var dx = that.pos.x - this.x;
        var dy = that.pos.y - this.y;
        var o = square(dx, 2) + square(dy, 2);
        var allKids = e.masses;
        allKids.length;
      }
      if (1e3 > o && target.isAlive()) {
        if (target.isGhost() === false) {
          if (0 != e.gravity.x || 0 != e.gravity.y) {
            this.scene.sound.play("antigravity_sound", 0.3);
          }
          this.scene.message.show("Antigravity Engaged", 50, "#08faf3");
        }
        e.gravity.x = 0;
        e.gravity.y = 0;
      }
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  21 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.init(obj);
      this.hit = false;
    }
    var Observable = require("../powerup");
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 26,
      height : 26
    };
    var square = (Math.random, Math.pow);
    var sqrt = Math.sqrt;
    var me = (Math.cos, Math.sin, Entity.prototype = new Observable);
    me.x = 0;
    me.y = 0;
    me.name = "bomb";
    me.getCode = function() {
      return "O " + this.x.toString(32) + " " + this.y.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var x2 = canvas.width / 2;
      var y = canvas.height / 2;
      this.drawCircle(x2, y, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(x, y, scale, context) {
      if (!this.hit) {
        if (options.dirty) {
          this.recache(scale);
        }
        var w = options.width * scale;
        var height = options.height * scale;
        var radius = w / 2;
        var top = height / 2;
        context.drawImage(options.canvas, x - radius, y - top, w, height);
      }
    };
    me.drawCircle = function(e, r, scale, ctx) {
      scale = scale * 0.2;
      ctx.fillStyle = "#000";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 8 * scale;
      ctx.beginPath();
      ctx.moveTo(53 * scale, 105 * scale);
      ctx.lineTo(41.5 * scale, 115 * scale);
      ctx.lineTo(43 * scale, 100 * scale);
      ctx.bezierCurveTo(35.5 * scale, 95 * scale, 30 * scale, 88.5 * scale, 26.5 * scale, 80 * scale);
      ctx.lineTo(11 * scale, 78 * scale);
      ctx.lineTo(24 * scale, 69.5 * scale);
      ctx.bezierCurveTo(24 * scale, 68 * scale, 24 * scale, 67 * scale, 24 * scale, 66 * scale);
      ctx.bezierCurveTo(24 * scale, 58.5 * scale, 26 * scale, 51 * scale, 30 * scale, 45 * scale);
      ctx.lineTo(22 * scale, 31.5 * scale);
      ctx.lineTo(37.5 * scale, 36 * scale);
      ctx.bezierCurveTo(43.5 * scale, 31 * scale, 51 * scale, 27.5 * scale, 60 * scale, 26 * scale);
      ctx.lineTo(66 * scale, 11 * scale);
      ctx.lineTo(72 * scale, 26.5 * scale);
      ctx.bezierCurveTo(80.5 * scale, 27.5 * scale, 88 * scale, 31 * scale, 93.5 * scale, 36.5 * scale);
      ctx.lineTo(110 * scale, 31.5 * scale);
      ctx.lineTo(101.5 * scale, 46 * scale);
      ctx.bezierCurveTo(105 * scale, 52 * scale, 107 * scale, 59 * scale, 107 * scale, 66 * scale);
      ctx.bezierCurveTo(107 * scale, 67 * scale, 107 * scale, 68 * scale, 107 * scale, 69 * scale);
      ctx.lineTo(121 * scale, 78 * scale);
      ctx.lineTo(104.5 * scale, 80.5 * scale);
      ctx.bezierCurveTo(101.5 * scale, 88 * scale, 96 * scale, 95 * scale, 89 * scale, 99.5 * scale);
      ctx.lineTo(90.5 * scale, 115 * scale);
      ctx.lineTo(78.5 * scale, 104.5 * scale);
      ctx.bezierCurveTo(74.5 * scale, 106 * scale, 70 * scale, 107 * scale, 65.5 * scale, 107 * scale);
      ctx.bezierCurveTo(61 * scale, 107 * scale, 57 * scale, 106 * scale, 53 * scale, 105 * scale);
      ctx.lineTo(53 * scale, 105 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(66 * scale, 66 * scale, 40 * scale, 0 * scale, 2 * Math.PI, true);
      ctx.lineWidth = 2 * scale;
      ctx.fillStyle = "#d12929";
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(66 * scale, 66 * scale, 8 * scale, 0 * scale, 2 * Math.PI, true);
      ctx.lineWidth = 2 * scale;
      ctx.fillStyle = "#000";
      ctx.fill();
      ctx.stroke();
    };
    me.collide = function(that) {
      var e = that.parent;
      var target = e.player;
      var dx = that.pos.x - this.x;
      var dy = that.pos.y - this.y;
      var sqrt8 = sqrt(square(dx, 2) + square(dy, 2));
      if (20 > sqrt8 && target.isAlive()) {
        e.explode();
        if (target.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
        }
      }
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  22 : [function(saveNotifs, module) {
    function Particle(v, c, r, x) {
      this.x = v;
      this.y = c;
      this.angle = r;
      this.realAngle = r;
      var n = (r - 180) / 360 * 2 * Math.PI;
      this.directionX = (-Math.sin(n)).toFixed(15) / 1;
      this.directionY = Math.cos(n).toFixed(15) / 1;
      this.init(x);
    }
    var GameObject = saveNotifs("../powerup");
    var square = (Math.max, Math.sqrt, Math.pow);
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 24,
      height : 16
    };
    var me = Particle.prototype = new GameObject;
    me.x = 0;
    me.y = 0;
    me.name = "boost";
    me.angle = 0;
    me.realAngle = 0;
    me.directionX = 0;
    me.directionY = 0;
    me.getCode = function() {
      return "B " + this.x.toString(32) + " " + this.y.toString(32) + " " + this.realAngle.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var x2 = canvas.width / 2;
      var y = canvas.height / 2;
      this.drawCircle(x2, y, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(key, str, scale, context) {
      if (options.dirty) {
        this.recache(scale);
      }
      var w = options.width * scale;
      var r = options.height * scale;
      var x = w / 2;
      var h = r / 2;
      var s = key;
      var y = str;
      var rotation = (this.angle - 90) * (Math.PI / 180);
      context.translate(s, y);
      context.rotate(rotation);
      context.drawImage(options.canvas, -x, -h, w, r);
      context.rotate(-rotation);
      context.translate(-s, -y);
    };
    me.drawCircle = function(x, r, scale, ctx) {
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "round";
      ctx.fillStyle = "#8ac832";
      ctx.strokeStyle = "#000000";
      scale = scale * 0.2;
      ctx.lineWidth = Math.max(8 * scale, 1);
      ctx.beginPath();
      ctx.moveTo(0 * scale, 0 * scale);
      ctx.lineTo(118 * scale, 0 * scale);
      ctx.lineTo(118 * scale, 81 * scale);
      ctx.lineTo(0 * scale, 81 * scale);
      ctx.closePath();
      ctx.beginPath();
      ctx.moveTo(3 * scale, 1.5 * scale);
      ctx.lineTo(35 * scale, 1.7 * scale);
      ctx.lineTo(66 * scale, 40 * scale);
      ctx.lineTo(34 * scale, 78 * scale);
      ctx.lineTo(4 * scale, 78 * scale);
      ctx.lineTo(36 * scale, 39 * scale);
      ctx.lineTo(3 * scale, 1.5 * scale);
      ctx.closePath();
      ctx.moveTo(53 * scale, 1.5 * scale);
      ctx.lineTo(85 * scale, 1.7 * scale);
      ctx.lineTo(116 * scale, 40 * scale);
      ctx.lineTo(84 * scale, 78 * scale);
      ctx.lineTo(54 * scale, 78 * scale);
      ctx.lineTo(85 * scale, 39 * scale);
      ctx.lineTo(53 * scale, 1.5 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    };
    me.collide = function(that) {
      var context = that.parent;
      var player = context.player;
      var dx = that.pos.x - this.x;
      var dy = that.pos.y - this.y;
      var o = square(dx, 2) + square(dy, 2);
      var attributes = context.masses;
      var length = attributes.length;
      var shiftX = this.directionX;
      var shiftY = this.directionY;
      if (1e3 > o && player.isAlive()) {
        var i = length - 1;
        for (; i >= 0; i--) {
          var p = attributes[i].pos;
          p.x += shiftX;
          p.y += shiftY;
        }
        if (player.isGhost() === false) {
          this.scene.sound.play("boost_sound");
          this.scene.message.show("Boost Engaged", 50, "#8ac832");
        }
      }
    };
    module.exports = Particle;
  }, {
    "../powerup" : 19
  }],
  23 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.id = random().toString(36).substr(2);
      this.init(obj);
    }
    var Observable = require("../powerup");
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var random = Math.random;
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 20,
      height : 32
    };
    var self = Entity.prototype = new Observable;
    self.x = 0;
    self.y = 0;
    self.name = "checkpoint";
    self.getCode = function() {
      return "C " + this.x.toString(32) + " " + this.y.toString(32);
    };
    self.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var x2 = canvas.width / 2;
      var y = canvas.height / 2;
      this.drawCircle(x2, y, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    self.setDirty = function(value) {
      options.dirty = value;
    };
    self.draw = function(x, y, scale, context) {
      if (options.dirty) {
        this.recache(scale);
      }
      var w = options.width * scale;
      var height = options.height * scale;
      var radius = w / 2;
      var top = height / 2;
      context.save();
      if (this.hit) {
        context.globalAlpha = 0.3;
      }
      context.drawImage(options.canvas, x - radius, y - top, w, height);
      context.restore();
    };
    self.drawCircle = function(e, r, scale, ctx) {
      scale = scale * 0.15;
      ctx.save();
      ctx.translate(1, 1);
      ctx.beginPath();
      ctx.moveTo(0 * scale, 0 * scale);
      ctx.lineTo(112 * scale, 0 * scale);
      ctx.lineTo(112 * scale, 95 * scale);
      ctx.lineTo(0 * scale, 95 * scale);
      ctx.closePath();
      ctx.fillStyle = "#826cdc";
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 8 * scale;
      ctx.beginPath();
      ctx.moveTo(3 * scale, 10 * scale);
      ctx.bezierCurveTo(3 * scale, 10 * scale, 33.5 * scale, 27 * scale, 55 * scale, 10 * scale);
      ctx.bezierCurveTo(76 * scale, -6 * scale, 108 * scale, 10 * scale, 108 * scale, 10 * scale);
      ctx.lineTo(109 * scale, 86 * scale);
      ctx.bezierCurveTo(109 * scale, 86 * scale, 74 * scale, 73.5 * scale, 56.5 * scale, 86 * scale);
      ctx.bezierCurveTo(40 * scale, 98 * scale, 3 * scale, 88.5 * scale, 3 * scale, 88.5 * scale);
      ctx.lineTo(3 * scale, 10 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 15 * scale;
      ctx.moveTo(3 * scale, 10 * scale);
      ctx.lineTo(3 * scale, 180 * scale);
      ctx.stroke();
      ctx.restore();
    };
    self.collide = function(target) {
      {
        var resolved = target.parent;
        var player = resolved.player;
        var x = target.pos.x - this.x;
        var y = target.pos.y - this.y;
        var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
        var nodesOnScreen = player._powerupsConsumed.checkpoints;
        this.scene;
      }
      if (26 > sqrt8 && player.isAlive() && -1 === nodesOnScreen.indexOf(this.id)) {
        nodesOnScreen.push(this.id);
        player.setCheckpointOnUpdate();
        if (player.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          this.scene.message.show("Checkpoint Saved", 50, "#826cdc", "#FFFFFF");
          this.scene.sound.play("checkpoint_sound");
        }
      }
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  24 : [function(saveNotifs, module) {
    function Particle(x, y, config, key) {
      this.x = x;
      this.y = y;
      this.angle = config - 180;
      this.realAngle = config;
      var bearingRad = this.angle / 360 * 2 * Math.PI;
      this.directionX = (-0.3 * Math.sin(bearingRad)).toFixed(15) / 1;
      this.directionY = (0.3 * Math.cos(bearingRad)).toFixed(15) / 1;
      this.init(key);
    }
    var GameObject = saveNotifs("../powerup");
    var square = (Math.max, Math.sqrt, Math.pow);
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 20,
      height : 20
    };
    var self = Particle.prototype = new GameObject;
    self.x = 0;
    self.y = 0;
    self.angle = 0;
    self.realAngle = 0;
    self.name = "gravity";
    self.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var expectedPackagePath = canvas.width / 2;
      var blobStagingPath = canvas.height / 2;
      this.drawArrow(expectedPackagePath, blobStagingPath, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 3 * scale;
        ctx.stroke();
      }
    };
    self.getCode = function() {
      return "G " + this.x.toString(32) + " " + this.y.toString(32) + " " + this.realAngle.toString(32);
    };
    self.setDirty = function(value) {
      options.dirty = value;
    };
    self.draw = function(key, str, scale, context) {
      if (options.dirty) {
        this.recache(scale);
      }
      var w = options.width * scale;
      var r = options.height * scale;
      var x = w / 2;
      var h = r / 2;
      var s = key;
      var y = str;
      var rotation = (this.angle + 90) * (Math.PI / 180);
      context.translate(s, y);
      context.rotate(rotation);
      context.drawImage(options.canvas, -x, -h, w, r);
      context.rotate(-rotation);
      context.translate(-s, -y);
    };
    self.drawArrow = function(to, path, scale, ctx) {
      scale = scale * 0.2;
      ctx.beginPath();
      ctx.moveTo(0 * scale, 0 * scale);
      ctx.lineTo(97 * scale, 0 * scale);
      ctx.lineTo(97 * scale, 96 * scale);
      ctx.lineTo(0 * scale, 96 * scale);
      ctx.closePath();
      ctx.clip();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = Math.max(6 * scale, 1);
      ctx.save();
      ctx.fillStyle = "#376eb7";
      ctx.strokeStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(41 * scale, 70 * scale);
      ctx.lineTo(41 * scale, 95 * scale);
      ctx.lineTo(97 * scale, 48 * scale);
      ctx.lineTo(41 * scale, 1 * scale);
      ctx.lineTo(41 * scale, 25 * scale);
      ctx.lineTo(1 * scale, 25 * scale);
      ctx.lineTo(1 * scale, 70 * scale);
      ctx.lineTo(41 * scale, 70 * scale);
      ctx.closePath();
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    };
    self.collide = function(that) {
      var e = that.parent;
      var target = e.player;
      var dx = that.pos.x - this.x;
      var dy = that.pos.y - this.y;
      var o = square(dx, 2) + square(dy, 2);
      var allKids = e.masses;
      var xSpeedIncrease = (allKids.length, this.directionX);
      var defaultYPos = this.directionY;
      if (1e3 > o && target.isAlive()) {
        e.gravity.x = xSpeedIncrease;
        e.gravity.y = defaultYPos;
        if (target.isGhost() === false) {
          this.scene.message.show("Gravity Changed", 50, "#1F80C3", "#FFFFFF");
          this.scene.sound.play("gravity_down_sound");
        }
      }
    };
    module.exports = Particle;
  }, {
    "../powerup" : 19
  }],
  25 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.init(obj);
    }
    var Observable = require("../powerup");
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 24,
      height : 24
    };
    var me = Entity.prototype = new Observable;
    me.x = 0;
    me.y = 0;
    me.name = "slowmo";
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var x2 = canvas.width / 2;
      var y = canvas.height / 2;
      this.drawCircle(x2, y, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.getCode = function() {
      return "S " + this.x.toString(32) + " " + this.y.toString(32);
    };
    me.draw = function(x, y, scale, context) {
      if (options.dirty) {
        this.recache(scale);
      }
      var w = options.width * scale;
      var height = options.height * scale;
      var radius = w / 2;
      var top = height / 2;
      context.drawImage(options.canvas, x - radius, y - top, w, height);
    };
    me.collide = function(that) {
      var options = that.parent;
      var player = options.player;
      var x = that.pos.x - this.x;
      var y = that.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      if (!this.hit && 26 > sqrt8 && player.isAlive()) {
        options.slow = true;
        if (player.isGhost() === false) {
          this.scene.sound.play("slowmo_sound");
          this.scene.message.show("Slow Motion", 50, "#FFFFFF", "#000000");
        }
      }
    };
    me.drawCircle = function(e, r, scale, ctx) {
      ctx.save();
      ctx.beginPath();
      scale = scale * 0.2;
      ctx.moveTo(0 * scale, 0 * scale);
      ctx.lineTo(116 * scale, 0 * scale);
      ctx.lineTo(116 * scale, 114 * scale);
      ctx.lineTo(0 * scale, 114 * scale);
      ctx.closePath();
      ctx.fillStyle = "#FFF";
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = Math.max(3 * scale, 0.5);
      ctx.beginPath();
      ctx.moveTo(58 * scale, 111 * scale);
      ctx.bezierCurveTo(89 * scale, 111 * scale, 114 * scale, 87 * scale, 114 * scale, 56 * scale);
      ctx.bezierCurveTo(114 * scale, 26 * scale, 89 * scale, 2 * scale, 58 * scale, 2 * scale);
      ctx.bezierCurveTo(27.1748289 * scale, 2 * scale, 2 * scale, 26 * scale, 2 * scale, 56 * scale);
      ctx.bezierCurveTo(2 * scale, 87 * scale, 27.1748289 * scale, 111 * scale, 58 * scale, 111 * scale);
      ctx.closePath();
      ctx.moveTo(58 * scale, 103 * scale);
      ctx.bezierCurveTo(84 * scale, 103 * scale, 106 * scale, 82 * scale, 106 * scale, 56 * scale);
      ctx.bezierCurveTo(106 * scale, 30 * scale, 84 * scale, 9 * scale, 58 * scale, 9 * scale);
      ctx.bezierCurveTo(31 * scale, 9 * scale, 10 * scale, 30 * scale, 10 * scale, 56 * scale);
      ctx.bezierCurveTo(10 * scale, 82 * scale, 31 * scale, 103 * scale, 58 * scale, 103 * scale);
      ctx.closePath();
      ctx.moveTo(58 * scale, 55 * scale);
      ctx.lineTo(37 * scale, 23 * scale);
      ctx.lineTo(35 * scale, 25 * scale);
      ctx.lineTo(56 * scale, 57 * scale);
      ctx.lineTo(58 * scale, 55 * scale);
      ctx.closePath();
      ctx.moveTo(58.5 * scale, 59 * scale);
      ctx.lineTo(81.5 * scale, 59 * scale);
      ctx.lineTo(81.5 * scale, 56 * scale);
      ctx.lineTo(58.5 * scale, 56 * scale);
      ctx.lineTo(58.5 * scale, 59 * scale);
      ctx.closePath();
      ctx.moveTo(98.5 * scale, 59 * scale);
      ctx.lineTo(105.5 * scale, 59 * scale);
      ctx.lineTo(105.5 * scale, 56 * scale);
      ctx.lineTo(98.5 * scale, 56 * scale);
      ctx.lineTo(98.5 * scale, 59 * scale);
      ctx.closePath();
      ctx.moveTo(11.5 * scale, 59 * scale);
      ctx.lineTo(18.5 * scale, 59 * scale);
      ctx.lineTo(18.5 * scale, 56 * scale);
      ctx.lineTo(11.5 * scale, 56 * scale);
      ctx.lineTo(11.5 * scale, 59 * scale);
      ctx.closePath();
      ctx.moveTo(57 * scale, 96 * scale);
      ctx.lineTo(57 * scale, 101.5 * scale);
      ctx.lineTo(60 * scale, 101.5 * scale);
      ctx.lineTo(60 * scale, 96 * scale);
      ctx.lineTo(57 * scale, 96 * scale);
      ctx.closePath();
      ctx.moveTo(57 * scale, 12 * scale);
      ctx.lineTo(57 * scale, 17.5 * scale);
      ctx.lineTo(60 * scale, 17.5 * scale);
      ctx.lineTo(60 * scale, 12 * scale);
      ctx.lineTo(57 * scale, 12 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  26 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.hit = false;
      this.id = random().toString(36).substr(2);
      this.init(obj);
    }
    var Observable = require("../powerup");
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var random = Math.random;
    var options = {
      canvas : document.createElement("canvas"),
      width : 35,
      height : 35
    };
    var params = {
      canvas : document.createElement("canvas"),
      width : 35,
      height : 35
    };
    var hashCacheState = true;
    var self = Entity.prototype = new Observable;
    self.x = 0;
    self.y = 0;
    self.name = "goal";
    self.hit = false;
    self.superErase = self.erase;
    self.getCode = function() {
      return "T " + this.x.toString(32) + " " + this.y.toString(32);
    };
    self.recache = function(scale) {
      hashCacheState = false;
      this.cacheStar(scale);
      this.cacheEmptyStar(scale);
    };
    self.cacheStar = function(scale) {
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var ctx = canvas.getContext("2d");
      var position = canvas.width / 2;
      var charsetBitSize = canvas.height / 2;
      this.drawStar(position, charsetBitSize, 5, 10, 5, true, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    self.cacheEmptyStar = function(scale) {
      var c = params.canvas;
      c.width = params.width * scale;
      c.height = params.height * scale;
      var ctx = c.getContext("2d");
      var position = c.width / 2;
      var charsetBitSize = c.height / 2;
      this.drawStar(position, charsetBitSize, 5, 10, 5, false, scale, ctx);
      if (this.settings.developerMode) {
        ctx.beginPath();
        ctx.rect(0, 0, c.width, c.height);
        ctx.strokeStyle = "red";
        ctx.strokeWidth = 1 * scale;
        ctx.stroke();
      }
    };
    self.setDirty = function(state) {
      hashCacheState = state;
    };
    self.draw = function(x, y, scale, context) {
      if (this.hit) {
        var w = params.width * scale;
        var width = params.height * scale;
        var r = w / 2;
        var radius = width / 2;
        context.drawImage(params.canvas, x - r, y - radius, w, width);
      } else {
        if (hashCacheState) {
          this.recache(scale);
        }
        w = options.width * scale;
        width = options.height * scale;
        r = w / 2;
        radius = width / 2;
        context.drawImage(options.canvas, x - r, y - radius, w, width);
      }
    };
    self.drawStar = function(x, y, theta, r, i, color, scale, ctx) {
      var angle = Math.PI / 2 * 3;
      var dx = x;
      var top = y;
      var pi2 = Math.PI / theta;
      r = r * scale;
      i = i * scale;
      ctx.strokeSyle = "#000";
      ctx.beginPath();
      ctx.moveTo(x, y - r);
      var twoPI = 0;
      for (; theta > twoPI; twoPI++) {
        dx = x + Math.cos(angle) * r;
        top = y + Math.sin(angle) * r;
        ctx.lineTo(dx, top);
        angle = angle + pi2;
        dx = x + Math.cos(angle) * i;
        top = y + Math.sin(angle) * i;
        ctx.lineTo(dx, top);
        angle = angle + pi2;
      }
      ctx.lineTo(x, y - r);
      ctx.closePath();
      ctx.lineWidth = Math.max(2 * scale, 1);
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.fillStyle = color ? "#FAE335" : "#FFFFFF";
      ctx.fill();
    };
    self.collide = function(target) {
      var resolved = target.parent;
      var player = resolved.player;
      var x = target.pos.x - this.x;
      var y = target.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      var targets = player._powerupsConsumed.targets;
      var data = this.scene;
      if (26 > sqrt8 && player.isAlive() && -1 === targets.indexOf(this.id)) {
        targets.push(this.id);
        var l = targets.length;
        var r = data.track.targetCount;
        if (player.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          data.sound.play("goal_sound");
          data.message.show(l + " of " + r + " Stars", 50, "#FAE335", "#666666");
        }
        if (l >= r) {
          player.complete = true;
        }
      }
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  27 : [function(require, module) {
    function Entity(x, data, obj) {
      this.x = x;
      this.y = data;
      this.id = random().toString(36).substr(2);
      this.init(obj);
    }
    var Observable = require("../powerup");
    var getAlignItem = (Math.max, Math.sqrt);
    var square = Math.pow;
    var random = Math.random;
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 29,
      height : 32
    };
    var self = Entity.prototype = new Observable;
    self.id = null;
    self.otherPortal = null;
    self.hit = false;
    self.x = 0;
    self.y = 0;
    self.name = "teleport";
    self.recorded = false;
    self.erase = function(obj, prop) {
      var instance = false;
      if (!this.remove) {
        var alignContentAlignItem = getAlignItem(square(obj.x - this.x, 2) + square(obj.y - this.y, 2));
        if (prop >= alignContentAlignItem) {
          instance = [this, this.otherPortal];
          this.removeAllReferences();
          this.otherPortal.removeAllReferences();
        }
      }
      return instance;
    };
    self.addOtherPortalRef = function(array2) {
      this.otherPortal = array2;
    };
    self.getCode = function() {
      var th_field = "";
      return this.recorded === false && this.otherPortal.recorded === true ? this.recorded = true : this.recorded === false && this.otherPortal.recorded === false ? (this.recorded = true, th_field = "W " + this.x.toString(32) + " " + this.y.toString(32) + " " + this.otherPortal.x.toString(32) + " " + this.otherPortal.y.toString(32)) : this.recorded === true && this.otherPortal.recorded === true && (this.otherPortal.recorded = false, th_field = "W " + this.x.toString(32) + " " + this.y.toString(32) + 
      " " + this.otherPortal.x.toString(32) + " " + this.otherPortal.y.toString(32)), th_field;
    };
    self.setDirty = function(value) {
      options.dirty = value;
    };
    self.recache = function(value) {
      options.dirty = false;
      this.drawPowerup(value, options);
    };
    self.drawPowerup = function(scale, e) {
      var canvas = e.canvas;
      canvas.width = e.width * scale;
      canvas.height = e.height * scale;
      var ctx = canvas.getContext("2d");
      var n = (ctx.width / 2, ctx.height / 2, 0.65 * scale);
      ctx.save();
      ctx.scale(n, n);
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(44, 0);
      ctx.lineTo(44, 48);
      ctx.lineTo(0, 48);
      ctx.closePath();
      ctx.clip();
      ctx.translate(0, 0);
      ctx.translate(0, 0);
      ctx.scale(1, 1);
      ctx.translate(0, 0);
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = 1;
      ctx.translate(-788, -50);
      ctx.save();
      ctx.translate(790, 52);
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(17, 3);
      ctx.bezierCurveTo(16.9424049, 2.83458834, 16.4420628, 2.62968665, 15.9196825, 2.4515011);
      ctx.lineTo(8.51063934, -0.0757469011);
      ctx.lineTo(16.223952, -1.41205186);
      ctx.bezierCurveTo(21.2423806, -2.2814774, 25.8773816, -1.40451316, 29.9447883, 0.583562762);
      ctx.bezierCurveTo(31.7394578, 1.46076529, 33.0361403, 2.35169307, 33.7316821, 2.95217334);
      ctx.bezierCurveTo(35.1972328, 4.14751314, 36.509471, 5.52829294, 37.6336956, 7.05811132);
      ctx.bezierCurveTo(39.8993675, 10.1439271, 41.2801108, 13.6041318, 41.7252304, 17.3208639);
      ctx.bezierCurveTo(41.7397043, 17.4414782, 41.7543021, 17.5670407, 41.7704814, 17.7094344);
      ctx.bezierCurveTo(41.7921038, 17.9009058, 41.7921038, 17.9009058, 41.8132645, 18.0904969);
      ctx.lineTo(41.840873, 18.3390683);
      ctx.lineTo(41.8856209, 18.735971);
      ctx.lineTo(41.8856209, 21.4226506);
      ctx.lineTo(41.8542399, 21.5977061);
      ctx.bezierCurveTo(41.8009577, 21.89487, 41.7866262, 21.9747988, 41.7740749, 22.044061);
      ctx.bezierCurveTo(41.759051, 22.1809078, 41.759051, 22.1809078, 41.7559584, 22.2091488);
      ctx.bezierCurveTo(41.6872107, 22.8267498, 41.6438556, 23.1562694, 41.5609313, 23.6049736);
      ctx.bezierCurveTo(40.8769441, 27.3127264, 39.3221077, 30.5993535, 36.9456235, 33.3462518);
      ctx.bezierCurveTo(32.8945821, 38.029004, 27.65733, 40.5391341, 21.868366, 40.5391341);
      ctx.bezierCurveTo(21.742671, 40.5391341, 21.6184358, 40.538205, 21.4955986, 40.5363608);
      ctx.bezierCurveTo(22.1492681, 41.0434881, 22.8806236, 41.5794806, 23.6943816, 42.1440112);
      ctx.lineTo(28.4276887, 45.4276613);
      ctx.lineTo(22.6779106, 45.7834802);
      ctx.bezierCurveTo(18.1741264, 46.062192, 14.0554746, 45.155711, 10.4302114, 43.4736066);
      ctx.bezierCurveTo(8.54152696, 42.5972663, 7.17424655, 41.7066293, 6.38621142, 41.0629331);
      ctx.bezierCurveTo(4.99599225, 40.025971, 3.38305673, 38.3146562, 2.25448469, 36.778713);
      ctx.bezierCurveTo(-0.0125398982, 33.6943248, -1.39399999, 30.2338948, -1.84021156, 26.5118367);
      ctx.bezierCurveTo(-1.86468983, 26.3063181, -1.88762639, 26.1042985, -1.92006182, 25.811651);
      ctx.lineTo(-1.95463612, 25.5020237);
      ctx.lineTo(-2.00013072, 25.1020716);
      ctx.lineTo(-2.00013072, 22.4141906);
      ctx.lineTo(-1.96885958, 22.2394346);
      ctx.bezierCurveTo(-1.92214724, 21.9784071, -1.90657901, 21.8914122, -1.89618079, 21.8334198);
      ctx.bezierCurveTo(-1.83478692, 21.2274076, -1.79887919, 20.9331002, -1.72945035, 20.5323584);
      ctx.bezierCurveTo(-0.927733904, 15.885014, 1.1979378, 11.9079902, 4.5664052, 8.76464131);
      ctx.bezierCurveTo(8.29993169, 5.27968493, 12.7861394, 3.24768826, 17.4210789, 3.06365477);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#dd45ec";
      ctx.beginPath();
      ctx.moveTo(23.9052288, 5.91261647);
      ctx.bezierCurveTo(23.9052288, 5.91261647, 22.5543791, 5.13614588, 18.1099346, 5.04995765);
      ctx.bezierCurveTo(13.6479739, 5.05021647, 9.39411765, 6.99424, 5.93111111, 10.2266871);
      ctx.bezierCurveTo(2.88431373, 13.0698635, 0.969542484, 16.6517224, 0.241437908, 20.8723576);
      ctx.bezierCurveTo(0.169019608, 21.2903576, 0.131372549, 21.6617694, 0.101045752, 21.9601929);
      ctx.bezierCurveTo(0.0960784314, 22.0104047, 0.0911111111, 22.0611341, 0.0858823529, 22.1113459);
      ctx.bezierCurveTo(0.0837908497, 22.1227341, 0.0816993464, 22.1341224, 0.0796078431, 22.1452518);
      ctx.lineTo(-0.000130718954, 22.5917224);
      ctx.lineTo(-0.000130718954, 23.0451812);
      ctx.lineTo(-0.000130718954, 24.6993224);
      ctx.lineTo(-0.000130718954, 24.9886871);
      ctx.lineTo(0.0325490196, 25.2759812);
      ctx.lineTo(0.0675816993, 25.5896753);
      ctx.bezierCurveTo(0.0929411765, 25.8184753, 0.118562092, 26.0470165, 0.145751634, 26.2752988);
      ctx.bezierCurveTo(0.550457516, 29.6511341, 1.80196078, 32.7860047, 3.86601307, 35.59424);
      ctx.bezierCurveTo(4.76326797, 36.8153694, 6.27176471, 38.4928047, 7.6179085, 39.4864282);
      ctx.bezierCurveTo(7.6179085, 39.4864282, 13.4911111, 44.3481694, 22.5543791, 43.7872988);
      ctx.bezierCurveTo(16.5849673, 39.6461224, 15.7624837, 37.5460282, 15.7624837, 37.5460282);
      ctx.bezierCurveTo(16.4521569, 37.6208282, 18.1535948, 38.5391341, 21.868366, 38.5391341);
      ctx.bezierCurveTo(27.0628758, 38.5391341, 31.7535948, 36.2909929, 35.4330719, 32.0377459);
      ctx.bezierCurveTo(37.5739869, 29.5631341, 38.9739869, 26.6037459, 39.5941176, 23.2421459);
      ctx.bezierCurveTo(39.6816993, 22.76824, 39.7295425, 22.3354871, 39.7682353, 21.9878871);
      ctx.bezierCurveTo(39.7768627, 21.9092047, 39.7852288, 21.8300047, 39.7946405, 21.7510635);
      ctx.bezierCurveTo(39.7983007, 21.7319106, 39.8019608, 21.7124988, 39.8053595, 21.6930871);
      ctx.lineTo(39.8856209, 21.2448047);
      ctx.lineTo(39.8856209, 20.7895341);
      ctx.lineTo(39.8856209, 19.1356518);
      ctx.lineTo(39.8856209, 18.8483576);
      ctx.lineTo(39.8534641, 18.5631341);
      ctx.lineTo(39.8254902, 18.3112988);
      ctx.bezierCurveTo(39.7975163, 18.0607576, 39.7695425, 17.8096988, 39.7394771, 17.5591576);
      ctx.bezierCurveTo(39.3355556, 14.1864282, 38.0845752, 11.0515576, 36.0215686, 8.24176941);
      ctx.bezierCurveTo(34.9975163, 6.84826353, 33.8019608, 5.59038118, 32.4675817, 4.50202824);
      ctx.bezierCurveTo(32.4675817, 4.50202824, 25.996732, -1.07536, 16.5653595, 0.558592941);
      ctx.bezierCurveTo(21.6393464, 2.28934588, 23.9052288, 5.91261647, 23.9052288, 5.91261647);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#fefefe";
      ctx.beginPath();
      ctx.moveTo(5.22875817, 24.6992965);
      ctx.lineTo(5.22875817, 23.0451553);
      ctx.bezierCurveTo(5.24078431, 22.97812, 5.25647059, 22.9113435, 5.26457516, 22.8437906);
      ctx.bezierCurveTo(5.30823529, 22.4770376, 5.33254902, 22.1071788, 5.39555556, 21.7440494);
      ctx.bezierCurveTo(5.9179085, 18.7173671, 7.26117647, 16.0988494, 9.5179085, 13.9930612);
      ctx.bezierCurveTo(12.7882353, 10.9404965, 16.6520261, 9.83428471, 21.0614379, 10.8020259);
      ctx.bezierCurveTo(23.1579085, 11.2619553, 24.9563399, 12.2887082, 26.3997386, 13.8804729);
      ctx.bezierCurveTo(27.8005229, 15.4251318, 28.5681046, 17.2482847, 28.8130719, 19.3033435);
      ctx.bezierCurveTo(29.0044444, 20.9103788, 28.7861438, 22.4467553, 28.0836601, 23.9122141);
      ctx.bezierCurveTo(26.5186928, 27.1764965, 23.3458824, 28.74652, 19.8862745, 27.9666847);
      ctx.bezierCurveTo(17.6018301, 27.4518847, 16.0658824, 25.7762612, 15.7793464, 23.4833435);
      ctx.bezierCurveTo(15.7513725, 23.2566141, 15.7422222, 23.0278141, 15.7233987, 22.7920259);
      ctx.bezierCurveTo(15.6826144, 22.7959082, 15.6577778, 22.7959082, 15.6345098, 22.8013435);
      ctx.bezierCurveTo(15.2580392, 22.8929671, 15.0844444, 23.1867318, 14.9532026, 23.5037906);
      ctx.bezierCurveTo(14.6407843, 24.2592965, 14.6128105, 25.0383553, 14.8180392, 25.8238847);
      ctx.bezierCurveTo(15.1252288, 26.9999788, 15.8075817, 27.9480494, 16.7301961, 28.7162376);
      ctx.bezierCurveTo(19.105098, 30.6939082, 21.8201307, 31.2356259, 24.7777778, 30.3869435);
      ctx.bezierCurveTo(27.9027451, 29.4903788, 30.1628758, 27.5002847, 31.6556863, 24.6703082);
      ctx.bezierCurveTo(33.1751634, 21.7893435, 33.4169935, 18.73652, 32.7003922, 15.5969906);
      ctx.bezierCurveTo(32.1134641, 13.0263553, 30.9056209, 10.7471553, 29.2807843, 8.67397882);
      ctx.bezierCurveTo(29.2345098, 8.61496706, 29.1887582, 8.55595529, 29.1427451, 8.49694353);
      ctx.bezierCurveTo(30.1487582, 9.31767294, 31.0295425, 10.2476259, 31.7918954, 11.2855082);
      ctx.bezierCurveTo(33.305098, 13.3460024, 34.2433987, 15.6329671, 34.5471895, 18.1681435);
      ctx.bezierCurveTo(34.5856209, 18.4903788, 34.6206536, 18.8131318, 34.6569935, 19.1356259);
      ctx.lineTo(34.6569935, 20.7897671);
      ctx.bezierCurveTo(34.6449673, 20.8565435, 34.629281, 20.92332, 34.620915, 20.9908729);
      ctx.bezierCurveTo(34.5644444, 21.4313906, 34.5309804, 21.8763082, 34.4501961, 22.3121671);
      ctx.bezierCurveTo(34.0122876, 24.6873906, 33.0475817, 26.8374376, 31.4616993, 28.6706847);
      ctx.bezierCurveTo(28.1134641, 32.5408729, 23.9121569, 34.11012, 18.8256209, 33.0287553);
      ctx.bezierCurveTo(16.5994771, 32.5553671, 14.72, 31.4287082, 13.2504575, 29.68372);
      ctx.bezierCurveTo(11.9879739, 28.1846141, 11.2983007, 26.4463553, 11.0705882, 24.5126847);
      ctx.bezierCurveTo(10.871634, 22.8236024, 11.1286275, 21.2212259, 11.9113725, 19.7042612);
      ctx.bezierCurveTo(13.5228758, 16.5810376, 16.6386928, 15.0982376, 19.9803922, 15.8646141);
      ctx.bezierCurveTo(22.303268, 16.3975318, 23.7997386, 18.0288965, 24.1079739, 20.3696965);
      ctx.bezierCurveTo(24.136732, 20.5899553, 24.1440523, 20.8128024, 24.1662745, 21.1008729);
      ctx.bezierCurveTo(24.343268, 20.9921671, 24.5147712, 20.9334141, 24.6146405, 20.8153906);
      ctx.bezierCurveTo(24.7620915, 20.6414612, 24.8909804, 20.4375082, 24.970719, 20.2255318);
      ctx.bezierCurveTo(25.28, 19.4032494, 25.2648366, 18.5688024, 24.9890196, 17.7405671);
      ctx.bezierCurveTo(24.5738562, 16.4935553, 23.7654902, 15.5263318, 22.715817, 14.7615082);
      ctx.bezierCurveTo(20.315817, 13.0147082, 17.6664052, 12.6334612, 14.8541176, 13.5207082);
      ctx.bezierCurveTo(11.8538562, 14.4672259, 9.67267974, 16.4187553, 8.23006536, 19.1622847);
      ctx.bezierCurveTo(6.68470588, 22.1014847, 6.45960784, 25.2078847, 7.22352941, 28.3996965);
      ctx.bezierCurveTo(7.82248366, 30.8996729, 9.0096732, 33.1206376, 10.5921569, 35.1438612);
      ctx.bezierCurveTo(10.6420915, 35.2083082, 10.692549, 35.2724965, 10.743268, 35.3364259);
      ctx.bezierCurveTo(9.97568627, 34.7698612, 8.83764706, 33.5606376, 8.09385621, 32.5486376);
      ctx.bezierCurveTo(6.57986928, 30.4886612, 5.6420915, 28.2016965, 5.33830065, 25.66652);
      ctx.bezierCurveTo(5.29960784, 25.3442847, 5.26535948, 25.0215318, 5.22875817, 24.6992965);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
    };
    self.draw = function(option, size, r, result) {
      if (options.dirty) {
        this.recache(r);
      }
      {
        var w = options.width * r;
        var d = options.height * r;
        var halfWidth = w / 2;
        var h = d / 2;
        var value = option;
        var height = size;
        (this.angle - 90) * (Math.PI / 180);
      }
      result.globalAlpha = this.hit === false ? 1 : 0.2;
      result.translate(value, height);
      result.drawImage(options.canvas, -halfWidth, -h, w, d);
      result.translate(-value, -height);
    };
    self.collide = function(that) {
      var ctx = that.parent;
      var self = ctx.player;
      var nodesOnScreen = self._powerupsConsumed.misc;
      if (-1 === nodesOnScreen.indexOf(this.id)) {
        {
          var dx = that.pos.x - this.x;
          var dy = that.pos.y - this.y;
          var a = square(dx, 2) + square(dy, 2);
          var lw = ctx.masses;
          lw.length;
        }
        if (1e3 > a && self.isAlive()) {
          nodesOnScreen.push(this.id);
          nodesOnScreen.push(this.otherPortal.id);
          ctx.moveVehicle(this.otherPortal.x - this.x, this.otherPortal.y - this.y);
          if (self.isGhost() === false) {
            this.hit = true;
            this.otherPortal.hit = true;
            this.sector.powerupCanvasDrawn = false;
            this.otherPortal.sector.powerupCanvasDrawn = false;
            this.scene.sound.play("teleport_sound", 0.3);
            this.scene.message.show("Teleport Engaged", 50, "#8ac832");
          }
        }
      }
    };
    module.exports = Entity;
  }, {
    "../powerup" : 19
  }],
  28 : [function(require, context) {
    function init(x, y, i, j) {
      this.p1 = new Particle(x, y);
      this.p2 = new Particle(i, j);
      this.pp = this.p2.sub(this.p1);
      this.len = this.pp.len();
      this.sectors = [];
    }
    var Particle = require("../math/cartesian");
    var m = Math.sqrt;
    var floor = (Math.pow, Math.round, Math.floor);
    init.prototype = {
      sectors : null,
      p1 : null,
      p2 : null,
      pp : null,
      len : 0,
      collided : false,
      remove : false,
      recorded : false,
      getCode : function(e) {
        this.recorded = true;
        var p = this.p2;
        var msg = " " + p.x.toString(32) + " " + p.y.toString(32);
        var x = this.checkForConnectedLine(e, p);
        return x && (msg = msg + x.getCode(e)), msg;
      },
      checkForConnectedLine : function(c, e) {
        var h = c.settings.drawSectorSize;
        var HuffTab = c.sectors.drawSectors;
        var i = floor(e.x / h);
        var j = floor(e.y / h);
        return HuffTab[i][j].searchForLine("sceneryLines", e);
      },
      erase : function(s, start) {
        var instance = false;
        if (!this.remove) {
          var p1 = this.p1;
          var p2 = this.p2;
          var d = s;
          var tca = start;
          var u = p2.sub(p1);
          var v1 = p1.sub(d);
          var a = u.dot(u);
          var roundDistance = 2 * v1.dot(u);
          var sampleWidth = v1.dot(v1) - tca * tca;
          var e = roundDistance * roundDistance - 4 * a * sampleWidth;
          if (e > 0) {
            e = m(e);
            var f = (-roundDistance - e) / (2 * a);
            var v = (-roundDistance + e) / (2 * a);
            if (f >= 0 && 1 >= f) {
              instance = true;
              this.removeAllReferences();
            }
            if (v >= 0 && 1 >= v) {
              instance = true;
              this.removeAllReferences();
            }
          }
          if (this.intersects(this.p1.x, this.p1.y, s.x, s.y, start)) {
            instance = true;
            this.removeAllReferences();
          } else {
            if (this.intersects(this.p2.x, this.p2.y, s.x, s.y, start)) {
              instance = true;
              this.removeAllReferences();
            }
          }
        }
        return instance;
      },
      intersects : function(height, top, width, y, left) {
        var lightI = height - width;
        var lightJ = top - y;
        return left * left >= lightI * lightI + lightJ * lightJ;
      },
      addSectorReference : function(t) {
        this.sectors.push(t);
      },
      removeAllReferences : function() {
        this.remove = true;
        var objects = this.sectors;
        var l = objects.length;
        var i = 0;
        for (; l > i; i++) {
          objects[i].drawn = false;
          objects[i].dirty = true;
        }
        this.sectors = [];
      }
    };
    context.exports = init;
  }, {
    "../math/cartesian" : 14
  }],
  29 : [function(floor, module) {
    function Camera(x, y, options) {
      this.track = options;
      this.scene = options.scene;
      this.settings = options.settings;
      this.drawSectorSize = this.settings.drawSectorSize;
      this.row = y;
      this.column = x;
      this.camera = options.camera;
      this.zoom = options.camera.zoom;
      this.canvasPool = options.canvasPool;
      this.x = x * this.drawSectorSize;
      this.y = y * this.drawSectorSize;
      this.realX = this.x * this.zoom;
      this.realY = this.y * this.zoom;
      this.lineCount = 0;
      this.powerupsCount = 0;
      this.drawn = false;
      this.dirty = false;
      this.physicsLines = [];
      this.sceneryLines = [];
      this.hasPowerups = false;
      this.powerups = {
        all : [],
        goals : [],
        gravitys : [],
        boosts : [],
        slowmos : [],
        checkpoints : [],
        bombs : [],
        antigravitys : [],
        teleports : [],
        helicopters : [],
        trucks : [],
        balloons : [],
        blobs : []
      };
    }
    {
      var BaseConfigurator = (floor("../math/cartesian"), floor("./physicsline"));
      var startYNew = floor("./sceneryline");
      Math.max;
      Math.min;
    }
    Camera.prototype = {
      image : false,
      scene : null,
      settings : null,
      drawSectorSize : null,
      row : 0,
      column : 0,
      camera : null,
      zoom : 0,
      x : 0,
      y : 0,
      realX : 0,
      realY : 0,
      lineCount : 0,
      powerupsCount : 0,
      drawn : false,
      physicsLines : [],
      sceneryLines : [],
      powerups : [],
      canvasPool : null,
      canvas : null,
      powerupCanvas : null,
      powerupCanvasOffset : 30,
      powerupCanvasDrawn : false,
      dirty : false,
      addLine : function(value) {
        if (value instanceof BaseConfigurator) {
          this.physicsLines.push(value);
        }
        if (value instanceof startYNew) {
          this.sceneryLines.push(value);
        }
        this.lineCount++;
        this.drawn = false;
      },
      searchForLine : function(name, head) {
        var result = this[name];
        var longestMatchedRule = false;
        var type;
        for (type in result) {
          var r = result[type];
          if (r.p1.x === head.x && r.p1.y === head.y && r.recorded === false && r.remove === false) {
            longestMatchedRule = r;
          }
        }
        return longestMatchedRule;
      },
      addPowerup : function(type) {
        var $scope = this.powerups;
        var _ref = null;
        switch(type.name) {
          case "goal":
            _ref = $scope.goals;
            break;
          case "gravity":
            _ref = $scope.gravitys;
            break;
          case "slowmo":
            _ref = $scope.slowmos;
            break;
          case "boost":
            _ref = $scope.boosts;
            break;
          case "checkpoint":
            _ref = $scope.checkpoints;
            break;
          case "bomb":
            _ref = $scope.bombs;
            break;
          case "antigravity":
            _ref = $scope.antigravitys;
            break;
          case "teleport":
            _ref = $scope.teleports;
            break;
          case "helicopter":
            _ref = $scope.helicopters;
            break;
          case "truck":
            _ref = $scope.trucks;
            break;
          case "balloon":
            _ref = $scope.balloons;
            break;
          case "blob":
            _ref = $scope.blobs;
        }
        $scope.all.push(type);
        _ref.push(type);
        this.powerupsCount++;
        this.hasPowerups = true;
        this.powerupCanvasDrawn = false;
      },
      erase : function(id, index, prop) {
        var that = [];
        if (prop.physics === true) {
          var values = this.physicsLines;
          var l = values.length;
          var i = l - 1;
          for (; i >= 0; i--) {
            var html = values[i];
            if (html.erase(id, index)) {
              that.push(html);
            }
          }
        }
        if (prop.scenery === true) {
          var activeUniformsList = this.sceneryLines;
          var l = activeUniformsList.length;
          var i = l - 1;
          for (; i >= 0; i--) {
            var u = activeUniformsList[i];
            if (u.erase(id, index)) {
              that.push(u);
            }
          }
        }
        if (prop.powerups === true) {
          var p = this.powerups.all;
          var plen = p.length;
          var i = plen - 1;
          for (; i >= 0; i--) {
            var s = p[i];
            var titleDiv = s.erase(id, index);
            if (titleDiv !== false) {
              that.push.apply(that, titleDiv);
            }
          }
        }
        return that;
      },
      cleanSector : function() {
        this.cleanSectorType("physicsLines");
        this.cleanSectorType("sceneryLines");
        this.cleanSectorType("powerups", "all");
        if (0 === this.powerups.all.length) {
          this.hasPowerups = false;
          if (this.powerupCanvas) {
            this.canvasPool.releaseCanvas(this.powerupCanvas);
            this.powerupCanvas = null;
          }
        } else {
          this.hasPowerups = true;
        }
        this.dirty = false;
      },
      cleanSectorType : function(repeaterId, type) {
        var data = this[repeaterId];
        if (type) {
          data = data[type];
        }
        var dataSize = data.length;
        var i = dataSize - 1;
        for (; i >= 0; i--) {
          var o = data[i];
          if (o.remove) {
            data.splice(i, 1);
          }
        }
      },
      draw : function() {
        var camera = this.scene.camera;
        var width = camera.zoom;
        var newEdges = this.physicsLines;
        var c = this.sceneryLines;
        var height = this.drawSectorSize * width | 0;
        var canvas = this.canvasPool.getCanvas();
        canvas.width = height;
        canvas.height = height;
        var ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        var centerLineWidth = 2 * width > 0.5 ? 2 * width : 0.5;
        var centerLineColor = this.settings.sceneryLineColor;
        var aligningLineColor = this.settings.physicsLineColor;
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = centerLineWidth;
        ctx.lineCap = "round";
        ctx.strokeStyle = centerLineColor;
        this.drawLines(c, width, ctx);
        ctx.stroke();
        ctx.beginPath();
        ctx.lineWidth = centerLineWidth;
        ctx.lineCap = "round";
        ctx.strokeStyle = aligningLineColor;
        this.drawLines(newEdges, width, ctx);
        ctx.stroke();
        if (this.settings.developerMode) {
          ctx.beginPath();
          ctx.strokeStyle = "blue";
          ctx.rect(0, 0, height, height);
          ctx.stroke();
        }
        this.canvas = canvas;
        this.drawn = true;
      },
      drawLine : function(line, text) {
        var value;
        var h;
        var dx;
        var height;
        var pos;
        var lastPoint;
        var canvas = this.canvas;
        var camera = this.scene.camera;
        var ratio = camera.zoom;
        var centerLineWidth = 2 * ratio > 0.5 ? 2 * ratio : 0.5;
        var ctx = false;
        var x = this.x;
        var y = this.y;
        if (!canvas) {
          var widthHeight = this.drawSectorSize * ratio | 0;
          canvas = this.canvasPool.getCanvas();
          canvas.width = widthHeight;
          canvas.height = widthHeight;
          ctx = canvas.getContext("2d");
        }
        if (!ctx) {
          ctx = canvas.getContext("2d");
        }
        pos = line.p1;
        lastPoint = line.p2;
        value = (pos.x - x) * ratio;
        h = (pos.y - y) * ratio;
        dx = (lastPoint.x - x) * ratio;
        height = (lastPoint.y - y) * ratio;
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = centerLineWidth;
        ctx.lineCap = "round";
        ctx.strokeStyle = text;
        ctx.moveTo(value, h);
        ctx.lineTo(dx, height);
        ctx.stroke();
      },
      cachePowerupSector : function() {
        this.powerupCanvasDrawn = true;
        var allItems = this.powerups.all;
        if (allItems.length > 0) {
          var camera = this.scene.camera;
          var zoom = camera.zoom;
          var value = this.drawSectorSize * zoom | 0;
          var top = this.powerupCanvasOffset;
          var element = this.canvasPool.getCanvas();
          element.width = value + top * zoom;
          element.height = value + top * zoom;
          var ctx = element.getContext("2d");
          ctx.clearRect(0, 0, element.width, element.height);
          this.drawPowerups(this.powerups.slowmos, zoom, ctx);
          this.drawPowerups(this.powerups.checkpoints, zoom, ctx);
          this.drawPowerups(this.powerups.boosts, zoom, ctx);
          this.drawPowerups(this.powerups.gravitys, zoom, ctx);
          this.drawPowerups(this.powerups.bombs, zoom, ctx);
          this.drawPowerups(this.powerups.goals, zoom, ctx);
          this.drawPowerups(this.powerups.antigravitys, zoom, ctx);
          this.drawPowerups(this.powerups.teleports, zoom, ctx);
          this.drawPowerups(this.powerups.helicopters, zoom, ctx);
          this.drawPowerups(this.powerups.trucks, zoom, ctx);
          this.drawPowerups(this.powerups.balloons, zoom, ctx);
          this.drawPowerups(this.powerups.blobs, zoom, ctx);
          this.powerupCanvas = element;
          if (this.settings.developerMode) {
            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.rect(0, 0, element.width, element.height);
            ctx.stroke();
          }
        }
      },
      update : function() {
        var zoom = this.camera.zoom;
        this.realX = this.x * zoom | 0;
        this.realY = this.y * zoom | 0;
        this.zoom = zoom;
      },
      resetCollided : function() {
        var tempActivities = this.physicsLines;
        var numActivities = tempActivities.length;
        var i = numActivities - 1;
        for (; i >= 0; i--) {
          if (tempActivities[i]) {
            tempActivities[i].collided = false;
          }
        }
      },
      collide : function(a) {
        var p = a.parent;
        var checks = this.physicsLines;
        var len = checks.length;
        var i = len - 1;
        for (; i >= 0; i--) {
          if (checks[i]) {
            var check = checks[i];
            if (check.remove) {
              checks.splice(i, 1);
            } else {
              check.collide(a);
            }
          }
        }
        if (p.powerupsEnabled) {
          var layers = this.powerups.all;
          var count = layers.length;
          var i = count - 1;
          for (; i >= 0; i--) {
            var layer = layers[i];
            if (layer.remove) {
              layers.splice(i, 1);
            } else {
              layers[i].collide(a);
            }
          }
        }
      },
      drawLines : function(c, width, ctx) {
        var value;
        var step;
        var size;
        var d;
        var e;
        var options;
        var pos;
        var x = this.x;
        var y = this.y;
        var i = c.length;
        var len = i - 1;
        for (; len >= 0; len--) {
          e = c[len];
          if (e.remove) {
            c.splice(len, 1);
          } else {
            options = e.p1;
            pos = e.p2;
            value = (options.x - x) * width;
            step = (options.y - y) * width;
            size = (pos.x - x) * width;
            d = (pos.y - y) * width;
            ctx.moveTo(value, step);
            ctx.lineTo(size, d);
          }
        }
      },
      drawPowerups : function(obj, val, callback) {
        obj = obj;
        var prev = obj.length;
        var x = this.x;
        var y = this.y;
        var bytes = this.powerupCanvasOffset * val / 2;
        var z = prev - 1;
        for (; z >= 0; z--) {
          var self = obj[z];
          if (self.remove) {
            obj.splice(z, 1);
          } else {
            var url = (self.x - x) * val + bytes;
            var offset = (self.y - y) * val + bytes;
            self.draw(url, offset, val, callback);
          }
        }
      },
      drawBackground : function(ctx, color, canvas) {
        var width = this.drawSectorSize * color | 0;
        ctx.beginPath();
        ctx.rect(0, 0, width, width);
        ctx.fillStyle = canvas;
        ctx.fill();
      },
      clear : function() {
        this.drawn = false;
        this.powerupCanvasDrawn = false;
        if (this.canvas) {
          this.canvas = null;
          this.canvasPool.releaseCanvas(this.canvas);
        }
        if (this.powerupCanvas) {
          this.canvasPool.releaseCanvas(this.powerupCanvas);
          this.powerupCanvas = null;
        }
      },
      close : function() {
        this.track = null;
        this.scene = null;
        this.settings = null;
        this.drawSectorSize = null;
        this.row = null;
        this.column = null;
        this.camera = null;
        this.zoom = null;
        this.canvasPool = null;
        this.x = null;
        this.y = null;
        this.realX = null;
        this.realY = null;
        this.lineCount = null;
        this.drawn = null;
        this.physicsLines = null;
        this.sceneryLines = null;
        this.canvas = null;
      }
    };
    module.exports = Camera;
  }, {
    "../math/cartesian" : 14,
    "./physicsline" : 18,
    "./sceneryline" : 28
  }],
  30 : [function(require, context) {
    function init(value, i, b, a) {
      this.x = value;
      this.y = i;
      this.time = b;
      this.id = rand().toString(36).substr(2);
      this.hit = false;
      this.init(a);
    }
    var AutoInject = require("../powerup");
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 22,
      height : 32
    };
    var rand = Math.random;
    var pow = Math.pow;
    var sqrt = Math.sqrt;
    var me = (Math.cos, Math.sin, init.prototype = new AutoInject);
    me.x = 0;
    me.y = 0;
    me.name = "balloon";
    me.getCode = function() {
      return "V " + this.x.toString(32) + " " + this.y.toString(32) + " 3 " + this.time.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var newOperators = canvas.getContext("2d");
      var iconIndex = canvas.width / 2;
      var item = canvas.height / 2;
      this.drawIcon(iconIndex, item, scale, newOperators);
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(x, y, scale, context) {
      if (!this.hit) {
        if (options.dirty) {
          this.recache(scale);
        }
        var w = options.width * scale;
        var height = options.height * scale;
        var radius = w / 2;
        var top = height / 2;
        context.drawImage(options.canvas, x - radius, y - top, w, height);
      }
    };
    me.drawIcon = function(iconIndex, x, size, ctx) {
      ctx.save();
      ctx.scale(size, size);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(21, 0);
      ctx.lineTo(21, 31);
      ctx.lineTo(0, 31);
      ctx.closePath();
      ctx.clip();
      ctx.translate(0, 0);
      ctx.translate(0, 0);
      ctx.scale(1, 1);
      ctx.translate(0, 0);
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = 1;
      ctx.translate(-1322, -440);
      ctx.save();
      ctx.translate(251, 28);
      ctx.save();
      ctx.translate(1056, 265);
      ctx.save();
      ctx.translate(3, 141);
      ctx.save();
      ctx.translate(12, 6);
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(7, 23);
      ctx.lineTo(14, 23);
      ctx.quadraticCurveTo(15, 23, 15, 24);
      ctx.lineTo(15, 30);
      ctx.quadraticCurveTo(15, 31, 14, 31);
      ctx.lineTo(7, 31);
      ctx.quadraticCurveTo(6, 31, 6, 30);
      ctx.lineTo(6, 24);
      ctx.quadraticCurveTo(6, 23, 7, 23);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(15, 19);
      ctx.lineTo(12.9375, 24.6875);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      ctx.translate(7.03125, 21.84375);
      ctx.scale(-1, 1);
      ctx.translate(-7.03125, -21.84375);
      ctx.beginPath();
      ctx.moveTo(8.0625, 19);
      ctx.lineTo(6, 24.6875);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.save();
      ctx.fillStyle = "#f02728";
      ctx.save();
      ctx.beginPath();
      ctx.arc(10.5, 11.125, 10.5, 0, 6.283185307179586, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(10.5, 11.125, 9.5, 0, 6.283185307179586, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
    };
    me.collide = function(that) {
      var e = that.parent;
      var self = e.player;
      var x = that.pos.x - this.x;
      var y = that.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      var nodesOnScreen = self._powerupsConsumed.misc;
      var scene = this.scene;
      if (30 > sqrt8 && self.isAlive() && -1 === nodesOnScreen.indexOf(this.id)) {
        nodesOnScreen.push(this.id);
        var next = this.time * scene.settings.drawFPS;
        self.setTempVehicle("BALLOON", next, {
          x : this.x,
          y : this.y
        }, e.dir);
        if (scene.camera.playerFocus === self) {
          scene.camera.focusOnPlayer();
          scene.vehicleTimer.playerAddedTime(self);
        }
        if (self.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          this.scene.message.show("Balloon Powerup!", 50, "#f02728", false);
        }
      }
    };
    context.exports = init;
  }, {
    "../powerup" : 19
  }],
  31 : [function(require, context) {
    function init(value, i, b, a) {
      this.x = value;
      this.y = i;
      this.time = b;
      this.id = rand().toString(36).substr(2);
      this.hit = false;
      this.init(a);
    }
    var AutoInject = require("../powerup");
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 32,
      height : 42
    };
    var rand = Math.random;
    var pow = Math.pow;
    var sqrt = Math.sqrt;
    var me = (Math.cos, Math.sin, init.prototype = new AutoInject);
    me.x = 0;
    me.y = 0;
    me.name = "blob";
    me.getCode = function() {
      return "V " + this.x.toString(32) + " " + this.y.toString(32) + " 4 " + this.time.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var newOperators = canvas.getContext("2d");
      var iconIndex = canvas.width / 2;
      var item = canvas.height / 2;
      this.drawIcon(iconIndex, item, scale, newOperators);
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(x, y, scale, context) {
      if (!this.hit) {
        if (options.dirty) {
          this.recache(scale);
        }
        var w = options.width * scale;
        var height = options.height * scale;
        var radius = w / 2;
        var top = height / 2;
        context.drawImage(options.canvas, x - radius, y - top, w, height);
      }
    };
    me.drawIcon = function(iconIndex, x, size, ctx) {
      size = size * 1;
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4 * size;
      ctx.save();
      ctx.scale(size, size);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(24, 0);
      ctx.lineTo(24, 22);
      ctx.lineTo(0, 22);
      ctx.closePath();
      ctx.clip();
      ctx.translate(0, 0);
      ctx.translate(0, 0);
      ctx.scale(1, 1);
      ctx.translate(0, 0);
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = 1;
      ctx.translate(-1320, -491);
      ctx.save();
      ctx.translate(251, 28);
      ctx.save();
      ctx.translate(1056, 265);
      ctx.save();
      ctx.translate(3, 187);
      ctx.save();
      ctx.translate(10, 11);
      ctx.save();
      ctx.save();
      ctx.fillStyle = "#a784c5";
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(4, 0);
      ctx.lineTo(20, 0);
      ctx.quadraticCurveTo(24, 0, 24, 4);
      ctx.lineTo(24, 18);
      ctx.quadraticCurveTo(24, 22, 20, 22);
      ctx.lineTo(4, 22);
      ctx.quadraticCurveTo(0, 22, 0, 18);
      ctx.lineTo(0, 4);
      ctx.quadraticCurveTo(0, 0, 4, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(5, 1);
      ctx.lineTo(19, 1);
      ctx.quadraticCurveTo(23, 1, 23, 5);
      ctx.lineTo(23, 17);
      ctx.quadraticCurveTo(23, 21, 19, 21);
      ctx.lineTo(5, 21);
      ctx.quadraticCurveTo(1, 21, 1, 17);
      ctx.lineTo(1, 5);
      ctx.quadraticCurveTo(1, 1, 5, 1);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
    };
    me.collide = function(that) {
      var e = that.parent;
      var self = e.player;
      var x = that.pos.x - this.x;
      var y = that.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      var nodesOnScreen = self._powerupsConsumed.misc;
      var scene = this.scene;
      if (30 > sqrt8 && self.isAlive() && -1 === nodesOnScreen.indexOf(this.id)) {
        nodesOnScreen.push(this.id);
        var next = this.time * scene.settings.drawFPS;
        self.setTempVehicle("BLOB", next, {
          x : this.x,
          y : this.y
        }, e.dir);
        if (scene.camera.playerFocus === self) {
          scene.camera.focusOnPlayer();
          scene.vehicleTimer.playerAddedTime(self);
        }
        if (self.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          this.scene.message.show("Blob Powerup!", 50, "#A784C5", false);
        }
      }
    };
    context.exports = init;
  }, {
    "../powerup" : 19
  }],
  32 : [function(require, context) {
    function init(value, i, b, a) {
      this.x = value;
      this.y = i;
      this.time = b;
      this.id = rand().toString(36).substr(2);
      this.hit = false;
      this.init(a);
    }
    var AutoInject = require("../powerup");
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 32,
      height : 42
    };
    var rand = Math.random;
    var pow = Math.pow;
    var sqrt = Math.sqrt;
    var me = (Math.cos, Math.sin, init.prototype = new AutoInject);
    me.x = 0;
    me.y = 0;
    me.name = "helicopter";
    me.getCode = function() {
      return "V " + this.x.toString(32) + " " + this.y.toString(32) + " 1 " + this.time.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var newOperators = canvas.getContext("2d");
      var iconIndex = canvas.width / 2;
      var item = canvas.height / 2;
      this.drawIcon(iconIndex, item, scale, newOperators);
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(x, y, scale, context) {
      if (!this.hit) {
        if (options.dirty) {
          this.recache(scale);
        }
        var w = options.width * scale;
        var height = options.height * scale;
        var radius = w / 2;
        var top = height / 2;
        context.drawImage(options.canvas, x - radius, y - top, w, height);
      }
    };
    me.drawIcon = function(iconIndex, x, scale, ctx) {
      scale = scale * 1;
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4 * scale;
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(15 * scale, 4.5 * scale);
      ctx.lineTo(15 * scale, 2.5 * scale);
      ctx.bezierCurveTo(15 * scale, 1.4 * scale, 14.1 * scale, 0.5 * scale, 13 * scale, 0.5 * scale);
      ctx.bezierCurveTo(11.9 * scale, 0.5 * scale, 11 * scale, 1.4 * scale, 11 * scale, 2.5 * scale);
      ctx.lineTo(11 * scale, 4.5 * scale);
      ctx.bezierCurveTo(11 * scale, 5.6 * scale, 11.9 * scale, 6.5 * scale, 13 * scale, 6.5 * scale);
      ctx.bezierCurveTo(14.1 * scale, 6.5 * scale, 15 * scale, 5.6 * scale, 15 * scale, 4.5 * scale);
      ctx.lineTo(15 * scale, 4.5 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.lineCap = "round";
      ctx.lineWidth = 2 * scale;
      ctx.moveTo(1 * scale, 3 * scale);
      ctx.lineTo(25 * scale, 3 * scale);
      ctx.stroke();
      ctx.lineCap = "butt";
      ctx.lineWidth = 1 * scale;
      ctx.beginPath();
      ctx.moveTo(6.1 * scale, 26.9 * scale);
      ctx.lineTo(4.1 * scale, 31.9 * scale);
      ctx.bezierCurveTo(3.8 * scale, 32.7 * scale, 4.2 * scale, 33.6 * scale, 4.9 * scale, 33.9 * scale);
      ctx.bezierCurveTo(5.7 * scale, 34.2 * scale, 6.6 * scale, 33.8 * scale, 6.9 * scale, 33 * scale);
      ctx.lineTo(8.9 * scale, 28 * scale);
      ctx.bezierCurveTo(9.2 * scale, 27.3 * scale, 8.8 * scale, 26.4 * scale, 8 * scale, 26.1 * scale);
      ctx.bezierCurveTo(7.3 * scale, 25.8 * scale, 6.4 * scale, 26.1 * scale, 6.1 * scale, 26.9 * scale);
      ctx.lineTo(6.1 * scale, 26.9 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(17 * scale, 28 * scale);
      ctx.lineTo(19 * scale, 33 * scale);
      ctx.bezierCurveTo(19.4 * scale, 33.8 * scale, 20.3 * scale, 34.2 * scale, 21 * scale, 33.9 * scale);
      ctx.bezierCurveTo(21.8 * scale, 33.6 * scale, 22.2 * scale, 32.7 * scale, 21.9 * scale, 31.9 * scale);
      ctx.lineTo(19.9 * scale, 26.9 * scale);
      ctx.bezierCurveTo(19.6 * scale, 26.2 * scale, 18.7 * scale, 25.8 * scale, 17.9 * scale, 26.1 * scale);
      ctx.bezierCurveTo(17.2 * scale, 26.4 * scale, 16.8 * scale, 27.3 * scale, 17.1 * scale, 28 * scale);
      ctx.lineTo(17 * scale, 28 * scale);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "#f59423";
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2 * scale;
      ctx.beginPath();
      ctx.arc(13 * scale, 17 * scale, 11 * scale, 0 * scale, 2 * Math.PI, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(21 * scale, 17 * scale);
      ctx.bezierCurveTo(21 * scale, 12.6 * scale, 17.4 * scale, 9 * scale, 13 * scale, 9 * scale);
      ctx.bezierCurveTo(8.6 * scale, 9 * scale, 5 * scale, 12.6 * scale, 5 * scale, 17 * scale);
      ctx.lineTo(21 * scale, 17 * scale);
      ctx.closePath();
      ctx.fill();
    };
    me.collide = function(that) {
      var e = that.parent;
      var self = e.player;
      var x = that.pos.x - this.x;
      var y = that.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      var nodesOnScreen = self._powerupsConsumed.misc;
      var scene = this.scene;
      if (30 > sqrt8 && self.isAlive() && -1 === nodesOnScreen.indexOf(this.id)) {
        nodesOnScreen.push(this.id);
        var next = this.time * scene.settings.drawFPS;
        self.setTempVehicle("HELI", next, {
          x : this.x,
          y : this.y
        }, e.dir);
        if (scene.camera.playerFocus === self) {
          scene.camera.focusOnPlayer();
          scene.vehicleTimer.playerAddedTime(self);
        }
        if (self.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          this.scene.message.show("Helicopter Powerup!", 50, "#F2902E", false);
        }
      }
    };
    context.exports = init;
  }, {
    "../powerup" : 19
  }],
  33 : [function(require, context) {
    function init(value, i, b, a) {
      this.x = value;
      this.y = i;
      this.time = b;
      this.id = rand().toString(36).substr(2);
      this.hit = false;
      this.init(a);
    }
    var AutoInject = require("../powerup");
    var options = {
      canvas : document.createElement("canvas"),
      dirty : true,
      width : 32,
      height : 42
    };
    var rand = Math.random;
    var pow = Math.pow;
    var sqrt = Math.sqrt;
    var me = (Math.cos, Math.sin, init.prototype = new AutoInject);
    me.x = 0;
    me.y = 0;
    me.name = "truck";
    me.getCode = function() {
      return "V " + this.x.toString(32) + " " + this.y.toString(32) + " 2 " + this.time.toString(32);
    };
    me.recache = function(scale) {
      options.dirty = false;
      var canvas = options.canvas;
      canvas.width = options.width * scale;
      canvas.height = options.height * scale;
      var newOperators = canvas.getContext("2d");
      var iconIndex = canvas.width / 2;
      var item = canvas.height / 2;
      this.drawIcon(iconIndex, item, scale, newOperators);
    };
    me.setDirty = function(value) {
      options.dirty = value;
    };
    me.draw = function(x, y, scale, context) {
      if (!this.hit) {
        if (options.dirty) {
          this.recache(scale);
        }
        var w = options.width * scale;
        var height = options.height * scale;
        var radius = w / 2;
        var top = height / 2;
        context.drawImage(options.canvas, x - radius, y - top, w, height);
      }
    };
    me.drawIcon = function(iconIndex, x, size, ctx) {
      size = size * 1;
      ctx.save();
      ctx.scale(size, size);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(24, 0);
      ctx.lineTo(24, 26);
      ctx.lineTo(0, 26);
      ctx.closePath();
      ctx.clip();
      ctx.translate(0, 0);
      ctx.translate(0, 0);
      ctx.scale(1, 1);
      ctx.translate(0, 0);
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0)";
      ctx.lineWidth = 1;
      ctx.translate(-1320, -352);
      ctx.save();
      ctx.translate(251, 28);
      ctx.save();
      ctx.translate(1056, 265);
      ctx.save();
      ctx.translate(3, 49);
      ctx.save();
      ctx.translate(10, 8);
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(2, 17);
      ctx.lineTo(4, 17);
      ctx.quadraticCurveTo(6, 17, 6, 19);
      ctx.lineTo(6, 26);
      ctx.quadraticCurveTo(6, 28, 4, 28);
      ctx.lineTo(2, 28);
      ctx.quadraticCurveTo(0, 28, 0, 26);
      ctx.lineTo(0, 19);
      ctx.quadraticCurveTo(0, 17, 2, 17);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(20, 17);
      ctx.lineTo(22, 17);
      ctx.quadraticCurveTo(24, 17, 24, 19);
      ctx.lineTo(24, 26);
      ctx.quadraticCurveTo(24, 28, 22, 28);
      ctx.lineTo(20, 28);
      ctx.quadraticCurveTo(18, 28, 18, 26);
      ctx.lineTo(18, 19);
      ctx.quadraticCurveTo(18, 17, 20, 17);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.lineCap = "square";
      ctx.beginPath();
      ctx.moveTo(3.5, 23);
      ctx.lineTo(20.5, 23);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.save();
      ctx.fillStyle = "#94d44e";
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(23, 11.2672237);
      ctx.bezierCurveTo(23.5979157, 11.6115707, 24, 12.2552568, 24, 12.999615);
      ctx.lineTo(24, 19.000385);
      ctx.bezierCurveTo(24, 20.1047419, 23.1029738, 21, 21.9950534, 21);
      ctx.lineTo(2.00494659, 21);
      ctx.bezierCurveTo(0.897645164, 21, 0, 20.1125667, 0, 19.000385);
      ctx.lineTo(0, 12.999615);
      ctx.bezierCurveTo(0, 12.2603805, 0.401930294, 11.6148368, 1, 11.268783);
      ctx.lineTo(1, 3.99742191);
      ctx.bezierCurveTo(1, 2.89427625, 1.88967395, 2, 2.991155, 2);
      ctx.lineTo(21.008845, 2);
      ctx.bezierCurveTo(22.1085295, 2, 23, 2.89092539, 23, 3.99742191);
      ctx.lineTo(23, 11.2672237);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(22.5009348, 12.1337882);
      ctx.lineTo(22, 11.8452936);
      ctx.lineTo(22, 3.99742191);
      ctx.bezierCurveTo(22, 3.44392402, 21.5569554, 3, 21.008845, 3);
      ctx.lineTo(2.991155, 3);
      ctx.bezierCurveTo(2.44342393, 3, 2, 3.44509694, 2, 3.99742191);
      ctx.lineTo(2, 11.8455);
      ctx.lineTo(1.50082265, 12.1343329);
      ctx.bezierCurveTo(1.19247839, 12.3127464, 1, 12.6390115, 1, 12.999615);
      ctx.lineTo(1, 19.000385);
      ctx.bezierCurveTo(1, 19.5563739, 1.44601448, 20, 2.00494659, 20);
      ctx.lineTo(21.9950534, 20);
      ctx.bezierCurveTo(22.5510229, 20, 23, 19.5521213, 23, 19.000385);
      ctx.lineTo(23, 12.999615);
      ctx.bezierCurveTo(23, 12.6352349, 22.8086914, 12.311029, 22.5009348, 12.1337882);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(5, 6);
      ctx.lineTo(19, 6);
      ctx.quadraticCurveTo(19, 6, 19, 6);
      ctx.lineTo(19, 12);
      ctx.quadraticCurveTo(19, 12, 19, 12);
      ctx.lineTo(5, 12);
      ctx.quadraticCurveTo(5, 12, 5, 12);
      ctx.lineTo(5, 6);
      ctx.quadraticCurveTo(5, 6, 5, 6);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(5.03571429, 16.0357143, 1.39285714, 0, 6.283185307179586, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(18.9642857, 16.0357143, 1.39285714, 0, 6.283185307179586, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
      ctx.restore();
    };
    me.collide = function(that) {
      var e = that.parent;
      var self = e.player;
      var x = that.pos.x - this.x;
      var y = that.pos.y - this.y;
      var sqrt8 = sqrt(pow(x, 2) + pow(y, 2));
      var nodesOnScreen = self._powerupsConsumed.misc;
      var scene = this.scene;
      if (30 > sqrt8 && self.isAlive() && -1 === nodesOnScreen.indexOf(this.id)) {
        nodesOnScreen.push(this.id);
        var next = this.time * scene.settings.drawFPS;
        self.setTempVehicle("TRUCK", next, {
          x : this.x,
          y : this.y
        }, e.dir);
        if (scene.camera.playerFocus === self) {
          scene.camera.focusOnPlayer();
          scene.vehicleTimer.playerAddedTime(self);
        }
        if (self.isGhost() === false) {
          this.hit = true;
          this.sector.powerupCanvasDrawn = false;
          this.scene.message.show("Truck Powerup!", 50, "#94d44e", false);
        }
      }
    };
    context.exports = init;
  }, {
    "../powerup" : 19
  }],
  34 : [function(__webpack_require__, mixin) {
    var Point = __webpack_require__("../math/cartesian");
    var Mock = __webpack_require__("./tool");
    var m = (__webpack_require__("../../libs/lodash-3.10.1"), Math.sqrt, Math.pow, Math.round, function(that) {
      this.toolInit(that);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
      var ctx = that.scene.settings.brush;
      this.addedObjects = [];
      this.options = {
        breakLength : ctx.breakLength,
        maxBreakLength : ctx.maxBreakLength,
        minBreakLength : ctx.minBreakLength,
        breakLengthSensitivity : ctx.breakLengthSensitivity,
        trailSpeed : ctx.trailSpeed,
        maxTrailSpeed : ctx.maxTrailSpeed,
        minTrailSpeed : ctx.minTrailSpeed,
        trailSpeedSensitivity : ctx.trailSpeedSensitivity
      };
    });
    var self = m.prototype = new Mock;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.name = "Brush";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.options = null;
    self.reset = function() {
      this.recordActionsToToolhandler();
      this.active = false;
    };
    self.recordActionsToToolhandler = function() {
      var trapId;
      var attempts = this.addedObjects;
      var attemptsLength = attempts.length;
      if (attemptsLength) {
        trapId = 0;
        for (; attemptsLength > trapId; trapId++) {
          this.toolhandler.addActionToTimeline({
            type : "add",
            objects : [attempts[trapId]]
          });
        }
      }
      this.addedObjects = [];
    };
    self.press = function() {
      if (this.recordActionsToToolhandler(), !this.active) {
        var b = this.mouse.touch.real;
        this.p1.x = b.x;
        this.p1.y = b.y;
        this.p2.x = b.x;
        this.p2.y = b.y;
        this.active = true;
      }
    };
    self.hold = function() {
      var r = this.mouse.touch.real;
      var p1 = this.p1;
      var p2 = this.p2;
      var value = this.options.trailSpeed;
      var scale = this.options.breakLength;
      p2.inc(r.sub(p2).factor(value));
      var stem_height = screen.height + r.sub(p2).len();
      if (stem_height = stem_height * scale, p2.sub(p1).lenSqr() > stem_height) {
        var geometrize_rasterizer_Rasterizer = this.scene.track;
        var a = false;
        a = "physics" === this.toolhandler.options.lineType ? geometrize_rasterizer_Rasterizer.addPhysicsLine(p1.x, p1.y, p2.x, p2.y) : geometrize_rasterizer_Rasterizer.addSceneryLine(p1.x, p1.y, p2.x, p2.y);
        if (a) {
          this.addedObjects.push(a);
        }
        p1.equ(p2);
        this.toolhandler.snapPoint.x = p2.x;
        this.toolhandler.snapPoint.y = p2.y;
      }
      this.toolhandler.moveCameraTowardsMouse();
    };
    self.release = function() {
      var p1 = this.p1;
      var p2 = this.p2;
      var geometrize_rasterizer_Rasterizer = this.scene.track;
      var s = false;
      s = "physics" === this.toolhandler.options.lineType ? geometrize_rasterizer_Rasterizer.addPhysicsLine(p1.x, p1.y, p2.x, p2.y) : geometrize_rasterizer_Rasterizer.addSceneryLine(p1.x, p1.y, p2.x, p2.y);
      if (s) {
        this.addedObjects.push(s);
      }
      this.recordActionsToToolhandler();
      var that = this.toolhandler;
      var p = that.snapPoint;
      p.x = p2.x;
      p.y = p2.y;
      this.active = false;
    };
    self.update = function() {
      var eKeys = this.toolhandler.gamepad;
      var root = this.mouse;
      if (eKeys.isButtonDown("alt")) {
        if (root.mousewheel !== false) {
          this.adjustTrailSpeed(root.mousewheel);
        }
      } else {
        if (eKeys.isButtonDown("shift") && root.mousewheel !== false) {
          this.adjustBreakLength(root.mousewheel);
        }
      }
      var that = this.toolhandler;
      if (that.options.snap) {
        this.active = true;
        this.p1.x = that.snapPoint.x;
        this.p1.y = that.snapPoint.y;
        this.p2.x = root.touch.real.x;
        this.p2.y = root.touch.real.y;
      }
      this.toolUpdate();
    };
    self.adjustTrailSpeed = function(canCreateDiscussions) {
      var size = this.options.trailSpeed;
      var position = this.options.trailSpeedSensitivity;
      var max = this.options.maxTrailSpeed;
      var len = this.options.minTrailSpeed;
      if (canCreateDiscussions > 0) {
        size = size + position;
        if (size > max) {
          size = max;
        }
      } else {
        size = size - position;
        if (len > size) {
          size = len;
        }
      }
      this.setOption("trailSpeed", size);
    };
    self.adjustBreakLength = function(canCreateDiscussions) {
      var width = this.options.breakLength;
      var margin = this.options.breakLengthSensitivity;
      var canvasWidth = this.options.maxBreakLength;
      var height = this.options.minBreakLength;
      if (canCreateDiscussions > 0) {
        width = width + margin;
        if (width > canvasWidth) {
          width = canvasWidth;
        }
      } else {
        width = width - margin;
        if (height > width) {
          width = height;
        }
      }
      this.setOption("breakLength", width);
    };
    self.setOption = function(key, value) {
      this.options[key] = value;
    };
    self.getOptions = function() {
      var options = this.toolhandler;
      var o = this.options;
      return o.lineType = options.options.lineType, o.snap = options.options.snap, o;
    };
    self.draw = function() {
      var scene = this.scene;
      var node = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      var camera = scene.camera;
      var zoom = camera.zoom;
      this.drawCursor(node);
      if (this.active) {
        this.drawLine(node, zoom);
        this.drawPoint(node, this.p1, zoom);
        this.drawPoint(node, this.p2, zoom);
      }
    };
    self.drawText = function(ctx) {
      var name = this.name;
      var max = this.options.breakLength;
      var id = this.options.trailSpeed;
      var dpr = this.game.pixelRatio;
      ctx.fillStyle = "#000000";
      ctx.font = 12 * dpr + "pt arial";
      ctx.fillText(name, 10 * dpr, 20 * dpr);
      ctx.font = 8 * dpr + "pt arial";
      id = 0 | id;
      max = max;
      ctx.fillText("Trail speed : " + id, 10 * dpr, 40 * dpr);
      ctx.fillText("Break length : " + max, 10 * dpr, 60 * dpr);
    };
    self.drawCursor = function(ctx) {
      var self = this.mouse.touch;
      var obj = self.real.toScreen(this.scene);
      var zoom = this.camera.zoom;
      var data = this.toolhandler;
      var r = (data.options.lineType, data.options.grid);
      var parBgColor = "#1884cf";
      if (r) {
        var r = 5 * zoom;
        ctx.beginPath();
        ctx.moveTo(obj.x, obj.y - r);
        ctx.lineTo(obj.x, obj.y + r);
        ctx.moveTo(obj.x - r, obj.y);
        ctx.lineTo(obj.x + r, obj.y);
        ctx.lineWidth = 1 * zoom;
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, 1 * zoom, 0, 2 * Math.PI, false);
        ctx.lineWidth = 1;
        ctx.fillStyle = parBgColor;
        ctx.fill();
      }
    };
    self.drawPoint = function(ctx, text, size) {
      var obj = text.toScreen(this.scene);
      ctx.beginPath();
      ctx.arc(obj.x, obj.y, 1 * size, 0, 2 * Math.PI, false);
      ctx.lineWidth = 1;
      ctx.fillStyle = "#1884cf";
      ctx.fill();
    };
    self.drawLine = function(context, props) {
      var scene = this.scene;
      var buttonStrokeSize = (scene.game.canvas, 2 * props > 0.5 ? 2 * props : 0.5);
      var options = this.toolhandler;
      var lineType = options.options.lineType;
      var color = "physics" === lineType ? "#000" : "#AAA";
      context.beginPath();
      context.lineWidth = buttonStrokeSize;
      context.lineCap = "round";
      context.strokeStyle = color;
      var obj = this.p1.toScreen(this.scene);
      var thumbPoint = this.p2.toScreen(this.scene);
      context.moveTo(obj.x, obj.y);
      context.lineTo(thumbPoint.x, thumbPoint.y);
      context.stroke();
    };
    mixin.exports = m;
  }, {
    "../../libs/lodash-3.10.1" : 90,
    "../math/cartesian" : 14,
    "./tool" : 49
  }],
  35 : [function(saveNotifs, module) {
    var Scrollpicker = (saveNotifs("../math/cartesian"), saveNotifs("./tool"));
    var s = function(a) {
      this.toolInit(a);
    };
    var self = s.prototype = new Scrollpicker;
    self.toolInit = self.init;
    self.toolDraw = self.draw;
    self.name = "Camera";
    self.hold = function() {
      var e = this.mouse.touch;
      var start = e.pos;
      var camera = this.camera;
      var i = e.old.pos.sub(start).factor(1 / camera.zoom);
      camera.position.inc(i);
    };
    self.draw = function() {
      {
        var scene = this.scene;
        scene.game.canvas;
        scene.game.canvas.getContext("2d");
      }
    };
    self.drawText = function(ctx) {
      {
        var name = this.name;
        var dpr = this.game.pixelRatio;
        var scene = this.scene;
        scene.game.canvas;
      }
      ctx.fillStyle = "#000000";
      ctx.font = 12 * dpr + "pt arial";
      ctx.fillText(name, 10 * dpr, 20 * dpr);
      ctx.font = 8 * dpr + "pt arial";
    };
    module.exports = s;
  }, {
    "../math/cartesian" : 14,
    "./tool" : 49
  }],
  36 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../math/cartesian");
    var plus = __webpack_require__("../math/curvedivision");
    var Shape = __webpack_require__("./tool");
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var Line = function(value) {
      this.toolInit(value);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.midpoint = new Point(0, 0);
      this.active = false;
      this.options = {};
    };
    var self = Line.prototype = new Shape;
    self.toolInit = self.init;
    self.name = "Curve";
    self.active = false;
    self.p1 = null;
    self.p2 = null;
    self.midpoint = null;
    self.anchoring = false;
    self.options = null;
    self.getOptions = function() {
      var options = this.toolhandler;
      var o = this.options;
      return o.lineType = options.options.lineType, o.snap = options.options.snap, o;
    };
    self.reset = function() {
      this.active = false;
      this.anchoring = false;
    };
    self.press = function() {
      if (!this.active) {
        this.active = true;
        var b = this.mouse.touch.real;
        this.p1.x = b.x;
        this.p1.y = b.y;
      }
    };
    self.hold = function() {
      var b = this.mouse.touch.real;
      this.p2.x = b.x;
      this.p2.y = b.y;
      var p1 = this.p1;
      var p2 = this.p2;
      this.midpoint.x = (p1.x + p2.x) / 2;
      this.midpoint.y = (p1.y + p2.y) / 2;
      this.toolhandler.moveCameraTowardsMouse();
    };
    self.release = function() {
      var p1 = this.p1;
      var p2 = this.p2;
      var p = this.midpoint;
      var that = this.toolhandler;
      if (this.anchoring) {
        if (p.x === p2.x && p.y === p2.y) {
          var geometrize_rasterizer_Rasterizer = this.scene.track;
          var inFolder = false;
          inFolder = "physics" === that.options.lineType ? geometrize_rasterizer_Rasterizer.addPhysicsLine(p1.x, p1.y, p2.x, p2.y) : geometrize_rasterizer_Rasterizer.addSceneryLine(p1.x, p1.y, p2.x, p2.y);
          if (inFolder) {
            that.addActionToTimeline({
              type : "add",
              objects : [inFolder]
            });
          }
          that.snapPoint.x = p2.x;
          that.snapPoint.y = p2.y;
        } else {
          this.splitAndAddCurve();
        }
        this.anchoring = false;
        this.active = false;
      } else {
        var base = p2.x - p1.x;
        var height = p2.y - p1.y;
        var sqrt8 = sqrt(pow(base, 2) + pow(height, 2));
        if (sqrt8 > 0) {
          this.anchoring = true;
        } else {
          this.active = false;
        }
      }
    };
    self.updateAnchor = function() {
      var b = this.mouse.touch.real;
      this.midpoint.x = b.x;
      this.midpoint.y = b.y;
    };
    self.splitAndAddCurve = function() {
      var result = (performance.now(), plus(this.p1, this.midpoint, this.p2));
      var console = this.scene.track;
      var l = result.length;
      var that = this.toolhandler;
      var serverIds = [];
      var i = 0;
      for (; l - 2 > i; i = i + 2) {
        var data = result[i];
        var taskTime = result[i + 1];
        var unit = result[i + 2];
        var c = result[i + 3];
        var key = false;
        key = "physics" === that.options.lineType ? console.addPhysicsLine(data, taskTime, unit, c) : console.addSceneryLine(data, taskTime, unit, c);
        if (key) {
          serverIds.push(key);
        }
        that.snapPoint.x = unit;
        that.snapPoint.y = c;
      }
      if (serverIds.length > 0) {
        that.addActionToTimeline({
          type : "add",
          objects : serverIds
        });
      }
    };
    self.update = function() {
      var node = this.mouse;
      var t = node.touch;
      var cur = node.secondaryTouch;
      var aggregator = this.toolhandler.gamepad;
      var that = this.toolhandler;
      if (that.options.snap) {
        this.active = true;
        this.p1 = that.snapPoint;
        if (!this.anchoring) {
          this.hold();
        }
      }
      var button = this.toolhandler.options;
      var i = aggregator.isButtonDown("shift");
      if (button.rightClickMove) {
        i = cur.old.down;
      }
      if (i) {
        if (t.old.down || button.rightClickMove) {
          this.moveCamera();
        }
      } else {
        if (t.press && !this.anchoring) {
          this.press();
        }
        if (t.old.down && !this.anchoring) {
          this.hold();
        }
        if (t.release) {
          this.release();
        }
        if (this.anchoring) {
          this.updateAnchor();
        }
      }
      if (node.mousewheel !== false && aggregator.isButtonDown("shift") === false) {
        this.mousewheel(node.mousewheel);
      }
    };
    self.draw = function() {
      var scene = this.scene;
      var node = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      var camera = scene.camera;
      var zoom = camera.zoom;
      this.drawCursor(node, zoom);
      if (this.active) {
        this.drawLine(node, zoom);
        this.drawPoint(node, this.p1, zoom);
        this.drawPoint(node, this.p2, zoom);
      }
    };
    self.toScreen = function(width, i) {
      var camera = this.scene.camera;
      var screen = this.scene.screen;
      return (width - camera.position[i]) * camera.zoom + screen.center[i];
    };
    self.drawCursor = function(ctx, scale) {
      var self = this.mouse.touch;
      var obj = self.real.toScreen(this.scene);
      var data = this.toolhandler;
      var r = (data.options.lineType, data.options.grid);
      var parBgColor = "#1884cf";
      if (r) {
        var r = 5 * scale;
        ctx.beginPath();
        ctx.moveTo(obj.x, obj.y - r);
        ctx.lineTo(obj.x, obj.y + r);
        ctx.moveTo(obj.x - r, obj.y);
        ctx.lineTo(obj.x + r, obj.y);
        ctx.lineWidth = 1 * scale;
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, 1 * scale, 0, 2 * Math.PI, false);
        ctx.lineWidth = 1;
        ctx.fillStyle = parBgColor;
        ctx.fill();
      }
    };
    self.drawPoint = function(ctx, text, size) {
      var obj = text.toScreen(this.scene);
      ctx.beginPath();
      ctx.arc(obj.x, obj.y, 1 * size, 0, 2 * Math.PI, false);
      ctx.lineWidth = 1;
      ctx.fillStyle = "#1884cf";
      ctx.fill();
    };
    self.drawText = function(ctx) {
      {
        var name = this.name;
        var dpr = this.game.pixelRatio;
        var scene = this.scene;
        scene.game.canvas;
      }
      ctx.fillStyle = "#000000";
      ctx.font = 12 * dpr + "pt arial";
      ctx.fillText(name, 10 * dpr, 20 * dpr);
      ctx.font = 8 * dpr + "pt arial";
    };
    self.drawLine = function(ctx, type) {
      var scene = this.scene;
      var centerLineWidth = (scene.game.canvas, 2 * type > 0.5 ? 2 * type : 0.5);
      var options = this.toolhandler;
      var lineType = options.options.lineType;
      var color = "physics" === lineType ? "#000" : "#AAA";
      ctx.beginPath();
      ctx.lineWidth = centerLineWidth;
      ctx.lineCap = "round";
      ctx.strokeStyle = color;
      var obj = this.p1.toScreen(this.scene);
      var myEnd = this.p2.toScreen(this.scene);
      var cntrl = this.midpoint.toScreen(this.scene);
      ctx.moveTo(obj.x, obj.y);
      ctx.quadraticCurveTo(cntrl.x, cntrl.y, myEnd.x, myEnd.y);
      ctx.stroke();
    };
    module.exports = Line;
  }, {
    "../math/cartesian" : 14,
    "../math/curvedivision" : 15,
    "./tool" : 49
  }],
  37 : [function(unescape, module) {
    var s_utf8 = unescape("../math/cartesian");
    var Ease = unescape("./tool");
    var query = unescape("../../libs/lodash-3.10.1");
    var round = Math.round;
    var c = function(data) {
      this.toolInit(data);
      var options = data.scene.settings.eraser;
      this.options = options;
      this.eraserPoint = new s_utf8;
      this.erasedObjects = [];
    };
    var self = c.prototype = new Ease;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.name = "Eraser";
    self.options = null;
    self.reset = function() {
      this.recordActionsToToolhandler();
    };
    self.press = function() {
      this.recordActionsToToolhandler();
    };
    self.recordActionsToToolhandler = function() {
      if (this.erasedObjects.length > 0) {
        this.toolhandler.addActionToTimeline({
          type : "remove",
          objects : query.flatten(this.erasedObjects)
        });
      }
      this.erasedObjects = [];
    };
    self.release = function() {
      this.recordActionsToToolhandler();
    };
    self.hold = function() {
      var target = this.mouse.touch;
      var p1 = target.pos;
      var obj = this.scene.track;
      var arc = this.scene.screen;
      var camera = this.scene.camera;
      var circle = arc.center;
      var pos = camera.position;
      var r = (p1.x - circle.x) / camera.zoom + pos.x;
      var y = (p1.y - circle.y) / camera.zoom + pos.y;
      this.eraserPoint.x = round(r);
      this.eraserPoint.y = round(y);
      var c = obj.erase(this.eraserPoint, this.options.radius / this.scene.camera.zoom, this.options.types);
      if (c.length > 0) {
        this.erasedObjects.push(c);
      }
    };
    self.draw = function() {
      var scene = this.scene;
      var newOperators = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      this.drawEraser(newOperators);
    };
    self.drawEraser = function(ctx) {
      {
        var node = this.mouse.touch;
        var c = node.pos;
        this.camera.zoom;
      }
      ctx.beginPath();
      ctx.arc(c.x, c.y, this.options.radius, 0, 2 * Math.PI, false);
      ctx.lineWidth = 1;
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();
      ctx.strokeStyle = "#000000";
      ctx.stroke();
    };
    self.setOption = function(key, value) {
      this.options[key] = value;
    };
    self.getOptions = function() {
      return this.options;
    };
    self.update = function() {
      var aggregator = this.toolhandler.gamepad;
      var mouse = this.mouse;
      if (aggregator.isButtonDown("shift") && mouse.mousewheel !== false) {
        this.adjustRadius(mouse.mousewheel);
      }
      this.toolUpdate();
    };
    self.adjustRadius = function(p) {
      var returnValue = this.options.radius;
      var x = this.options.radiusSizeSensitivity;
      var instance = this.options.maxRadius;
      var subDirectoryReturnValue = this.options.minRadius;
      var superior = p > 0 ? x : -x;
      returnValue = returnValue + superior;
      if (subDirectoryReturnValue > returnValue) {
        returnValue = subDirectoryReturnValue;
      } else {
        if (returnValue > instance) {
          returnValue = instance;
        }
      }
      this.setOption("radius", returnValue);
    };
    module.exports = c;
  }, {
    "../../libs/lodash-3.10.1" : 90,
    "../math/cartesian" : 14,
    "./tool" : 49
  }],
  38 : [function(parseFloat, module) {
    var Statement = (parseFloat("../math/cartesian"), parseFloat("./tool"));
    var s = (Math.round, parseFloat("./poweruptools/gravitytool"));
    var ItemsCount = parseFloat("./poweruptools/goaltool");
    var userUnderlinePosition = parseFloat("./poweruptools/boosttool");
    var lightDist = parseFloat("./poweruptools/slowmotool");
    var min_w1 = parseFloat("./poweruptools/checkpointtool");
    var tab_w = parseFloat("./poweruptools/bombtool");
    var tableElementOffsetLeft = parseFloat("./poweruptools/antigravitytool");
    var tableElementOffsetTop = parseFloat("./poweruptools/teleporttool");
    var LittleSmallscript = function(obj) {
      this.toolInit(obj);
      this.powerupTools = {};
      this.registerPowerupTools();
      this.options = {
        selected : "goal"
      };
    };
    var self = LittleSmallscript.prototype = new Statement;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.name = "Powerup";
    self.powerupTools = null;
    self.registerPowerupTools = function() {
      this.registerTool(new ItemsCount(this.toolhandler));
      this.registerTool(new userUnderlinePosition(this.toolhandler));
      this.registerTool(new s(this.toolhandler));
      this.registerTool(new lightDist(this.toolhandler));
      this.registerTool(new tab_w(this.toolhandler));
      this.registerTool(new min_w1(this.toolhandler));
      this.registerTool(new tableElementOffsetLeft(this.toolhandler));
      this.registerTool(new tableElementOffsetTop(this.toolhandler));
    };
    self.registerTool = function(type) {
      this.powerupTools[type.name] = type;
    };
    self.setOption = function(key, value) {
      this.options[key] = value;
    };
    self.getOptions = function() {
      return this.options;
    };
    self.update = function() {
      var instance = this.toolhandler.gamepad;
      var self = (this.mouse, this.options);
      if (instance.isButtonDown("opt1")) {
        self.selected = "goal";
        instance.setButtonUp("opt1");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt2")) {
        self.selected = "boost";
        instance.setButtonUp("opt2");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt3")) {
        self.selected = "gravity";
        instance.setButtonUp("opt3");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt4")) {
        self.selected = "slowmo";
        instance.setButtonUp("opt4");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt5")) {
        self.selected = "bomb";
        instance.setButtonUp("opt5");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt6")) {
        self.selected = "checkpoint";
        instance.setButtonUp("opt6");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt7")) {
        self.selected = "antigravity";
        instance.setButtonUp("opt7");
        this.scene.stateChanged();
      }
      if (instance.isButtonDown("opt8") && Application.User.get("classic")) {
        self.selected = "teleport";
        instance.setButtonUp("opt8");
        this.scene.stateChanged();
      }
      this.toolUpdate();
    };
    self.press = function() {
      var i = this.options.selected;
      this.powerupTools[i].press();
    };
    self.hold = function() {
      var i = this.options.selected;
      this.powerupTools[i].hold();
    };
    self.release = function() {
      var i = this.options.selected;
      this.powerupTools[i].release();
    };
    self.draw = function() {
      var scene = this.scene;
      var o = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      var opt = this.options;
      this.powerupTools[opt.selected].draw(o);
    };
    module.exports = LittleSmallscript;
  }, {
    "../math/cartesian" : 14,
    "./poweruptools/antigravitytool" : 39,
    "./poweruptools/bombtool" : 40,
    "./poweruptools/boosttool" : 41,
    "./poweruptools/checkpointtool" : 42,
    "./poweruptools/goaltool" : 43,
    "./poweruptools/gravitytool" : 44,
    "./poweruptools/slowmotool" : 45,
    "./poweruptools/teleporttool" : 46,
    "./tool" : 49
  }],
  39 : [function(require, context) {
    var Particle = require("../../math/cartesian");
    var TreeBase = require("../tool");
    var Rectangle = require("../../sector/powerups/antigravity");
    var init = function(action) {
      this.toolInit(action);
      this.powerup = new Rectangle(0, 0, action.scene.track);
      this.p1 = new Particle(0, 0);
      this.p2 = new Particle(0, 0);
      this.active = false;
    };
    var self = init.prototype = new TreeBase;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "antigravity";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var device = this.scene.settings.device;
      var camera = this.scene.screen;
      if (this.active === true) {
        var p = camera.realToScreen(this.p1.x, "x");
        var o = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(p, o, r, x);
        x.globalAlpha = 1;
      } else {
        if ("desktop" === device) {
          p = camera.realToScreen(node.real.x, "x");
          o = camera.realToScreen(node.real.y, "y");
          x.globalAlpha = 0.8;
          this.powerup.draw(p, o, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      var w = this.scene.track;
      var rect = new Rectangle(this.p1.x, this.p1.y, w);
      w.addPowerup(rect);
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [rect]
      });
    };
    context.exports = init;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/antigravity" : 20,
    "../tool" : 49
  }],
  40 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../../math/cartesian");
    var Shape = __webpack_require__("../tool");
    var Flower = __webpack_require__("../../sector/powerups/bomb");
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Flower(0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Shape;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "bomb";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var device = this.scene.settings.device;
      var camera = this.scene.screen;
      if (this.active === true) {
        var p = camera.realToScreen(this.p1.x, "x");
        var o = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(p, o, r, x);
        x.globalAlpha = 1;
      } else {
        if ("desktop" === device) {
          p = camera.realToScreen(node.real.x, "x");
          o = camera.realToScreen(node.real.y, "y");
          x.globalAlpha = 0.8;
          this.powerup.draw(p, o, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var ctx = (this.scene.screen, this.scene.track);
      var val = new Flower(this.p1.x, this.p1.y, ctx);
      ctx.addPowerup(val);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [val]
      });
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/bomb" : 21,
    "../tool" : 49
  }],
  41 : [function(require, module) {
    var Point = require("../../math/cartesian");
    var Progress = require("../tool");
    var Acceleration = require("../../sector/powerups/boost");
    var PI = Math.PI;
    var atan2 = Math.atan2;
    var pow = Math.pow;
    var rnd = Math.sqrt;
    var max = Math.max;
    var min = Math.min;
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Acceleration(0, 0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Progress;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "boost";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var obj = this.scene.track;
      var a = new Acceleration(this.p1.x, this.p1.y, this.powerup.angle, obj);
      obj.addPowerup(a);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [a]
      });
    };
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var camera = this.scene.screen;
      var device = this.scene.settings.device;
      if (this.active === true) {
        var a = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        var p1 = this.p1;
        var p2 = this.p2;
        var profName = p1.y - p2.y;
        var p = p1.x - p2.x;
        var angle = atan2(p1.y - p2.y, p1.x - p2.x);
        if (0 === p && 0 === profName) {
          angle = PI - PI / 2;
        }
        if (0 > angle) {
          angle = angle + 2 * PI;
        }
        this.drawPathToMouse(x, angle);
        this.powerup.angle = angle * (180 / PI) - 90 | 0;
        this.powerup.draw(a, undefined, r, x);
      } else {
        if ("desktop" === device) {
          x.globalAlpha = 0.8;
          this.powerup.angle = 0;
          a = camera.realToScreen(node.real.x, "x");
          undefined = camera.realToScreen(node.real.y, "y");
          this.powerup.draw(a, undefined, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.drawPathToMouse = function(context, num) {
      var v1 = this.p1;
      var p2 = this.p2;
      var assert = this.scene.screen;
      var ratio = this.scene.camera.zoom;
      var x = assert.realToScreen(v1.x, "x");
      var t = assert.realToScreen(v1.y, "y");
      var n = assert.realToScreen(p2.x, "x");
      var y = assert.realToScreen(p2.y, "y");
      var width = rnd(pow(n - x, 2) + pow(y - t, 2));
      if (30 * ratio > width) {
        width = 30 * ratio;
      }
      context.strokeStyle = "#ADCF7D";
      context.lineWidth = max(1, 2 * ratio);
      context.beginPath();
      context.moveTo(x, t);
      context.lineTo(x + width, t);
      context.stroke();
      context.beginPath();
      context.moveTo(x, t);
      context.lineTo(n, y);
      context.stroke();
      context.closePath();
      var s = num + 180 * (PI / 180);
      var a = min(width, 50 * ratio);
      context.beginPath();
      context.moveTo(x, t);
      context.arc(x, t, a, s, 0, false);
      context.moveTo(x, t);
      context.stroke();
      context.fillStyle = "rgba(173, 207, 125,0.2)";
      context.fill();
      context.closePath();
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/boost" : 22,
    "../tool" : 49
  }],
  42 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../../math/cartesian");
    var Shape = __webpack_require__("../tool");
    var Flower = __webpack_require__("../../sector/powerups/checkpoint");
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Flower(0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Shape;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "checkpoint";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var device = this.scene.settings.device;
      var camera = this.scene.screen;
      if (this.active === true) {
        var p = camera.realToScreen(this.p1.x, "x");
        var o = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(p, o, r, x);
        x.globalAlpha = 1;
      } else {
        if ("desktop" === device) {
          p = camera.realToScreen(node.real.x, "x");
          o = camera.realToScreen(node.real.y, "y");
          x.globalAlpha = 0.8;
          this.powerup.draw(p, o, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var ctx = (this.scene.screen, this.scene.track);
      var val = new Flower(this.p1.x, this.p1.y, ctx);
      ctx.addPowerup(val);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [val]
      });
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/checkpoint" : 23,
    "../tool" : 49
  }],
  43 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../../math/cartesian");
    var Shape = __webpack_require__("../tool");
    var Rect = __webpack_require__("../../sector/powerups/target");
    var update = function(action) {
      this.toolInit(action);
      this.powerup = new Rect(0, 0, action.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = update.prototype = new Shape;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "goal";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var device = this.scene.settings.device;
      var camera = this.scene.screen;
      if (this.active === true) {
        var p = camera.realToScreen(this.p1.x, "x");
        var o = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(p, o, r, x);
        x.globalAlpha = 1;
      } else {
        if ("desktop" === device) {
          p = camera.realToScreen(node.real.x, "x");
          o = camera.realToScreen(node.real.y, "y");
          x.globalAlpha = 0.8;
          this.powerup.draw(p, o, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var graph = (this.scene.screen, this.scene.track);
      var rect = new Rect(this.p1.x, this.p1.y, graph);
      graph.addTarget(rect);
      graph.addPowerup(rect);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [rect]
      });
    };
    module.exports = update;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/target" : 26,
    "../tool" : 49
  }],
  44 : [function(require, module) {
    var Point = require("../../math/cartesian");
    var Progress = require("../tool");
    var Acceleration = require("../../sector/powerups/gravity");
    var PI = Math.PI;
    var atan2 = Math.atan2;
    var pow = Math.pow;
    var rnd = Math.sqrt;
    var max = Math.max;
    var min = Math.min;
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Acceleration(0, 0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Progress;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "gravity";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var obj = this.scene.track;
      var a = new Acceleration(this.p1.x, this.p1.y, this.powerup.angle - 180, obj);
      obj.addPowerup(a);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [a]
      });
    };
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var camera = this.scene.screen;
      var device = this.scene.settings.device;
      if (this.active === true) {
        var a = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        var p1 = this.p1;
        var p2 = this.p2;
        var profName = p1.y - p2.y;
        var p = p1.x - p2.x;
        var angle = atan2(p1.y - p2.y, p1.x - p2.x);
        if (0 === p && 0 === profName) {
          angle = PI - PI / 2;
        }
        if (0 > angle) {
          angle = angle + 2 * PI;
        }
        this.drawPathToMouse(x, angle);
        this.powerup.angle = angle * (180 / PI) + 90 | 0;
        this.powerup.draw(a, undefined, r, x);
      } else {
        if ("desktop" === device) {
          x.globalAlpha = 0.8;
          this.powerup.angle = 180;
          a = camera.realToScreen(node.real.x, "x");
          undefined = camera.realToScreen(node.real.y, "y");
          this.powerup.draw(a, undefined, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.drawPathToMouse = function(context, num) {
      var v1 = this.p1;
      var p2 = this.p2;
      var assert = this.scene.screen;
      var ratio = this.scene.camera.zoom;
      var x = assert.realToScreen(v1.x, "x");
      var t = assert.realToScreen(v1.y, "y");
      var n = assert.realToScreen(p2.x, "x");
      var y = assert.realToScreen(p2.y, "y");
      var width = rnd(pow(n - x, 2) + pow(y - t, 2));
      if (30 * ratio > width) {
        width = 30 * ratio;
      }
      context.strokeStyle = "#A2B7D2";
      context.lineWidth = max(1, 2 * ratio);
      context.beginPath();
      context.moveTo(x, t);
      context.lineTo(x + width, t);
      context.stroke();
      context.beginPath();
      context.moveTo(x, t);
      context.lineTo(n, y);
      context.stroke();
      context.closePath();
      var s = num + 180 * (PI / 180);
      var a = min(width, 50 * ratio);
      context.beginPath();
      context.moveTo(x, t);
      context.arc(x, t, a, s, 0, false);
      context.moveTo(x, t);
      context.stroke();
      context.fillStyle = "rgba(162, 183, 210,0.2)";
      context.fill();
      context.closePath();
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/gravity" : 24,
    "../tool" : 49
  }],
  45 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../../math/cartesian");
    var Shape = __webpack_require__("../tool");
    var Flower = __webpack_require__("../../sector/powerups/slowmo");
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Flower(0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Shape;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "slowmo";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var device = this.scene.settings.device;
      var camera = this.scene.screen;
      if (this.active === true) {
        var p = camera.realToScreen(this.p1.x, "x");
        var o = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(p, o, r, x);
        x.globalAlpha = 1;
      } else {
        if ("desktop" === device) {
          p = camera.realToScreen(node.real.x, "x");
          o = camera.realToScreen(node.real.y, "y");
          x.globalAlpha = 0.8;
          this.powerup.draw(p, o, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var ctx = (this.scene.screen, this.scene.track);
      var val = new Flower(this.p1.x, this.p1.y, ctx);
      ctx.addPowerup(val);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [val]
      });
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/slowmo" : 25,
    "../tool" : 49
  }],
  46 : [function(__webpack_require__, module) {
    var Point = __webpack_require__("../../math/cartesian");
    var Shape = __webpack_require__("../tool");
    var Flower = __webpack_require__("../../sector/powerups/teleport");
    var PI = Math.PI;
    var atan2 = Math.atan2;
    var pow = Math.pow;
    var msqrt = Math.sqrt;
    var max = Math.max;
    var updateScrollEvents = (Math.min, Math.abs);
    var Line = function(data) {
      this.toolInit(data);
      this.powerup = new Flower(0, 0, data.scene.track);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
    };
    var self = Line.prototype = new Shape;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.portal1 = null;
    self.name = "teleport";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      var ctx = (this.scene.screen, this.scene.track);
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.portal1 = new Flower(this.p1.x, this.p1.y, ctx);
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var lfReceivedUnread = updateScrollEvents(this.p2.x - this.p1.x);
      var lfReceivedRead = updateScrollEvents(this.p2.y - this.p1.y);
      if (lfReceivedUnread > 40 || lfReceivedRead > 40) {
        var obj = this.scene.track;
        this.portal2 = new Flower(this.p2.x, this.p2.y, obj);
        this.portal1.addOtherPortalRef(this.portal2);
        this.portal2.addOtherPortalRef(this.portal1);
        obj.addPowerup(this.portal1);
        obj.addPowerup(this.portal2);
        this.toolhandler.addActionToTimeline({
          type : "add",
          objects : [this.portal1, this.portal2]
        });
        this.active = false;
      } else {
        this.active = false;
        this.portal1 = null;
      }
    };
    self.draw = function(x) {
      var node = this.mouse.touch;
      var r = (node.pos, this.camera.zoom);
      var camera = this.scene.screen;
      var device = this.scene.settings.device;
      if (this.active === true) {
        var a = camera.realToScreen(this.p1.x, "x");
        var val = camera.realToScreen(this.p1.y, "y");
        var test = camera.realToScreen(this.p2.x, "x");
        var undefined = camera.realToScreen(this.p2.y, "y");
        var p1 = this.p1;
        var p2 = this.p2;
        var c = p1.y - p2.y;
        var d = p1.x - p2.x;
        var angle = atan2(p1.y - p2.y, p1.x - p2.x);
        if (0 === d && 0 === c) {
          angle = PI - PI / 2;
        }
        if (0 > angle) {
          angle = angle + 2 * PI;
        }
        this.drawPathToMouse(x, angle);
        this.portal1.draw(a, val, r, x);
        this.powerup.draw(test, undefined, r, x);
      } else {
        if ("desktop" === device) {
          x.globalAlpha = 0.8;
          var g = camera.realToScreen(node.real.x, "x");
          var undefined = camera.realToScreen(node.real.y, "y");
          this.powerup.draw(g, undefined, r, x);
          x.globalAlpha = 1;
        }
      }
    };
    self.drawPathToMouse = function(g) {
      var v1 = this.p1;
      var p2 = this.p2;
      var assert = this.scene.screen;
      var enemyGold = this.scene.camera.zoom;
      var p = assert.realToScreen(v1.x, "x");
      var y = assert.realToScreen(v1.y, "y");
      var t = assert.realToScreen(p2.x, "x");
      var n = assert.realToScreen(p2.y, "y");
      var potential = msqrt(pow(t - p, 2) + pow(n - y, 2));
      if (30 * enemyGold > potential) {
        potential = 30 * enemyGold;
      }
      g.strokeStyle = "#dd45ec";
      g.lineWidth = max(1, 2 * enemyGold);
      g.beginPath();
      g.moveTo(p, y);
      g.lineTo(t, n);
      g.stroke();
      g.closePath();
    };
    module.exports = Line;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/powerups/teleport" : 27,
    "../tool" : 49
  }],
  47 : [function(require, module) {
    var Point = require("../math/cartesian");
    var TreeBase = require("./tool");
    var ent = require("../utils/path");
    var Context = require("../sector/physicsline");
    var EventEmitter = require("../sector/sceneryline");
    var min = Math.min;
    var max = Math.max;
    var abs = Math.abs;
    var Tooltip = function(obj) {
      this.toolInit(obj);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.selectedElements = [];
      this.dashOffset = 0;
    };
    var self = Tooltip.prototype = new TreeBase;
    self.toolInit = self.init;
    self.name = "Select";
    self.passive = false;
    self.active = false;
    self.p1 = null;
    self.p2 = null;
    self.selectedElements = [];
    self.dashOffset = 0;
    self.selectedSectors = [];
    self.press = function() {
      var b = this.mouse.touch.real;
      this.passive = false;
      this.active = true;
      this.p1.x = b.x;
      this.p1.y = b.y;
      this.p2.x = b.x;
      this.p2.y = b.y;
    };
    self.hold = function() {
      var b = this.mouse.touch.real;
      this.p2.x = b.x;
      this.p2.y = b.y;
    };
    self.unselectElements = function() {
      var manifest = this.selectedElements;
      var l = manifest.length;
      var i = 0;
      for (; l > i; i++) {
        var view = manifest[i];
        if (view instanceof Context) {
          view.highlightLine(false);
        }
        if (view instanceof EventEmitter) {
          view.highlightLine(false);
        }
      }
    };
    self.release = function() {
      this.unselectElements();
      var pathSizes = (performance.now(), this.scene.track.select(this.p1, this.p2));
      var pathCount = pathSizes.length;
      var colorDist = [];
      var pathId = 0;
      for (; pathCount > pathId; pathId++) {
        var n = pathSizes[pathId];
        if (this.intersectsLine(n.p1, n.p2)) {
          n.removeAllReferences();
          colorDist.push(n);
        }
      }
      this.selectedElements = colorDist;
      this.active = false;
      this.passive = true;
    };
    self.buildPaths = function(item) {
      var _posPoints = [];
      for (; item.length > 0;) {
        var o = new ent;
        o.build(item);
        _posPoints.push(o);
      }
    };
    self.intersectsLine = function(start, end) {
      var h = min(this.p1.y, this.p2.y);
      var minX = min(this.p1.x, this.p2.x);
      var v = max(this.p1.y, this.p2.y);
      var maxX = max(this.p1.x, this.p2.x);
      var r = abs(maxX - minX);
      var g = abs(h - v);
      var i = start.x;
      var x = end.x;
      if (start.x > end.x && (i = end.x, x = start.x), x > minX + r && (x = minX + r), minX > i && (i = minX), i > x) {
        return false;
      }
      var ch = start.y;
      var a = end.y;
      var factor = end.x - start.x;
      if (abs(factor) > 1e-7) {
        var m = (end.y - start.y) / factor;
        var b = start.y - m * start.x;
        ch = m * i + b;
        a = m * x + b;
      }
      if (ch > a) {
        var s = a;
        a = ch;
        ch = s;
      }
      return a > h + g && (a = h + g), h > ch && (ch = h), ch > a ? false : true;
    };
    self.toScreen = function(width, i) {
      var camera = this.scene.camera;
      var screen = this.scene.screen;
      return (width - camera.position[i]) * camera.zoom + screen.center[i];
    };
    self.draw = function() {
      var scene = this.scene;
      var ctx = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      if (this.drawText(ctx), this.active || this.passive) {
        var p = this.p1.toScreen(this.scene);
        var drop = this.p2.toScreen(this.scene);
        var width = drop.x - p.x;
        var height = drop.y - p.y;
        ctx.save();
        if (ctx.setLineDash) {
          ctx.setLineDash([6]);
          ctx.lineDashOffset = this.dashOffset;
        }
        if (this.active) {
          ctx.beginPath();
          ctx.rect(p.x, p.y, width, height);
          ctx.fillStyle = "rgba(24, 132, 207, 0.3)";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(24, 132, 207, 0.7)";
          ctx.stroke();
        } else {
          if (this.passive) {
            ctx.strokeStyle = "rgba(24, 132, 207, 0.7)";
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x, p.y, width, height);
          }
        }
        ctx.restore();
        if (this.dashOffset > 22) {
          this.dashOffset = 0;
        }
        this.dashOffset++;
      }
    };
    self.reset = function() {
      this.p1.x = 0;
      this.p1.y = 0;
      this.p2.x = 0;
      this.p2.y = 0;
      this.active = false;
      this.passive = false;
      this.unselectElements();
    };
    self.drawSectors = function() {
      var self = this.scene;
      var camera = self.camera;
      var canvas = self.screen;
      var context = self.game.canvas.getContext("2d");
      var zoom = camera.zoom;
      var pos = camera.position;
      var currentCenter = self.screen.center;
      var scale = this.settings.drawSectorSize * zoom;
      var y = pos.x * zoom / scale;
      var minValue = pos.y * zoom / scale;
      var i = canvas.width / scale;
      var translateX = canvas.height / scale;
      var baseName = translateX / 2;
      var offset = i / 2;
      var scaledMargin = y - offset - 1;
      var initialValue = minValue - baseName - 1;
      var j = y + offset;
      var middlePathName = minValue + baseName;
      var a = this.totalSectors;
      var x = a.length;
      var key = 0;
      for (; x > key; key++) {
        var me = a[key];
        var maxValue = me.row;
        var i = me.column;
        if (i >= scaledMargin && j >= i && maxValue >= initialValue && middlePathName >= maxValue) {
          if (me.drawn === false && me.image === false) {
            me.draw();
          }
          var placex = i * scale - y * scale + currentCenter.x;
          var textureY = maxValue * scale - minValue * scale + currentCenter.y;
          placex = 0 | placex;
          textureY = 0 | textureY;
          if (me.image) {
            context.drawImage(me.image, placex, textureY);
          } else {
            context.drawImage(me.canvas, placex, textureY);
          }
        } else {
          if (me.drawn) {
            me.clear();
          }
        }
      }
    };
    self.drawText = function(ctx) {
      {
        var name = this.name;
        var dpr = this.game.pixelRatio;
        var scene = this.scene;
        scene.game.canvas;
        this.radius;
      }
      ctx.save();
      ctx.fillStyle = "#000000";
      ctx.font = 12 * dpr + "pt arial";
      ctx.fillText(name, 10 * dpr, 20 * dpr);
      ctx.font = 8 * dpr + "pt arial";
    };
    self.close = function() {
      this.dashOffset = 0;
      this.selectedElements = [];
      this.mouse = null;
      this.camera = null;
      this.scene = null;
      this.toolHandler = null;
      this.p2 = null;
      this.p1 = null;
      this.active = false;
      this.passive = false;
    };
    module.exports = Tooltip;
  }, {
    "../math/cartesian" : 14,
    "../sector/physicsline" : 18,
    "../sector/sceneryline" : 28,
    "../utils/path" : 64,
    "./tool" : 49
  }],
  48 : [function(__webpack_require__, mixin) {
    var Point = __webpack_require__("../math/cartesian");
    var Mock = __webpack_require__("./tool");
    var m = (Math.sqrt, Math.pow, function(self) {
      this.game = self.scene.game;
      this.toolInit(self);
      this.p1 = new Point(0, 0);
      this.p2 = new Point(0, 0);
      this.active = false;
      this.shouldDrawMetadata = false;
      this.options = {};
    });
    var self = m.prototype = new Mock;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.toolDraw = self.draw;
    self.name = "StraightLine";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.reset = function() {
      this.active = false;
    };
    self.press = function() {
      if (!this.active) {
        var b = this.mouse.touch.real;
        this.p1.x = b.x;
        this.p1.y = b.y;
        this.active = true;
      }
    };
    self.getOptions = function() {
      var options = this.toolhandler;
      var o = this.options;
      return o.lineType = options.options.lineType, o.snap = options.options.snap, o;
    };
    self.hold = function() {
      var b = this.mouse.touch.real;
      this.p2.x = b.x;
      this.p2.y = b.y;
      this.toolhandler.moveCameraTowardsMouse();
    };
    self.release = function() {
      var p1 = this.p1;
      var p2 = this.p2;
      var geometrize_rasterizer_Rasterizer = this.scene.track;
      var el = this.toolhandler;
      var inFolder = false;
      inFolder = "physics" === el.options.lineType ? geometrize_rasterizer_Rasterizer.addPhysicsLine(p1.x, p1.y, p2.x, p2.y) : geometrize_rasterizer_Rasterizer.addSceneryLine(p1.x, p1.y, p2.x, p2.y);
      if (inFolder) {
        el.addActionToTimeline({
          type : "add",
          objects : [inFolder]
        });
      }
      var p = el.snapPoint;
      p.x = p2.x;
      p.y = p2.y;
      this.active = false;
    };
    self.update = function() {
      this.toolUpdate();
      var that = this.toolhandler;
      var mouse = that.gamepad;
      if (that.options.snap) {
        this.active = true;
        this.p1 = that.snapPoint;
        this.hold();
      }
      this.shouldDrawMetadata = mouse.isButtonDown("ctrl") ? true : false;
    };
    self.draw = function() {
      var scene = this.scene;
      var node = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      var camera = scene.camera;
      var zoom = camera.zoom;
      node.save();
      this.drawCursor(node);
      if (this.active) {
        this.drawLine(node, zoom);
        this.drawPoint(node, this.p1, zoom);
        this.drawPoint(node, this.p2, zoom);
        this.drawPointData(node, this.p2, zoom);
      }
      node.restore();
    };
    self.drawCursor = function(ctx) {
      var self = this.mouse.touch;
      var obj = self.real.toScreen(this.scene);
      var zoom = this.camera.zoom;
      var data = this.toolhandler;
      var r = (data.options.lineType, data.options.grid);
      var parBgColor = "#1884cf";
      if (r) {
        var r = 5 * zoom;
        ctx.beginPath();
        ctx.moveTo(obj.x, obj.y - r);
        ctx.lineTo(obj.x, obj.y + r);
        ctx.moveTo(obj.x - r, obj.y);
        ctx.lineTo(obj.x + r, obj.y);
        ctx.lineWidth = 1 * zoom;
        ctx.closePath();
        ctx.stroke();
      } else {
        ctx.lineWidth = 1;
        ctx.fillStyle = parBgColor;
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, 1 * zoom, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.fill();
      }
    };
    self.drawPoint = function(ctx, text, size) {
      var obj = text.toScreen(this.scene);
      ctx.beginPath();
      ctx.arc(obj.x, obj.y, 1 * size, 0, 2 * Math.PI, false);
      ctx.lineWidth = 1;
      ctx.fillStyle = "#1884cf";
      ctx.fill();
    };
    self.drawPointData = function(ctx, options) {
      var intersect = options.toScreen(this.scene);
      if (this.shouldDrawMetadata) {
        var s = this.p1.getAngleInDegrees(this.p2);
        s = s.toFixed(2);
        var targets = this.game.pixelRatio;
        ctx.fillStyle = "#000000";
        ctx.font = 8 * targets + "pt arial";
        ctx.fillText("" + s + "\u00b0", intersect.x + 10, intersect.y + 10);
        ctx.strokeText("" + s + "\u00b0", intersect.x + 10, intersect.y + 10);
      }
    };
    self.drawLine = function(context, props) {
      var scene = this.scene;
      var buttonStrokeSize = (scene.game.canvas, 2 * props > 0.5 ? 2 * props : 0.5);
      var options = this.toolhandler;
      var lineType = options.options.lineType;
      var color = "physics" === lineType ? "#000" : "#AAA";
      context.beginPath();
      context.lineWidth = buttonStrokeSize;
      context.lineCap = "round";
      context.strokeStyle = color;
      var obj = this.p1.toScreen(this.scene);
      var thumbPoint = this.p2.toScreen(this.scene);
      context.moveTo(obj.x, obj.y);
      context.lineTo(thumbPoint.x, thumbPoint.y);
      context.stroke();
    };
    mixin.exports = m;
  }, {
    "../math/cartesian" : 14,
    "./tool" : 49
  }],
  49 : [function(saveNotifs, module) {
    var Dialog = (saveNotifs("../math/cartesian"), Math.round, function() {
    });
    Dialog.prototype = {
      name : "",
      toolhandler : null,
      camera : null,
      mouse : null,
      scene : null,
      init : function(options) {
        this.toolhandler = options;
        this.scene = options.scene;
        this.game = options.scene.game;
        this.camera = options.scene.camera;
        this.mouse = options.scene.mouse;
        this.gamepad = options.gamepad;
      },
      press : function() {
      },
      hold : function() {
      },
      release : function() {
      },
      update : function() {
        var node = this.mouse;
        var t = node.touch;
        var cur = node.secondaryTouch;
        var aggregator = this.toolhandler.gamepad;
        var button = this.toolhandler.options;
        var i = aggregator.isButtonDown("shift");
        if (button.rightClickMove) {
          i = cur.old.down;
        }
        if (i) {
          if (t.old.down || button.rightClickMove) {
            this.moveCamera();
          }
        } else {
          if (t.press) {
            this.press();
          }
          if (t.old.down) {
            this.hold();
          }
          if (t.release) {
            this.release();
          }
        }
        if (node.mousewheel !== false && aggregator.isButtonDown("shift") === false) {
          this.mousewheel(node.mousewheel);
        }
      },
      moveCamera : function() {
        var e = this.mouse.secondaryTouch;
        var start = e.pos;
        var camera = this.camera;
        var i = e.old.pos.sub(start).factor(1 / camera.zoom);
        camera.position.inc(i);
      },
      draw : function() {
      },
      reset : function() {
      },
      mousewheel : function(factor) {
        var options = this.scene.settings;
        var scale = this.scene.game.pixelRatio;
        var step = options.cameraSensitivity;
        var zoom = options.cameraZoomMin;
        var z = options.cameraZoomMax;
        var newScale = zoom * scale;
        var z2 = z * scale;
        var self = this.camera;
        var org = this.mouse.touch;
        var value = self.desiredZoom;
        value = value + factor * step;
        self.setZoom(value / scale, org.pos);
        if (self.desiredZoom < newScale) {
          self.setZoom(zoom, org.pos);
        } else {
          if (self.desiredZoom > z2) {
            self.setZoom(z, org.pos);
          }
        }
      },
      checkKeys : function() {
        var player = this.gamepad;
        var type = this.name.toLowerCase();
        var self = this.toolhandler;
        if (player.isButtonDown(type)) {
          self.setTool(type);
          player.setButtonUp(type);
        }
      },
      getOptions : function() {
        return {};
      },
      close : function() {
      }
    };
    module.exports = Dialog;
  }, {
    "../math/cartesian" : 14
  }],
  50 : [function(floor, exp) {
    var I = floor("../math/cartesian");
    var round = (floor("../utils/canvaspool"), Math.sqrt, Math.pow, Math.floor);
    var startYNew = floor("../sector/physicsline");
    var startXNew = floor("../sector/sceneryline");
    var NamedTableId = floor("../sector/powerups/target");
    var maxSize = 50;
    var create = function(options) {
      this.currentTool = "";
      this.scene = options;
      this.camera = options.camera;
      this.mouse = options.mouse;
      this.mouse.updateCallback = this.draw.bind(this);
      this.gamepad = options.playerManager.firstPlayer.getGamepad();
      this.tools = {};
      this.options = options.settings.toolHandler;
      this.snapPoint = new I;
      this.snapPoint.equ(this.scene.track.defaultLine.p2);
      this.gridCache = false;
      this.initAnalytics();
      this.actionTimeline = [];
      this.actionTimelinePointer = 0;
    };
    create.prototype = {
      currentTool : "",
      scene : null,
      camera : null,
      mouse : null,
      tools : {},
      gamepad : null,
      gridCache : false,
      gridCacheAlpha : 1,
      gridUseEnabled : false,
      snapPoint : false,
      options : null,
      initAnalytics : function() {
        this.analytics = {
          actions : 0
        };
      },
      enableGridUse : function() {
        this.gridUseEnabled = true;
      },
      getToolOptions : function() {
        return this.tools[this.currentTool].getOptions();
      },
      setToolOption : function(key, type, name) {
        if ("undefined" != typeof name && "undefined" != typeof this.tools[name]) {
          this.tools[name].setOption(key, type);
        } else {
          this.tools[this.currentTool].setOption(key, type);
        }
        this.scene.stateChanged();
      },
      registerTool : function(type) {
        type = new type(this);
        var name = type.name.toLowerCase();
        this.tools[name] = type;
      },
      setTool : function(name) {
        {
          name = name.toLowerCase();
          this.scene;
        }
        if (this.currentTool !== name) {
          this.resetTool();
          this.currentTool = name;
          this.scene.stateChanged();
          this.analytics.actions++;
        }
      },
      addActionToTimeline : function(t) {
        if (this.actionTimeline.length >= maxSize) {
          this.actionTimeline.splice(0, this.actionTimeline.length - maxSize);
          this.actionTimelinePointer = maxSize;
        }
        this.actionTimeline.splice(this.actionTimelinePointer);
        this.actionTimeline.push(t);
        this.actionTimelinePointer++;
      },
      revertAction : function() {
        var t = this.actionTimelinePointer;
        if (t > 0) {
          var aggs = this.actionTimeline[t - 1];
          switch(t--, aggs.type) {
            case "add":
              this.removeObjects(aggs.objects);
              break;
            case "remove":
              this.addObjects(aggs.objects);
          }
          this.actionTimelinePointer = t;
        }
      },
      applyAction : function() {
        var crossfilterable_layers = this.actionTimeline;
        var layer_i = this.actionTimelinePointer;
        if (layer_i < crossfilterable_layers.length) {
          var layer = this.actionTimeline[layer_i];
          switch(layer_i++, layer.type) {
            case "add":
              this.addObjects(layer.objects);
              break;
            case "remove":
              this.removeObjects(layer.objects);
          }
          this.actionTimelinePointer = layer_i;
        }
      },
      removeObjects : function(s) {
        var l = s.length;
        var i = 0;
        for (; l > i; i++) {
          var entry = s[i];
          entry.remove = true;
          entry.removeAllReferences();
        }
        this.scene.track.cleanTrack();
      },
      addObjects : function(list) {
        var i = list.length;
        var t = this.scene.track;
        var l = 0;
        for (; i > l; l++) {
          var target = list[l];
          if (target instanceof startYNew) {
            target.remove = false;
            t.addPhysicsLineToTrack(target);
          } else {
            if (target instanceof startXNew) {
              target.remove = false;
              t.addSceneryLineToTrack(target);
            } else {
              if (target instanceof NamedTableId) {
                target.remove = false;
                t.addTarget(target);
                t.addPowerup(target);
              } else {
                target.remove = false;
                t.addPowerup(target);
              }
            }
          }
        }
      },
      resetTool : function() {
        if ("" !== this.currentTool) {
          this.tools[this.currentTool].reset();
        }
      },
      update : function() {
        this.checkGrid();
        if (this.mouse.enabled) {
          this.tools[this.currentTool].update();
        }
        this.checkHotkeys();
        this.checkMouse();
        this.checkSnap();
      },
      checkGrid : function() {
        var camera = this.scene.camera;
        if (camera.zoom !== camera.desiredZoom) {
          this.gridCache = false;
        }
      },
      checkSnap : function() {
        if (this.options.snapLocked) {
          this.options.snap = true;
        }
      },
      moveCameraTowardsMouse : function() {
        if (this.options.cameraLocked === false) {
          var container = this.scene.screen;
          var height = 100;
          var currentMin = container.height - height;
          var total = 0 + height;
          var bottom = container.width - height;
          var left = 0 + height;
          var x = this.options.cameraMoveSpeed;
          var c = container.center;
          var camera = this.camera;
          var org = this.mouse.touch;
          var right = org.pos.x;
          var max = org.pos.y;
          var mesh_size_x = 0.8 * (right - c.x);
          var j = max - c.y;
          if (right >= bottom || left >= right || max >= currentMin || total >= max) {
            camera.position.x += mesh_size_x * x * (1 / camera.zoom);
            camera.position.y += j * x * (1 / camera.zoom);
          }
        }
      },
      checkMouse : function() {
        var touch = this.mouse.touch;
        var e = this.mouse.secondaryTouch;
        if (touch.press || e.press) {
          this.press();
        }
      },
      press : function() {
        this.camera.unfocus();
      },
      checkHotkeys : function() {
        var assert = this.gamepad;
        var celldiag = this.options.snap;
        var rdfnode = this.options.snapLocked;
        var cMethod = this.options.rightClickMove;
        var cellright = assert.isButtonDown("alt");
        if (cMethod) {
          cellright = assert.isButtonDown("shift");
        }
        if (cellright && !celldiag) {
          this.toggleQuickSnap();
        } else {
          if (!(cellright || !celldiag || rdfnode)) {
            this.toggleQuickSnap();
          }
        }
        if (assert.isButtonDown("ctrl") && assert.isButtonDown("z")) {
          assert.setButtonUp("z");
          this.revertAction();
        }
        if (assert.isButtonDown("ctrl") && assert.isButtonDown("y")) {
          assert.setButtonUp("y");
          this.applyAction();
        }
        var _tools = this.tools;
        var name;
        for (name in _tools) {
          var _tool = _tools[name];
          _tool.checkKeys();
        }
        if (this.gridUseEnabled && assert.isButtonDown("grid")) {
          assert.setButtonUp("grid");
          this.toggleGrid();
        }
        if (assert.isButtonDown("zoom_increase")) {
          assert.setButtonUp("zoom_increase");
          this.scene.camera.increaseZoom();
        }
        if (assert.isButtonDown("zoom_decrease")) {
          assert.setButtonUp("zoom_decrease");
          this.scene.camera.decreaseZoom();
        }
        if (assert.isButtonDown("zoom_100")) {
          assert.setButtonUp("zoom_100");
          this.scene.camera.resetZoom();
        }
        if (assert.isButtonDown("lineType")) {
          assert.setButtonUp("lineType");
          this.toggleLineType();
        }
      },
      toggleLineType : function() {
        var lineType = this.options.lineType;
        this.options.lineType = "physics" === lineType ? "scenery" : "physics";
        this.scene.stateChanged();
      },
      toggleGrid : function() {
        this.options.grid = this.scene.state.grid = !this.options.grid;
        this.scene.stateChanged();
      },
      toggleSnap : function() {
        this.options.snap = !this.options.snap;
        this.options.snapLocked = !this.options.snapLocked;
        this.resetTool();
        this.scene.stateChanged();
      },
      toggleQuickSnap : function() {
        if (!this.options.snapLocked) {
          this.options.snap = !this.options.snap;
          this.resetTool();
          this.scene.stateChanged();
        }
      },
      toggleCameraLock : function() {
        this.options.cameraLocked = !this.options.cameraLocked;
        this.scene.stateChanged();
      },
      draw : function() {
        this.scene.game.pixelRatio;
        this.scene.game.canvas.getContext("2d");
        if (this.mouse.enabled) {
          this.tools[this.currentTool].draw();
        }
      },
      drawGrid : function() {
        var pixelRatio = this.scene.game.pixelRatio;
        var ctxSupport = this.scene.game.canvas.getContext("2d");
        if (this.options.grid === true && this.options.visibleGrid) {
          this.drawCachedGrid(ctxSupport, pixelRatio);
        }
      },
      drawCachedGrid : function(context, f) {
        if (this.gridCache === false) {
          this.cacheGrid(f);
        }
        var bitmap = this.gridCache;
        var w = bitmap.width;
        var size = bitmap.height;
        var s = this.scene.screen;
        var data = s.center;
        var x = (data.x / w | 0) + 2;
        var width = (data.y / size | 0) + 2;
        var zoom = this.camera.zoom;
        var sx = this.camera.position.x * zoom % w;
        var height = this.camera.position.y * zoom % size;
        context.globalAlpha = this.gridCacheAlpha;
        var r = -x;
        for (; x > r; r++) {
          var offset = -width;
          for (; width > offset; offset++) {
            var xThumbnail = r * w - sx + data.x;
            var dy = offset * size - height + data.y;
            context.drawImage(bitmap, 0, 0, size, w, xThumbnail, dy, w, size);
          }
        }
        context.globalAlpha = 1;
      },
      cacheGrid : function() {
        var r = this.scene.camera.zoom;
        var size = 200 * r;
        var h = 200 * r;
        var i = this.options.gridSize;
        var s = i * r;
        var canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = h;
        var ctx = canvas.getContext("2d");
        ctx.strokeStyle = this.options.gridMinorLineColor;
        ctx.strokeWidth = 1;
        ctx.beginPath();
        var b = null;
        var a = null;
        var x = null;
        var c = null;
        b = round(size / s);
        a = 0;
        for (; b >= a; a++) {
          x = a * s;
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        b = round(h / s);
        a = 0;
        for (; b >= a; a++) {
          c = a * s;
          ctx.moveTo(0, c);
          ctx.lineTo(size, c);
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.rect(0, 0, size, h);
        ctx.lineWidth = 2;
        ctx.strokeStyle = this.options.gridMajorLineColor;
        ctx.stroke();
        ctx.closePath();
        this.gridCache = canvas;
        this.gridCacheAlpha = Math.min(r + 0.2, 1);
      },
      resize : function() {
        var pixelRatio = this.scene.game.pixelRatio;
        this.cacheGrid(pixelRatio);
      },
      undo : function() {
      },
      redo : function() {
      },
      close : function() {
        this.actionTimeline = [];
        this.actionTimelinePointer = 0;
        this.tools = null;
        this.mouse = null;
        this.scene = null;
        this.camera = null;
        this.options.grid = false;
        this.options = null;
        this.gridCache = null;
      }
    };
    exp.exports = create;
  }, {
    "../math/cartesian" : 14,
    "../sector/physicsline" : 18,
    "../sector/powerups/target" : 26,
    "../sector/sceneryline" : 28,
    "../utils/canvaspool" : 58
  }],
  51 : [function(FbmNoise2, candidate) {
    var __ = (FbmNoise2("../math/cartesian"), FbmNoise2("./tool"));
    var s = (Math.round, FbmNoise2("./vehiclepoweruptools/helicoptertool"));
    var elevationNoise = FbmNoise2("./vehiclepoweruptools/trucktool");
    var ruggedNoise = FbmNoise2("./vehiclepoweruptools/balloontool");
    var erodeNoise = FbmNoise2("./vehiclepoweruptools/blobtool");
    var d = function(a) {
      this.toolInit(a);
      this.powerupTools = {};
      this.options = a.scene.settings.vehiclePowerup;
      this.registerPowerupTools();
    };
    var self = d.prototype = new __;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.name = "vehiclepowerup";
    self.powerupTools = null;
    self.registerPowerupTools = function() {
      this.registerTool(new s(this, this.toolhandler));
      this.registerTool(new elevationNoise(this, this.toolhandler));
      this.registerTool(new ruggedNoise(this, this.toolhandler));
      this.registerTool(new erodeNoise(this, this.toolhandler));
    };
    self.registerTool = function(type) {
      this.powerupTools[type.name] = type;
    };
    self.setOption = function(key, value) {
      this.options[key] = value;
    };
    self.getOptions = function() {
      return this.options;
    };
    self.update = function() {
      this.toolhandler.gamepad;
      this.mouse;
      this.options;
      this.toolUpdate();
    };
    self.press = function() {
      var i = this.options.selected;
      this.powerupTools[i].press();
    };
    self.hold = function() {
      var i = this.options.selected;
      this.powerupTools[i].hold();
    };
    self.release = function() {
      var i = this.options.selected;
      this.powerupTools[i].release();
    };
    self.draw = function() {
      var scene = this.scene;
      var o = (scene.game.canvas, scene.game.canvas.getContext("2d"));
      var opt = this.options;
      this.powerupTools[opt.selected].draw(o);
    };
    candidate.exports = d;
  }, {
    "../math/cartesian" : 14,
    "./tool" : 49,
    "./vehiclepoweruptools/balloontool" : 52,
    "./vehiclepoweruptools/blobtool" : 53,
    "./vehiclepoweruptools/helicoptertool" : 54,
    "./vehiclepoweruptools/trucktool" : 55
  }],
  52 : [function(__webpack_require__, context) {
    var Particle = __webpack_require__("../../math/cartesian");
    var _UiIcon = __webpack_require__("../tool");
    var Point = __webpack_require__("../../sector/vehiclepowerups/balloon");
    var init = function(obj, target) {
      this.toolInit(target);
      this.powerup = new Point(0, 0, 0, target.scene.track);
      this.p1 = new Particle(0, 0);
      this.p2 = new Particle(0, 0);
      this.options = obj.options;
      this.active = false;
    };
    var self = init.prototype = new _UiIcon;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "balloon";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var c = node.pos;
      var y = this.camera.zoom;
      var device = this.scene.settings.device;
      if (("desktop" === device || this.active) && (x.globalAlpha = 0.8, this.powerup.draw(c.x, c.y, y, x), x.globalAlpha = 1), this.active === true) {
        var camera = this.scene.screen;
        var o = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(o, undefined, y, x);
        x.globalAlpha = 1;
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var t = (this.scene.screen, this.scene.track);
      var o = new Point(this.p1.x, this.p1.y, this.options.time, t);
      t.addPowerup(o);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [o]
      });
    };
    context.exports = init;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/vehiclepowerups/balloon" : 30,
    "../tool" : 49
  }],
  53 : [function(require, context) {
    var Particle = require("../../math/cartesian");
    var TreeBase = require("../tool");
    var Point = require("../../sector/vehiclepowerups/blob");
    var init = function(obj, target) {
      this.toolInit(target);
      this.powerup = new Point(0, 0, 0, target.scene.track);
      this.p1 = new Particle(0, 0);
      this.options = obj.options;
      this.active = false;
    };
    var self = init.prototype = new TreeBase;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "blob";
    self.p1 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var c = node.pos;
      var y = this.camera.zoom;
      var device = this.scene.settings.device;
      if (("desktop" === device || this.active) && (x.globalAlpha = 0.8, this.powerup.draw(c.x, c.y, y, x), x.globalAlpha = 1), this.active === true) {
        var camera = this.scene.screen;
        var o = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(o, undefined, y, x);
        x.globalAlpha = 1;
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.active = true;
    };
    self.release = function() {
      var t = (this.scene.screen, this.scene.track);
      var o = new Point(this.p1.x, this.p1.y, this.options.time, t);
      t.addPowerup(o);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [o]
      });
    };
    context.exports = init;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/vehiclepowerups/blob" : 31,
    "../tool" : 49
  }],
  54 : [function(__webpack_require__, context) {
    var Particle = __webpack_require__("../../math/cartesian");
    var _UiIcon = __webpack_require__("../tool");
    var Point = __webpack_require__("../../sector/vehiclepowerups/helicopter");
    var init = function(obj, target) {
      this.toolInit(target);
      this.powerup = new Point(0, 0, 0, target.scene.track);
      this.p1 = new Particle(0, 0);
      this.p2 = new Particle(0, 0);
      this.options = obj.options;
      this.active = false;
    };
    var self = init.prototype = new _UiIcon;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "helicopter";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var c = node.pos;
      var y = this.camera.zoom;
      var device = this.scene.settings.device;
      if (("desktop" === device || this.active) && (x.globalAlpha = 0.8, this.powerup.draw(c.x, c.y, y, x), x.globalAlpha = 1), this.active === true) {
        var camera = this.scene.screen;
        var o = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(o, undefined, y, x);
        x.globalAlpha = 1;
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var t = (this.scene.screen, this.scene.track);
      var o = new Point(this.p1.x, this.p1.y, this.options.time, t);
      t.addPowerup(o);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [o]
      });
    };
    context.exports = init;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/vehiclepowerups/helicopter" : 32,
    "../tool" : 49
  }],
  55 : [function(__webpack_require__, context) {
    var Particle = __webpack_require__("../../math/cartesian");
    var _UiIcon = __webpack_require__("../tool");
    var Point = __webpack_require__("../../sector/vehiclepowerups/truck");
    var init = function(obj, target) {
      this.toolInit(target);
      this.powerup = new Point(0, 0, 0, target.scene.track);
      this.p1 = new Particle(0, 0);
      this.p2 = new Particle(0, 0);
      this.options = obj.options;
      this.active = false;
    };
    var self = init.prototype = new _UiIcon;
    self.toolInit = self.init;
    self.toolUpdate = self.update;
    self.powerup = null;
    self.name = "truck";
    self.p1 = null;
    self.p2 = null;
    self.active = false;
    self.draw = function(x) {
      var node = this.mouse.touch;
      var c = node.pos;
      var y = this.camera.zoom;
      var device = this.scene.settings.device;
      if (("desktop" === device || this.active) && (x.globalAlpha = 0.8, this.powerup.draw(c.x, c.y, y, x), x.globalAlpha = 1), this.active === true) {
        var camera = this.scene.screen;
        var o = camera.realToScreen(this.p1.x, "x");
        var undefined = camera.realToScreen(this.p1.y, "y");
        x.globalAlpha = 0.4;
        this.powerup.draw(o, undefined, y, x);
        x.globalAlpha = 1;
      }
    };
    self.press = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p1.x = d.x;
      this.p1.y = d.y;
      this.p2.x = d.x;
      this.p2.y = d.y;
      this.active = true;
    };
    self.hold = function() {
      var node = this.mouse.touch;
      var d = node.real;
      this.p2.x = d.x;
      this.p2.y = d.y;
    };
    self.release = function() {
      var t = (this.scene.screen, this.scene.track);
      var o = new Point(this.p1.x, this.p1.y, this.options.time, t);
      t.addPowerup(o);
      this.active = false;
      this.toolhandler.addActionToTimeline({
        type : "add",
        objects : [o]
      });
    };
    context.exports = init;
  }, {
    "../../math/cartesian" : 14,
    "../../sector/vehiclepowerups/truck" : 33,
    "../tool" : 49
  }],
  56 : [function(require, module) {
    function Renderer(data) {
      this.scene = data;
      this.game = data.game;
      this.settings = data.game.settings;
      this.camera = data.camera;
      this.sectors = {};
      this.sectors.drawSectors = [];
      this.sectors.physicsSectors = [];
      this.totalSectors = [];
      this.powerups = [];
      this.powerupsLookupTable = {};
      this.physicsLines = [];
      this.sceneryLines = [];
      this.targets = [];
      this.allowedVehicles = ["MTB", "BMX"];
      this.canvasPool = new Image(data);
      this.createPowerupCache();
    }
    var TagHourlyStat = require("../math/cartesian");
    var Node = require("../sector/physicsline");
    var Rect = require("../sector/sceneryline");
    var line = require("../math/bresenham");
    var Url = require("../sector/sector");
    var List = require("../../libs/lodash-3.10.1");
    var floor = Math.floor;
    var $ = Math.max;
    var replace = Math.min;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var round = Math.round;
    var Element = require("../sector/powerups/bomb");
    var Promise = require("../sector/powerups/gravity");
    var Directory = require("../sector/powerups/boost");
    var RegExp = require("../sector/powerups/checkpoint");
    var Input = require("../sector/powerups/target");
    var Vector = require("../sector/powerups/slowmo");
    var Container = require("../sector/powerups/antigravity");
    var Error = require("../sector/powerups/teleport");
    var Participant = require("../sector/vehiclepowerups/helicopter");
    var TestCase = require("../sector/vehiclepowerups/truck");
    var Parser = require("../sector/vehiclepowerups/balloon");
    var File = require("../sector/vehiclepowerups/blob");
    var Image = require("../utils/canvaspool");
    var character = {
      LINE : 1,
      POWERUPS : 2
    };
    var self = [];
    Renderer.prototype = {
      defaultLine : {
        p1 : new TagHourlyStat(-40, 50),
        p2 : new TagHourlyStat(40, 50)
      },
      game : null,
      scene : null,
      camera : null,
      canvas : null,
      canvasPool : null,
      settings : null,
      physicsLines : null,
      sceneryLines : null,
      powerups : null,
      targets : null,
      targetCount : 0,
      sectors : null,
      totalSectors : null,
      allowedVehicles : null,
      dirty : false,
      createPowerupCache : function() {
        self.push(new Directory(0, 0, 0, this));
        self.push(new Vector(0, 0, this));
        self.push(new Element(0, 0, this));
        self.push(new Promise(0, 0, 0, this));
        self.push(new RegExp(0, 0, this));
        self.push(new Input(0, 0, this));
        self.push(new Container(0, 0, this));
        self.push(new Error(0, 0, this));
        self.push(new Participant(0, 0, 0, this));
        self.push(new TestCase(0, 0, 0, this));
        self.push(new Parser(0, 0, 0, this));
        self.push(new File(0, 0, 0, this));
      },
      recachePowerups : function(edgeLength) {
        var functor;
        for (functor in self) {
          self[functor].recache(edgeLength);
        }
      },
      read : function(type) {
        var e = type.split("#");
        var fogsArray = e[0].split(",");
        var linesAry = [];
        var nameArgs = [];
        if (e.length > 2) {
          linesAry = e[1].split(",");
          nameArgs = e[2].split(",");
        } else {
          if (e.length > 1) {
            nameArgs = e[1].split(",");
          }
        }
        this.addLines(fogsArray, this.addPhysicsLine);
        this.addLines(linesAry, this.addSceneryLine);
        this.addPowerups(nameArgs);
      },
      addPowerups : function(t) {
        var count = t.length;
        var parts = [];
        var s = ((new Date).getTime(), 0);
        for (; count > s; s++) {
          if (parts = t[s].split(" "), parts.length >= 2) {
            var result = [];
            var n = parts.length;
            var i = 1;
            for (; n > i; i++) {
              var a = parseInt(parts[i], 32);
              result.push(a);
            }
            var name = round(result[0]);
            var options = round(result[1]);
            var p = null;
            switch(parts[0]) {
              case "B":
                p = new Directory(name, options, result[2], this);
                this.addPowerup(p);
                break;
              case "S":
                p = new Vector(name, options, this);
                this.addPowerup(p);
                break;
              case "O":
                p = new Element(name, options, this);
                this.addPowerup(p);
                break;
              case "G":
                p = new Promise(name, options, result[2], this);
                this.addPowerup(p);
                break;
              case "C":
                p = new RegExp(name, options, this);
                this.addPowerup(p);
                break;
              case "T":
                p = new Input(name, options, this);
                this.addTarget(p);
                this.addPowerup(p);
                break;
              case "A":
                p = new Container(name, options, this);
                this.addPowerup(p);
                break;
              case "V":
                var testMeshes = result[2];
                var desc = result[3];
                var comment = this.settings.vehiclePowerup.minTime;
                var x = this.settings.vehiclePowerup.maxTime;
                desc = desc || comment;
                desc = replace(desc, x);
                desc = $(desc, comment);
                switch(testMeshes) {
                  case 1:
                    p = new Participant(name, options, desc, this);
                    break;
                  case 2:
                    p = new TestCase(name, options, desc, this);
                    break;
                  case 3:
                    p = new Parser(name, options, desc, this);
                    break;
                  case 4:
                    p = new File(name, options, desc, this);
                    break;
                  default:
                    continue;
                }this.addPowerup(p);
                break;
              case "W":
                var data = result[0];
                var index = result[1];
                var buffer = result[2];
                var msg = result[3];
                var n = new Error(data, index, this);
                var test = new Error(buffer, msg, this);
                n.addOtherPortalRef(test);
                test.addOtherPortalRef(n);
                this.addPowerup(n);
                this.addPowerup(test);
            }
          }
        }
      },
      addTarget : function(target) {
        this.dirty = true;
        this.targetCount++;
        this.targets.push(target);
      },
      addPowerup : function(x) {
        var translate = this.sectors.drawSectors;
        var isCreditCard_1 = this.sectors.physicsSectors;
        var p = x.x;
        var n = x.y;
        var banner_hidden = this.settings.drawSectorSize;
        var banned_words = this.settings.physicsSectorSize;
        this.addRef(p, n, x, character.POWERUPS, isCreditCard_1, banned_words);
        var a = this.addRef(p, n, x, character.POWERUPS, translate, banner_hidden);
        return a !== false && this.totalSectors.push(a), null !== x && (this.powerups.push(x), x.id && (this.powerupsLookupTable[x.id] = x)), x;
      },
      addLines : function(lines, callback) {
        var count = lines.length;
        var mid = 0;
        for (; count > mid; mid++) {
          var buf = lines[mid].split(" ");
          var l = buf.length;
          if (l > 3) {
            var i = 0;
            for (; l - 2 > i; i = i + 2) {
              var a = parseInt(buf[i], 32);
              var c = parseInt(buf[i + 1], 32);
              var b = parseInt(buf[i + 2], 32);
              var dg = parseInt(buf[i + 3], 32);
              var res = a + c + b + dg;
              if (!isNaN(res)) {
                callback.call(this, a, c, b, dg);
              }
            }
          }
        }
      },
      addPhysicsLine : function(t, x, y, w) {
        t = round(t);
        x = round(x);
        y = round(y);
        w = round(w);
        var base = y - t;
        var height = w - x;
        var sqrt8 = sqrt(pow(base, 2) + pow(height, 2));
        if (sqrt8 >= 2) {
          var r = new Node(t, x, y, w);
          this.addPhysicsLineToTrack(r);
        }
        return r;
      },
      addPhysicsLineToTrack : function(node) {
        var height = this.settings.drawSectorSize;
        var p1 = node.p1;
        var p2 = node.p2;
        var x = p1.x;
        var y1 = p1.y;
        var x2 = p2.x;
        var y2 = p2.y;
        var g = line(x, y1, x2, y2, height);
        var detail = this.sectors.drawSectors;
        var length = g.length;
        var i = 0;
        for (; length > i; i = i + 2) {
          var n = g[i];
          var f = g[i + 1];
          var e = this.addRef(n, f, node, character.LINE, detail, height);
          if (e !== false) {
            this.totalSectors.push(e);
          }
        }
        var s = this.settings.physicsSectorSize;
        var m = line(x, y1, x2, y2, s);
        var isCreditCard_1 = this.sectors.physicsSectors;
        var l = m.length;
        i = 0;
        for (; l > i; i = i + 2) {
          n = m[i];
          f = m[i + 1];
          this.addRef(n, f, node, character.LINE, isCreditCard_1, s);
        }
        return this.physicsLines.push(node), node;
      },
      addSceneryLine : function(i, x, y, w) {
        i = round(i);
        x = round(x);
        y = round(y);
        w = round(w);
        var base = y - i;
        var height = w - x;
        var sqrt8 = sqrt(pow(base, 2) + pow(height, 2));
        if (sqrt8 >= 2) {
          var rect = new Rect(i, x, y, w);
          this.addSceneryLineToTrack(rect);
        }
        return rect;
      },
      addSceneryLineToTrack : function(node) {
        var height = this.settings.drawSectorSize;
        var p1 = node.p1;
        var p2 = node.p2;
        var x = p1.x;
        var y = p1.y;
        var x2 = p2.x;
        var y2 = p2.y;
        var g = line(x, y, x2, y2, height);
        var detail = this.sectors.drawSectors;
        var l = g.length;
        var i = 0;
        for (; l > i; i = i + 2) {
          var p = g[i];
          var n = g[i + 1];
          var e = this.addRef(p, n, node, character.LINE, detail, height);
          if (e !== false) {
            this.totalSectors.push(e);
          }
        }
        return this.sceneryLines.push(node), node;
      },
      addRef : function(e, r, s, name, x, n) {
        var url = floor(e / n);
        var i = floor(r / n);
        var eo1 = false;
        if (void 0 === x[url] && (x[url] = []), void 0 === x[url][i]) {
          var u = new Url(url, i, this);
          x[url][i] = u;
          eo1 = u;
        }
        switch(name) {
          case character.LINE:
            x[url][i].addLine(s);
            s.addSectorReference(x[url][i]);
            break;
          case character.POWERUPS:
            x[url][i].addPowerup(s);
            s.addSectorReference(x[url][i]);
        }
        return this.dirty = true, eo1;
      },
      cleanTrack : function() {
        this.cleanLines();
        this.cleanPowerups();
      },
      cleanLines : function() {
        var commonBlockProps = this.physicsLines;
        var result = this.sceneryLines;
        var len = commonBlockProps.length;
        var rows = result.length;
        var i = len - 1;
        for (; i >= 0; i--) {
          if (commonBlockProps[i].remove) {
            commonBlockProps.splice(i, 1);
          }
        }
        var j = rows - 1;
        for (; j >= 0; j--) {
          if (result[j].remove) {
            result.splice(j, 1);
          }
        }
      },
      cleanPowerups : function() {
        var controls = this.powerups;
        var _tooltips = this.targets;
        var l = this.targets.length;
        var distance = controls.length;
        var id = (this.powerupsLookupTable, distance - 1);
        for (; id >= 0; id--) {
          if (controls[id].remove) {
            controls.splice(id, 1);
          }
        }
        var i = l - 1;
        for (; i >= 0; i--) {
          if (_tooltips[i].remove) {
            _tooltips.splice(i, 1);
          }
        }
        this.targetCount = _tooltips.length;
      },
      updatePowerupState : function(value) {
        var e = value._powerupsConsumed;
        this.resetPowerups();
        var targets = e.targets;
        var psNode = e.checkpoints;
        var backwardNode = e.misc;
        this.setPowerupStates(targets);
        this.setPowerupStates(psNode);
        this.setPowerupStates(backwardNode);
      },
      setPowerupStates : function(e) {
        var msgObj = this.powerupsLookupTable;
        var t;
        for (t in e) {
          var target = e[t];
          var params = msgObj[target];
          if (params.remove && params.id) {
            delete msgObj[target];
            delete e[target];
          }
          params.hit = true;
          params.sector.powerupCanvasDrawn = false;
        }
      },
      getCode : function() {
        this.cleanTrack();
        var reactions = this.powerups;
        var stdout = this.physicsLines;
        var delta = this.sceneryLines;
        var result = "";
        var l = stdout.length;
        var deltaSize = delta.length;
        var count = reactions.length;
        if (l > 0) {
          var i;
          for (i in stdout) {
            var chunk = stdout[i];
            if (!chunk.recorded) {
              result = result + (chunk.p1.x.toString(32) + " " + chunk.p1.y.toString(32) + chunk.getCode(this) + ",");
            }
          }
          result = result.slice(0, -1);
          for (i in stdout) {
            stdout[i].recorded = false;
          }
        }
        if (result = result + "#", deltaSize > 0) {
          var i;
          for (i in delta) {
            chunk = delta[i];
            if (!chunk.recorded) {
              result = result + (chunk.p1.x.toString(32) + " " + chunk.p1.y.toString(32) + chunk.getCode(this) + ",");
            }
          }
          result = result.slice(0, -1);
          for (i in delta) {
            delta[i].recorded = false;
          }
        }
        if (result = result + "#", count > 0) {
          var reaction_id;
          for (reaction_id in reactions) {
            var reaction = reactions[reaction_id];
            var bondType = reaction.getCode();
            if (bondType) {
              result = result + (bondType + ",");
            }
          }
          result = result.slice(0, -1);
        }
        return result;
      },
      resetPowerups : function() {
        var targets = this.powerups;
        var i;
        for (i in targets) {
          var target = targets[i];
          if (target.hit && !target.remove) {
            target.hit = false;
            target.sector.powerupCanvasDrawn = false;
          }
        }
      },
      addDefaultLine : function() {
        var input = this.defaultLine;
        var p1 = input.p1;
        var p2 = input.p2;
        this.addPhysicsLine(p1.x, p1.y, p2.x, p2.y);
      },
      erase : function(x, i, id) {
        this.dirty = true;
        var scope = x.x - i;
        var n = x.y - i;
        var text = x.x + i;
        var e = x.y + i;
        var height = $(scope, text);
        var index = replace(scope, text);
        var k = $(n, e);
        var f = replace(n, e);
        var width = this.settings.drawSectorSize;
        var mid = floor(height / width);
        var metersPerLine = floor(index / width);
        var randomLineNumber = floor(k / width);
        var y = floor(f / width);
        var MODULE_NOTICES = this.sectors.drawSectors;
        var data = [];
        var moduleSlug = metersPerLine;
        for (; mid >= moduleSlug; moduleSlug++) {
          var type = y;
          for (; randomLineNumber >= type; type++) {
            if (MODULE_NOTICES[moduleSlug] && MODULE_NOTICES[moduleSlug][type]) {
              data.push(MODULE_NOTICES[moduleSlug][type].erase(x, i, id));
            }
          }
        }
        return List.flatten(data);
      },
      drawAndCache : function() {
        var t = performance.now();
        var namespaceSplit = this.totalSectors;
        var countRep = namespaceSplit.length;
        var i = 0;
        for (; countRep > i; i++) {
          var n = namespaceSplit[i];
          !function(scale) {
            setTimeout(function() {
              scale.draw();
              scale.cacheAsImage();
            }, 250 * i);
          }(n);
        }
        var q = performance.now();
        console.log("Track :: Time to draw entire track : " + (q - t) + "ms");
      },
      undraw : function() {
        var yscales = (performance.now(), this.totalSectors);
        var scaleid;
        for (scaleid in yscales) {
          var yscale = yscales[scaleid];
          if (yscale.drawn) {
            yscale.clear(true);
          }
        }
        var zoom = this.camera.zoom;
        this.recachePowerups(Math.max(zoom, 1));
        this.canvasPool.update();
      },
      collide : function(a) {
        var modV2 = this.settings.physicsSectorSize;
        var i = Math.floor(a.pos.x / modV2 - 0.5);
        var j = Math.floor(a.pos.y / modV2 - 0.5);
        var matrix = this.sectors.physicsSectors;
        if (matrix[i] && matrix[i][j]) {
          matrix[i][j].resetCollided();
        }
        if (matrix[i + 1] && matrix[i + 1][j]) {
          matrix[i + 1][j].resetCollided();
        }
        if (matrix[i + 1] && matrix[i + 1][j + 1]) {
          matrix[i + 1][j + 1].resetCollided();
        }
        if (matrix[i] && matrix[i][j + 1]) {
          matrix[i][j + 1].resetCollided();
        }
        if (matrix[i] && matrix[i][j]) {
          matrix[i][j].collide(a);
        }
        if (matrix[i + 1] && matrix[i + 1][j]) {
          matrix[i + 1][j].collide(a);
        }
        if (matrix[i + 1] && matrix[i + 1][j + 1]) {
          matrix[i + 1][j + 1].collide(a);
        }
        if (matrix[i] && matrix[i][j + 1]) {
          matrix[i][j + 1].collide(a);
        }
      },
      getDrawSector : function(delta, index) {
        var width = this.settings.drawSectorSize;
        var mid = floor(delta / width);
        var m_0 = floor(index / width);
        var MPermMove = this.sectors.drawSectors;
        var flipx = false;
        return "undefined" != typeof MPermMove[mid] && "undefined" != typeof MPermMove[mid][m_0] && (flipx = MPermMove[mid][m_0]), flipx;
      },
      draw : function() {
        var self = this.scene;
        var camera = self.camera;
        var canvas = self.screen;
        var ctx = self.game.canvas.getContext("2d");
        var scale = camera.zoom;
        var pos = camera.position;
        var currentCenter = self.screen.center;
        var width = this.settings.drawSectorSize * scale;
        var radius = pos.x * scale / width;
        var windowHeight = pos.y * scale / width;
        var widthProportions = canvas.width / width;
        var propsWidth = canvas.height / width;
        var scrollTop = propsWidth / 2;
        var w = widthProportions / 2;
        var maxX = radius - w - 1;
        var levelBegin = windowHeight - scrollTop - 1;
        var x2 = radius + w;
        var t = windowHeight + scrollTop;
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.oImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        var y = radius * width - currentCenter.x;
        var h = windowHeight * width - currentCenter.y;
        var a = this.totalSectors;
        var x = a.length;
        var key = 0;
        for (; x > key; key++) {
          var me = a[key];
          var d = me.row;
          var x = me.column;
          if (me.dirty && me.cleanSector(), x >= maxX && x2 >= x && d >= levelBegin && t >= d) {
            if (me.drawn === false) {
              me.draw();
            }
            if (me.hasPowerups) {
              if (!me.powerupCanvasDrawn) {
                me.cachePowerupSector();
              }
            }
            var scrollX = x * width - y;
            var top = d * width - h;
            if (scrollX = 0 | scrollX, top = 0 | top, ctx.drawImage(me.canvas, scrollX, top, width, width), me.hasPowerups && me.powerupCanvasDrawn) {
              var w = me.powerupCanvasOffset * scale;
              ctx.drawImage(me.powerupCanvas, scrollX - w / 2, top - w / 2, width + w, width + w);
            }
          } else {
            if (me.drawn) {
              me.clear();
            }
          }
        }
      },
      closeSectors : function() {
        var conns = this.totalSectors;
        var l = conns.length;
        var i = 0;
        for (; l > i; i++) {
          conns[i].close();
        }
      },
      close : function() {
        this.scene = null;
        this.closeSectors();
        this.totalSectors = null;
        this.canvasPool = null;
        this.sectors = null;
        this.physicsLines = null;
        this.sceneryLines = null;
        this.powerups = null;
        this.camera = null;
      }
    };
    module.exports = Renderer;
  }, {
    "../../libs/lodash-3.10.1" : 90,
    "../math/bresenham" : 13,
    "../math/cartesian" : 14,
    "../sector/physicsline" : 18,
    "../sector/powerups/antigravity" : 20,
    "../sector/powerups/bomb" : 21,
    "../sector/powerups/boost" : 22,
    "../sector/powerups/checkpoint" : 23,
    "../sector/powerups/gravity" : 24,
    "../sector/powerups/slowmo" : 25,
    "../sector/powerups/target" : 26,
    "../sector/powerups/teleport" : 27,
    "../sector/sceneryline" : 28,
    "../sector/sector" : 29,
    "../sector/vehiclepowerups/balloon" : 30,
    "../sector/vehiclepowerups/blob" : 31,
    "../sector/vehiclepowerups/helicopter" : 32,
    "../sector/vehiclepowerups/truck" : 33,
    "../utils/canvaspool" : 58
  }],
  57 : [function(canCreateDiscussions, module) {
    function template(data) {
      this.scene = data;
      this.settings = data.settings;
      this.build_interface();
    }
    var _this = template.prototype;
    _this.scene = null;
    _this.container = null;
    _this.cached = false;
    _this.build_interface = function() {
      this.sprite_sheet = this.create_sprite_sheet();
      var referenceWidth = this.scene.game.pixelRatio;
      var block = new createjs.Container;
      var i = "helsinki";
      var options = this.settings.campaignData;
      var data = options.goals;
      var label = data.third;
      var o = new createjs.Container;
      var a = this.get_sprite("bronze_medal");
      label = new createjs.Text(label, "30px " + i, "#000000");
      var msg = data.second;
      var that = new createjs.Container;
      var spec = this.get_sprite("silver_medal");
      msg = new createjs.Text(msg, "30px " + i, "#000000");
      var item = data.first;
      var p = new createjs.Container;
      var d = this.get_sprite("gold_medal");
      item = new createjs.Text(item, "30px " + i, "#000000");
      var scale = referenceWidth / 2.5;
      if ("phone" === this.settings.controls) {
        scale = referenceWidth / 2.5;
      }
      a.y = 7;
      a.x = 16;
      label.x = 69;
      label.y = 14;
      spec.y = 7;
      spec.x = 175;
      msg.x = 229;
      msg.y = 14;
      d.y = 7;
      d.x = 350;
      item.y = 14;
      item.x = 400;
      o.addChild(a);
      o.addChild(label);
      that.addChild(spec);
      that.addChild(msg);
      p.addChild(d);
      p.addChild(item);
      o.alpha = 0.4;
      that.alpha = 0.4;
      p.alpha = 0.4;
      block.addChild(o);
      block.addChild(that);
      block.addChild(p);
      block.scaleX = block.scaleY = scale;
      block.y = 80 * scale;
      block.x = 0;
      this.bronze_container = o;
      this.silver_container = that;
      this.gold_container = p;
      this.container = block;
      this.scene.game.stage.addChild(block);
      this.update_state();
    };
    _this.update_state = function() {
      var file = this.settings.campaignData;
      var ttr = file.user;
      switch(ttr.has_goal) {
        case 1:
        case "first":
          this.gold_container.alpha = 1;
        case "second":
        case 2:
          this.silver_container.alpha = 1;
        case "third":
        case 3:
          this.bronze_container.alpha = 1;
        case 0:
      }
    };
    _this.center_container = function() {
      var wh = this.scene.screen;
      var c = this.container;
      var foodIconDefinition = c.getBounds();
      var ratio = this.scene.game.pixelRatio;
      c.x = wh.width / 2 - foodIconDefinition.width / 2 * c.scaleY;
      c.y = 40 * ratio;
    };
    _this.update = function() {
      if (this.settings.mobile) {
        this.center_container();
      }
      this.update_state();
    };
    _this.create_sprite_sheet = function() {
      var FileSchema = this.scene.assets.getResult("campaign_icons");
      var data = {
        images : [FileSchema],
        frames : [[548, 68, 44, 44], [2, 68, 452, 56], [502, 68, 44, 44], [2, 2, 588, 64], [456, 68, 44, 44]],
        animations : {
          bronze_medal : [0],
          center_panel : [1],
          silver_medal : [2],
          left_panel : [3],
          gold_medal : [4]
        }
      };
      var gifObj = new createjs.SpriteSheet(data);
      return gifObj;
    };
    _this.get_sprite = function(animation) {
      var image = this.sprite_sheet;
      var sprite = new createjs.Sprite(image, animation);
      return sprite.stop(), sprite;
    };
    module.exports = template;
  }, {}],
  58 : [function(canCreateDiscussions, module) {
    function Game(options) {
      this.options = options;
      this.canvasPool = [];
      if (options.screen) {
        this.setToScreen = true;
        this.update();
      }
      if (options.cap) {
        this.setToScreen = false;
        this.poolCap = options.cap;
      }
    }
    var floor = Math.floor;
    var ceil = Math.ceil;
    Game.prototype = {
      canvasPool : null,
      poolCap : 5e3,
      setToScreen : true,
      options : null,
      update : function() {
        if (this.setToScreen) {
          this.getPoolCapFromScreen();
          this.cleanPool();
        }
      },
      getPoolCapFromScreen : function() {
        var options = this.options;
        var o = options.settings;
        var screen = options.screen;
        var x = (this.options.width, this.options.height, screen.width);
        var length = screen.height;
        var camera = options.camera;
        var zoom = camera.zoom;
        var width = floor(o.drawSectorSize * zoom);
        var i = ceil(x / width);
        var r = ceil(length / width);
        this.poolCap = i * r + i + r;
      },
      getCanvas : function() {
        var plant0 = this.canvasPool.pop();
        return null == plant0 && (plant0 = document.createElement("canvas")), plant0;
      },
      releaseCanvas : function(canvas) {
        if (this.canvasPool.length < this.poolCap) {
          this.canvasPool.push(canvas);
        }
      },
      cleanPool : function() {
        if (this.canvasPool.length > this.poolCap) {
          this.canvasPool = this.canvasPool.slice(0, this.poolCap + 1);
        }
      }
    };
    module.exports = Game;
  }, {}],
  59 : [function(canCreateDiscussions, module) {
    function repeat(n) {
      n = parseInt(n, 10);
      var m = floor(n / 6e4);
      var value = (n - 6e4 * m) / 1e3;
      return value = value.toFixed(2), 10 > m && (m = m), 10 > value && (value = "0" + value), m + ":" + value;
    }
    var floor = Math.floor;
    module.exports = repeat;
  }, {}],
  60 : [function(getBaseUri, module) {
    function DataSource(data) {
      this.scene = data;
      this.tickDownButtons = {};
      this.previousTickDownButtons = {};
      this.downButtons = {};
      this.keymap = {};
      this.records = {};
      this.numberOfKeysDown = 0;
      this.tickNumberOfKeysDown = 0;
    }
    var path = getBaseUri("../../libs/lodash-3.10.1");
    DataSource.prototype = {
      tickDownButtons : null,
      previousTickDownButtons : null,
      downButtons : null,
      paused : false,
      keymap : null,
      records : null,
      keysToRecord : null,
      keysToPlay : null,
      recording : false,
      playback : null,
      numberOfKeysDown : 0,
      tickNumberOfKeysDown : 0,
      replaying : false,
      listen : function() {
        document.onkeydown = this.handleButtonDown.bind(this);
        document.onkeyup = this.handleButtonUp.bind(this);
      },
      unlisten : function() {
        this.downButtons = {};
        document.onkeydown = function() {
        };
        document.onkeyup = function() {
        };
      },
      pause : function() {
        this.paused = true;
      },
      unpause : function() {
        this.paused = false;
      },
      recordKeys : function(canCreateDiscussions) {
        this.keysToRecord = canCreateDiscussions;
        this.recording = true;
      },
      loadPlayback : function(index, eachIndex) {
        this.keysToPlay = eachIndex;
        this.playback = index;
        this.replaying = true;
      },
      setKeyMap : function(array) {
        var keys = {};
        var i;
        for (i in array) {
          if (array[i] instanceof Array) {
            var key;
            for (key in array[i]) {
              keys[array[i][key]] = i;
            }
          } else {
            keys[array[i]] = i;
          }
        }
        this.keymap = keys;
      },
      handleButtonDown : function(event) {
        var code = this.getInternalCode(event.keyCode);
        if ("string" == typeof code) {
          event.preventDefault();
        }
        this.setButtonDown(code);
      },
      handleButtonUp : function(event) {
        var code = this.getInternalCode(event.keyCode);
        if ("string" == typeof code) {
          event.preventDefault();
        }
        this.setButtonUp(code);
      },
      getInternalCode : function(name) {
        var attrToProp = this.keymap;
        return attrToProp[name] || name;
      },
      setButtonsDown : function(array) {
        var i = 0;
        var length = array.length;
        for (; length > i; i++) {
          this.setButtonDown(array[i]);
        }
      },
      setButtonUp : function(code) {
        if (this.downButtons[code]) {
          if (this.onButtonUp) {
            this.onButtonUp(code);
          }
          this.downButtons[code] = false;
          this.numberOfKeysDown--;
        }
      },
      setButtonDown : function(code, f) {
        if (!this.downButtons[code]) {
          if (this.onButtonDown) {
            this.onButtonDown(code);
          }
          this.downButtons[code] = f ? f : true;
          this.numberOfKeysDown++;
        }
      },
      isButtonDown : function(key) {
        var e = false;
        var i = this.tickDownButtons[key];
        return (i > 0 || 1 == i) && (e = true), e;
      },
      getButtonDownOccurances : function(key) {
        var entryToSend = 0;
        if (this.isButtonDown(key)) {
          entryToSend = 1;
          var entry = this.tickDownButtons[key];
          if (entry !== true) {
            entryToSend = entry;
          }
        }
        return entryToSend;
      },
      getDownButtons : function() {
        var btns = [];
        var move;
        for (move in this.tickDownButtons) {
          if (this.tickDownButtons[move]) {
            btns.push(move);
          }
        }
        return btns;
      },
      reset : function(noalert) {
        if (this.replaying || noalert) {
          this.downButtons = {};
        }
        this.tickDownButtons = {};
        this.previousTickDownButtons = {};
        this.records = {};
      },
      update : function() {
        this.scene;
        if (this.replaying) {
          this.updatePlayback();
        }
        this.previousTickDownButtons = path.merge({}, this.tickDownButtons);
        this.tickDownButtons = path.merge({}, this.downButtons);
        this.tickNumberOfKeysDown = this.numberOfKeysDown;
        if (this.recording) {
          this.updateRecording();
        }
      },
      areKeysDown : function() {
        var n;
        for (n in this.downButtons) {
          if (this.downButtons[n] === true) {
            return true;
          }
        }
        return false;
      },
      updatePlayback : function() {
        var indices = this.keysToPlay;
        var res = this.playback;
        var id = this.scene.ticks;
        var i;
        for (i in indices) {
          var code = indices[i];
          var path = code + "_up";
          var dataType = code + "_down";
          if ("undefined" != typeof res[dataType] && "undefined" != typeof res[dataType][id]) {
            var smoothFunc = res[dataType][id];
            this.setButtonDown(code, smoothFunc);
          }
          if ("undefined" != typeof res[path] && "undefined" != typeof res[path][id]) {
            this.setButtonUp(code);
          }
        }
      },
      updateRecording : function() {
        var s = this.scene.ticks;
        var result = this.records;
        var propertiesOrder = (this.keymap, this.keysToRecord);
        var pods = this.tickDownButtons;
        var edges = this.previousTickDownButtons;
        var i;
        for (i in propertiesOrder) {
          var key = propertiesOrder[i];
          if ("undefined" != typeof pods[key]) {
            var answer = pods[key];
            var n = false;
            if ("undefined" != typeof edges[key] && (n = edges[key]), answer !== n) {
              var k = key + "_up";
              var i = key + "_down";
              var j = k;
              if (answer) {
                j = i;
              }
              if (!result[j]) {
                result[j] = [];
              }
              if (!answer) {
                if (result[i] && -1 !== result[i].indexOf(s)) {
                  s = s + 1;
                }
              }
              result[j].push(s);
            }
          }
        }
      },
      buttonWasRecentlyDown : function(animation) {
        var result = this.records;
        if (this.replaying) {
          result = this.playback;
        }
        var name = animation + "_down";
        var s = false;
        if (result[name]) {
          var meshes = this.scene.ticks;
          var chars = meshes;
          var e = result[name];
          var a = -1;
          a = this.replaying ? "undefined" != typeof e[chars] : e.indexOf(chars);
          if (-1 !== a) {
            s = true;
          }
        }
        return s;
      },
      getReplayString : function() {
        return JSON.stringify(this.records);
      },
      encodeReplayString : function(importedPages) {
        var o = this.scene.settings;
        var markup_classes = {
          version : o.replayVersion
        };
        var importedPageName;
        for (importedPageName in importedPages) {
          var list = importedPages[importedPageName];
          markup_classes[importedPageName] = "";
          var id;
          for (id in list) {
            var dd = list[id];
            markup_classes[importedPageName] += dd.toString(32) + " ";
          }
        }
        return markup_classes;
      },
      close : function() {
        this.unlisten();
        this.handleButtonUp = null;
        this.handleButtonDown = null;
        this.onButtonDown = null;
        this.onButtonUp = null;
        this.scene = null;
        this.tickDownButtons = null;
        this.downButtons = null;
        this.keymap = null;
        this.records = null;
        this.keysToRecord = null;
      }
    };
    module.exports = DataSource;
  }, {
    "../../libs/lodash-3.10.1" : 90
  }],
  61 : [function(saveNotifs, module) {
    var Scene = (saveNotifs("../math/cartesian"), Math.round, function(scene) {
      this.scene = scene;
      this.screen = scene.screen;
      this.context = scene.game.canvas.getContext("2d");
      this.clockwise = false;
      this.settings = {
        radius : 10,
        color : "#1884cf"
      };
    });
    Scene.prototype = {
      scene : null,
      clockwise : false,
      context : null,
      screen : null,
      pixelRatio : 1,
      draw : function() {
        var ctx = this.context;
        var available = this.screen;
        var options = this.settings;
        var scale = this.scene.game.pixelRatio;
        var radius = options.radius;
        var isArray = this.clockwise;
        var item = this.scene.game.tickCount % 25 / 25 * 2 * Math.PI;
        if (0 === item) {
          if (this.clockwise) {
            item = 2 * Math.PI;
          }
          this.clockwise = !this.clockwise;
        }
        var start = isArray ? 0 : item;
        var a = isArray ? item : 0;
        var indicatorX = available.width - 25 * scale;
        var y = available.height - 25 * scale;
        var fill = false;
        ctx.beginPath();
        ctx.arc(indicatorX, y, radius * scale, start, a, fill);
        ctx.lineWidth = 3 * scale;
        ctx.strokeStyle = options.color;
        ctx.stroke();
      }
    };
    module.exports = Scene;
  }, {
    "../math/cartesian" : 14
  }],
  62 : [function(canCreateDiscussions, module) {
    function render(data) {
      this.scene = data;
      this.message = false;
      this.timeout = false;
      this.color = "#000";
    }
    var ctx = render.prototype;
    ctx.message = null;
    ctx.timeout = null;
    ctx.draw = function() {
      var text = this.message;
      var prevTimeout = this.timeout;
      var color = this.color;
      var centerLineColor = this.outline;
      if (prevTimeout !== false && 0 >= prevTimeout && (text = false), this.scene.state.paused && (color = false, centerLineColor = false, text = this.scene.settings.mobile ? "Paused" : "Paused - Press Spacebar to Continue"), color === false && (color = "#333333"), text) {
        var game = this.scene.game;
        var $scope = this.scene;
        var size = game.pixelRatio;
        var ctx = game.canvas.getContext("2d");
        var x = $scope.screen.center.x;
        var y = 100;
        var ss = $scope.settings;
        if ("phone" === ss.controls) {
          y = 80;
        }
        ctx.save();
        ctx.fillStyle = color;
        ctx.lineWidth = 4 * (size / 2);
        ctx.font = 12 * size + "pt helsinki";
        ctx.textAlign = "center";
        if (centerLineColor) {
          ctx.strokeStyle = centerLineColor;
          ctx.strokeText(text, x, y * size);
          ctx.strokeStyle = "#000";
        }
        ctx.fillText(text, x, y * size);
        ctx.restore();
      }
    };
    ctx.show = function(message, timeout, value, color) {
      this.message = message;
      this.timeout = timeout;
      this.color = value;
      this.outline = color;
    };
    ctx.hide = function() {
      this.message = false;
      this.color = false;
      this.outline = false;
    };
    ctx.update = function() {
      if (this.timeout !== false) {
        this.timeout--;
      }
    };
    module.exports = render;
  }, {}],
  63 : [function(require, context) {
    var Point = require("../math/cartesian");
    var Y = require("../../libs/lodash-3.10.1");
    var EventEmitter = require("events").EventEmitter;
    var round = Math.round;
    var init = function(data) {
      this.scene = data;
      this.enabled = true;
      this.touch = this.getTouchObject();
      this.touch.old = this.getTouchObject();
      this.secondaryTouch = this.getTouchObject();
      this.secondaryTouch.old = this.getTouchObject();
      this.initAnalytics();
      this.bindToMouseEvents();
      this.updateCallback = false;
    };
    var _this = init.prototype = new EventEmitter;
    _this.scene = null;
    _this.touch = null;
    _this.touches = [];
    _this.wheel = false;
    _this.mousewheel = false;
    _this.mouseMoveListener = null;
    _this.mouseUpListener = null;
    _this.mouseDownListener = null;
    _this.throttledMouseWheel = null;
    _this.analytics = null;
    _this.contextMenuHandler = function(e) {
      return e.stopPropagation(), e.preventDefault(), false;
    };
    _this.initAnalytics = function() {
      this.analytics = {
        clicks : 0
      };
    };
    _this.getTouchObject = function() {
      var data = {
        id : null,
        down : false,
        press : false,
        release : false,
        pos : new Point(0, 0),
        real : new Point(0, 0),
        type : 1
      };
      return data;
    };
    _this.bindToMouseEvents = function() {
      var stage = this.scene.game.stage;
      var canvas = this.scene.game.canvas;
      var onMove = this.onMouseMove.bind(this);
      var resizeHandler = this.onMouseDown.bind(this);
      var bound = this.onMouseUp.bind(this);
      stage.addEventListener("stagemousemove", onMove);
      stage.addEventListener("stagemousedown", resizeHandler);
      stage.addEventListener("stagemouseup", bound);
      this.mouseMoveListener = onMove;
      this.mouseDownListener = resizeHandler;
      this.mouseUpListener = bound;
      var boundOnMouseWheel = Y.throttle(this.onMouseWheel, 0);
      canvas.addEventListener("mousewheel", boundOnMouseWheel.bind(this));
      canvas.addEventListener("wheel", boundOnMouseWheel.bind(this));
      canvas.addEventListener("DOMMouseScroll", boundOnMouseWheel.bind(this));
      this.mouseWheelListener = boundOnMouseWheel;
    };
    _this.onMouseDown = function(e) {
      this.analytics.clicks++;
      if (2 === e.nativeEvent.button) {
        if (this.secondaryTouch.down === false) {
          this.updatePosition(e, this.secondaryTouch);
          this.secondaryTouch.down = true;
        }
      } else {
        if (this.touch.down === false) {
          this.updatePosition(e, this.touch);
          this.touch.down = true;
        }
      }
    };
    _this.disableContextMenu = function() {
      this.scene.game.canvas.oncontextmenu = function() {
        return false;
      };
    };
    _this.onMouseUp = function(e) {
      if (2 === e.nativeEvent.button) {
        if (this.secondaryTouch.down === true) {
          this.updatePosition(e, this.secondaryTouch);
          this.secondaryTouch.down = false;
        }
      } else {
        if (this.touch.down === true) {
          this.updatePosition(e, this.touch);
          this.touch.down = false;
        }
      }
    };
    _this.updatePosition = function(event, e) {
      e.id = event.pointerID;
      e.type = event.nativeEvent.button;
      var _this = e.pos;
      _this.x = event.stageX;
      _this.y = event.stageY;
      this.updateRealPosition(e);
    };
    _this.updateRealPosition = function(item) {
      var b = (item.old, item.pos);
      var options = item.real;
      var game = (item.down, this.scene);
      var s = game.screen;
      var camera = game.camera;
      var c = s.center;
      var pos = camera.position;
      var r = (b.x - c.x) / camera.zoom + pos.x;
      var arg = (b.y - c.y) / camera.zoom + pos.y;
      options.x = round(r);
      options.y = round(arg);
      var app = this.scene.settings;
      if (this.scene.toolHandler.options.grid) {
        var s = app.toolHandler.gridSize;
        options.x = round(options.x / s) * s;
        options.y = round(options.y / s) * s;
      }
      this.updateCallback;
    };
    _this.onMouseWheel = function(e) {
      e = window.event || e;
      e.preventDefault();
      e.stopPropagation();
      var event = Math.max(-1, Math.min(1, e.deltaY || -e.detail));
      return 0 == event && (event = Math.max(-1, Math.min(1, e.deltaX || -e.detail))), this.wheel = -event, false;
    };
    _this.onMouseMove = function(e) {
      this.updatePosition(e, this.touch);
      this.updatePosition(e, this.secondaryTouch);
    };
    _this.update = function() {
      if (this.enabled) {
        this.updateTouch(this.touch);
        this.updateTouch(this.secondaryTouch);
        this.updateWheel();
      }
    };
    _this.updateTouch = function(data) {
      var self = data.old;
      var position = data.pos;
      var b = data.real;
      var payload = data.down;
      self.pos.x = position.x;
      self.pos.y = position.y;
      self.real.x = b.x;
      self.real.y = b.y;
      if (!self.down && payload) {
        data.press = true;
      }
      if (self.down && !payload) {
        data.release = true;
      }
      if (self.press) {
        data.press = false;
      }
      if (self.release) {
        data.release = false;
      }
      this.updateRealPosition(data);
      self.down = data.down;
      self.press = data.press;
      self.release = data.release;
    };
    _this.updateWheel = function() {
      this.mousewheel = this.wheel;
      this.wheel = false;
    };
    _this.close = function() {
      var self = this.scene.game.stage;
      var el = this.scene.game.canvas;
      self.removeAllEventListeners();
      el.removeEventListener("mousewheel", this.mouseWheelListener);
      el.removeEventListener("DOMMouseScroll", this.mouseWheelListener);
      this.touches = null;
      this.touch = null;
      this.scene = null;
      this.wheel = null;
      this.mouseMoveListener = null;
      this.mouseDownListener = null;
      this.mouseUpListener = null;
    };
    context.exports = init;
  }, {
    "../../libs/lodash-3.10.1" : 90,
    "../math/cartesian" : 14,
    events : 1
  }],
  64 : [function(canCreateDiscussions, module) {
    function Slider() {
      this.start = null;
      this.end = null;
      this.verticies = [];
    }
    Slider.prototype = {
      start : null,
      end : null,
      verticies : [],
      build : function(inputs) {
        var input = inputs.pop();
        this.start = input.p1;
        this.end = input.p2;
        this.verticies.push(input);
        var length = inputs.length;
        var i = length - 1;
        for (; i >= 0; i--) {
          var input = inputs[i];
          var p1 = input.p1;
          var p2 = input.p2;
          if (this.start.x === p2.x && this.start.y === p2.y) {
            this.verticies.unshift(input);
            this.start = input.p1;
            inputs.splice(i, 1);
          } else {
            if (this.end.x === p1.x && this.end.y === p1.y) {
              this.verticies.push(input);
              this.end = input.p2;
              inputs.splice(i, 1);
            }
          }
        }
      }
    };
    module.exports = Slider;
  }, {}],
  65 : [function(_$$mdAnimate_, module) {
    function render(data) {
      this.scene = data;
      this.maxRaces = this.scene.settings.mobile ? 3 : 10;
      this.createContainer();
    }
    var regexImports = _$$mdAnimate_("./formatnumber");
    var options = render.prototype;
    options.container = null;
    options.raceList = [];
    options.raceCount = 0;
    options.highlightedRace = null;
    options.raceOpacity = 0.3;
    options.raceYOffset = 50;
    options.mobileRaceXOffset = 180;
    options.maxRaces = 10;
    options.createContainer = function() {
      var self = this.scene.game;
      var trigger = self.settings;
      var ratio = self.pixelRatio;
      var scale = ratio / 2.5;
      var block = new createjs.Container;
      block.scaleX = block.scaleY = scale;
      block.y = 80 * scale;
      block.x = 15 * scale;
      if (trigger.isCampaign) {
        block.y += 55 * scale;
      }
      this.container = block;
      self.stage.addChild(block);
    };
    options.clear = function() {
      this.container.removeAllChildren();
      this.raceList = [];
      this.raceCount = 0;
    };
    options.centerContainer = function() {
      var scene = this.scene;
      var canvas = scene.screen;
      var c = this.container;
      var foodIconDefinition = c.getBounds();
      var ratio = this.scene.game.pixelRatio;
      c.x = canvas.width / 2 - foodIconDefinition.width / 2 * c.scaleY;
      var top = 40;
      if (scene.settings.isCampaign) {
        c.visible = false;
      }
      c.y = top * ratio;
    };
    options.addRace = function(options, x) {
      if (this.raceCount < this.maxRaces) {
        var self = this.scene;
        var sel = self.game;
        var attrs = (sel.pixelRatio, options.user);
        var z = options.race;
        var o = self.settings;
        var fps = o.drawFPS;
        var color = attrs.color;
        var COIN = "helsinki";
        var group = new createjs.Container;
        var shape = (self.camera, new createjs.Shape);
        var g = shape.graphics;
        g.setStrokeStyle(4, "round");
        g.beginFill(color).drawCircle(0, 0, 20);
        shape.x = 25;
        shape.y = 25;
        var str = regexImports(parseInt(z.run_ticks) / fps * 1e3);
        var b = new createjs.Text(str, "30px " + COIN, "#000000");
        b.x = 55;
        b.y = 9;
        var text = new createjs.Text(attrs.d_name.charAt(0), "25px " + COIN, "#000000");
        text.x = 17;
        text.y = 33;
        text.textBaseline = "alphabetic";
        var container = new createjs.Container;
        container.addChild(shape);
        container.addChild(text);
        container.cache(0, 0, 50, 50);
        container.removeAllChildren();
        group.addChild(container, b);
        group.alpha = this.raceOpacity;
        if (o.mobile) {
          group.x = x * this.mobileRaceXOffset;
        } else {
          group.x = -2;
          group.y = x * this.raceYOffset;
        }
        this.raceList.push(group);
        this.container.addChild(group);
        this.raceCount++;
      }
    };
    options.update = function() {
      if (this.raceCount > 0) {
        var camera = this.scene.camera;
        if (camera.focusIndex > 0 && camera.focusIndex < this.maxRaces) {
          this.highlightRace(camera.focusIndex - 1);
        } else {
          this.unhighlightRace();
        }
        if (this.scene.settings.mobile) {
          this.centerContainer();
        }
      }
    };
    options.highlightRace = function(name) {
      if (this.highlightedRace !== this.raceList[name]) {
        this.unhighlightRace();
        var e = this.raceList[name];
        e.alpha = 1;
        this.highlightedRace = e;
      }
    };
    options.unhighlightRace = function() {
      if (this.highlightedRace) {
        this.highlightedRace.alpha = this.raceOpacity;
        this.highlightedRace = null;
      }
    };
    module.exports = render;
  }, {
    "./formatnumber" : 59
  }],
  66 : [function(saveNotifs, module) {
    function resize(data) {
      this.scene = data;
      this.stage = data.game.stage;
      this.build_interface();
    }
    var dhms = saveNotifs("./formatnumber");
    var options = resize.prototype;
    options.container = null;
    options.cached = false;
    options.scene = null;
    options.state = null;
    options.offset = {
      y : 0,
      x : 0
    };
    options.build_interface = function() {
      var that = this.scene;
      var referenceWidth = that.game.pixelRatio;
      var o = that.settings;
      var target = new createjs.Container;
      var n = "helsinki";
      var text = new createjs.Text("00:00.00", "40px " + n, "#000000");
      var obj = new createjs.Text("TIME:", "20px " + n, "#999999");
      var a = this.get_timer_sprite();
      var h = new createjs.Text(" -- : --.--", "35px " + n, "#999999");
      var l = new createjs.Text("BEST:", "20px " + n, "#999999");
      var shadow = new createjs.Text("0/0", "40px " + n, "#000000");
      var bitmapFontText = new createjs.Bitmap(that.assets.getResult("targets_icon"));
      var scale = referenceWidth / 2.5;
      if (o.mobile) {
        scale = referenceWidth / 2.5;
      }
      text.y = 18;
      text.x = 57;
      obj.y = 3;
      obj.x = 59;
      a.y = 0;
      a.x = 0;
      h.x = 237;
      h.y = 21;
      l.x = 240;
      l.y = 3;
      shadow.y = 15;
      shadow.x = 460;
      bitmapFontText.y = 0;
      bitmapFontText.x = 400;
      target.addChild(text);
      target.addChild(obj);
      target.addChild(a);
      target.addChild(h);
      target.addChild(l);
      target.addChild(shadow);
      target.addChild(bitmapFontText);
      target.scaleX = target.scaleY = scale;
      target.y = (10 + this.offset.y) * scale;
      target.x = 10 * scale;
      this.best_time_title = l;
      this.time_title = obj;
      this.container = target;
      this.time = text;
      this.goals = shadow;
      this.best_time = h;
      this.stage.addChild(target);
    };
    options.update = function() {
      var s = this.scene;
      var width = s.ticks;
      var data = s.settings;
      var el = s.track;
      var r = s.playerManager.firstPlayer;
      if (this.cached === false && width > 50) {
        this.cached = true;
        this.cache_fixed_text();
      }
      var xStride = width / data.drawFPS;
      this.time.text = dhms(1e3 * xStride);
      var key = el.targetCount;
      var _cur = r.getTargetsHit();
      this.goals.text = _cur + "/" + key;
      var replyLines = " -- : --.--";
      if (data.isCampaign && data.campaignData.user.best_time) {
        replyLines = data.campaignData.user.best_time;
      } else {
        if (data.userTrackStats && data.userTrackStats.best_time) {
          replyLines = data.userTrackStats.best_time;
        }
      }
      this.best_time.text = replyLines;
      if (data.mobile) {
        this.center_container();
      }
    };
    options.center_container = function() {
      var c = this.container;
      var foodIconDefinition = c.getBounds();
      var wh = this.scene.screen;
      var ratio = this.scene.game.pixelRatio;
      c.x = wh.width / 2 - foodIconDefinition.width / 2 * c.scaleY;
      c.y = 10 * ratio;
    };
    options.cache_fixed_text = function() {
      var bounds;
      var myContainer = this.best_time_title;
      var bitmap = this.time_title;
      var paddingTop = 10;
      bounds = myContainer.getBounds();
      myContainer.cache(bounds.x, bounds.y, bounds.width, bounds.height + paddingTop);
      bounds = bitmap.getBounds();
      bitmap.cache(bounds.x, bounds.y, bounds.width, bounds.height + paddingTop);
    };
    options.get_timer_sprite = function() {
      var FileSchema = this.scene.assets.getResult("time_icon");
      var data = {
        images : [FileSchema],
        frames : {
          width : 60,
          height : 60
        }
      };
      var image = new createjs.SpriteSheet(data);
      var module = new createjs.Sprite(image);
      return module;
    };
    module.exports = resize;
  }, {
    "./formatnumber" : 59
  }],
  67 : [function(canCreateDiscussions, mixin) {
    var CryptoJS = CryptoJS || function(e, m) {
      var p = {};
      var j = p.lib = {};
      var l = function() {
      };
      var f = j.Base = {
        extend : function(name) {
          l.prototype = this;
          var c = new l;
          return name && c.mixIn(name), c.hasOwnProperty("init") || (c.init = function() {
            c.$super.init.apply(this, arguments);
          }), c.init.prototype = c, c.$super = this, c;
        },
        create : function() {
          var res = this.extend();
          return res.init.apply(res, arguments), res;
        },
        init : function() {
        },
        mixIn : function(a) {
          var prop;
          for (prop in a) {
            if (a.hasOwnProperty(prop)) {
              this[prop] = a[prop];
            }
          }
          if (a.hasOwnProperty("toString")) {
            this.toString = a.toString;
          }
        },
        clone : function() {
          return this.init.prototype.extend(this);
        }
      };
      var n = j.WordArray = f.extend({
        init : function(a, c) {
          a = this.words = a || [];
          this.sigBytes = c != m ? c : 4 * a.length;
        },
        toString : function(encoder) {
          return (encoder || Hex).stringify(this);
        },
        concat : function(a) {
          var c = this.words;
          var q = a.words;
          var d = this.sigBytes;
          if (a = a.sigBytes, this.clamp(), d % 4) {
            var b = 0;
            for (; a > b; b++) {
              c[d + b >>> 2] |= (q[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((d + b) % 4);
            }
          } else {
            if (65535 < q.length) {
              b = 0;
              for (; a > b; b = b + 4) {
                c[d + b >>> 2] = q[b >>> 2];
              }
            } else {
              c.push.apply(c, q);
            }
          }
          return this.sigBytes += a, this;
        },
        clamp : function() {
          var a = this.words;
          var c = this.sigBytes;
          a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
          a.length = e.ceil(c / 4);
        },
        clone : function() {
          var transformedMasterKey = f.clone.call(this);
          return transformedMasterKey.words = this.words.slice(0), transformedMasterKey;
        },
        random : function(a) {
          var b = [];
          var e = 0;
          for (; a > e; e = e + 4) {
            b.push(4294967296 * e.random() | 0);
          }
          return new n.init(b, a);
        }
      });
      var b = p.enc = {};
      var Hex = b.Hex = {
        stringify : function(a) {
          var q = a.words;
          a = a.sigBytes;
          var outChance = [];
          var b = 0;
          for (; a > b; b++) {
            var a = q[b >>> 2] >>> 24 - 8 * (b % 4) & 255;
            outChance.push((a >>> 4).toString(16));
            outChance.push((15 & a).toString(16));
          }
          return outChance.join("");
        },
        parse : function(t) {
          var c = t.length;
          var b = [];
          var d = 0;
          for (; c > d; d = d + 2) {
            b[d >>> 3] |= parseInt(t.substr(d, 2), 16) << 24 - 4 * (d % 8);
          }
          return new n.init(b, c / 2);
        }
      };
      var g = b.Latin1 = {
        stringify : function(a) {
          var q = a.words;
          a = a.sigBytes;
          var outChance = [];
          var b = 0;
          for (; a > b; b++) {
            outChance.push(String.fromCharCode(q[b >>> 2] >>> 24 - 8 * (b % 4) & 255));
          }
          return outChance.join("");
        },
        parse : function(t) {
          var d = t.length;
          var b = [];
          var c = 0;
          for (; d > c; c++) {
            b[c >>> 2] |= (255 & t.charCodeAt(c)) << 24 - 8 * (c % 4);
          }
          return new n.init(b, d);
        }
      };
      var primParser = b.Utf8 = {
        stringify : function(a) {
          try {
            return decodeURIComponent(escape(g.stringify(a)));
          } catch (e) {
            throw Error("Malformed UTF-8 data");
          }
        },
        parse : function(text) {
          return g.parse(unescape(encodeURIComponent(text)));
        }
      };
      var k = j.BufferedBlockAlgorithm = f.extend({
        reset : function() {
          this._data = new n.init;
          this._nDataBytes = 0;
        },
        _append : function(data) {
          if ("string" == typeof data) {
            data = primParser.parse(data);
          }
          this._data.concat(data);
          this._nDataBytes += data.sigBytes;
        },
        _process : function(a) {
          var c = this._data;
          var b = c.words;
          var d = c.sigBytes;
          var f = this.blockSize;
          var h = d / (4 * f);
          h = a ? e.ceil(h) : e.max((0 | h) - this._minBufferSize, 0);
          if (a = h * f, d = e.min(4 * a, d), a) {
            var g = 0;
            for (; a > g; g = g + f) {
              this._doProcessBlock(b, g);
            }
            g = b.splice(0, a);
            c.sigBytes -= d;
          }
          return new n.init(g, d);
        },
        clone : function() {
          var funcThread = f.clone.call(this);
          return funcThread._data = this._data.clone(), funcThread;
        },
        _minBufferSize : 0
      });
      j.Hasher = k.extend({
        cfg : f.extend(),
        init : function(a) {
          this.cfg = this.cfg.extend(a);
          this.reset();
        },
        reset : function() {
          k.reset.call(this);
          this._doReset();
        },
        update : function(text) {
          return this._append(text), this._process(), this;
        },
        finalize : function(a) {
          return a && this._append(a), this._doFinalize();
        },
        blockSize : 16,
        _createHelper : function(a) {
          return function(context, b) {
            return (new a.init(b)).finalize(context);
          };
        },
        _createHmacHelper : function(a) {
          return function(b, f) {
            return (new s.HMAC.init(a, f)).finalize(b);
          };
        }
      });
      var s = p.algo = {};
      return p;
    }(Math);
    !function(Math) {
      var i = CryptoJS;
      var m = i.lib;
      var p = m.WordArray;
      var j = m.Hasher;
      m = i.algo;
      var r = [];
      var acc = [];
      var f = function(name) {
        return 4294967296 * (name - (0 | name)) | 0;
      };
      var g = 2;
      var k = 0;
      for (; 64 > k;) {
        var n;
        t: {
          n = g;
          var t = Math.sqrt(n);
          var d = 2;
          for (; t >= d; d++) {
            if (!(n % d)) {
              n = false;
              break t;
            }
          }
          n = true;
        }
        if (n) {
          if (8 > k) {
            r[k] = f(Math.pow(g, 0.5));
          }
          acc[k] = f(Math.pow(g, 1 / 3));
          k++;
        }
        g++;
      }
      var s = [];
      m = m.SHA256 = j.extend({
        _doReset : function() {
          this._hash = new p.init(r.slice(0));
        },
        _doProcessBlock : function(f, n) {
          var b = this._hash.words;
          var t = b[0];
          var a = b[1];
          var e = b[2];
          var h = b[3];
          var c = b[4];
          var d = b[5];
          var l = b[6];
          var j = b[7];
          var i = 0;
          for (; 64 > i; i++) {
            if (16 > i) {
              s[i] = 0 | f[n + i];
            } else {
              var v = s[i - 15];
              var u = s[i - 2];
              s[i] = ((v << 25 | v >>> 7) ^ (v << 14 | v >>> 18) ^ v >>> 3) + s[i - 7] + ((u << 15 | u >>> 17) ^ (u << 13 | u >>> 19) ^ u >>> 10) + s[i - 16];
            }
            v = j + ((c << 26 | c >>> 6) ^ (c << 21 | c >>> 11) ^ (c << 7 | c >>> 25)) + (c & d ^ ~c & l) + acc[i] + s[i];
            u = ((t << 30 | t >>> 2) ^ (t << 19 | t >>> 13) ^ (t << 10 | t >>> 22)) + (t & a ^ t & e ^ a & e);
            j = l;
            l = d;
            d = c;
            c = h + v | 0;
            h = e;
            e = a;
            a = t;
            t = v + u | 0;
          }
          b[0] = b[0] + t | 0;
          b[1] = b[1] + a | 0;
          b[2] = b[2] + e | 0;
          b[3] = b[3] + h | 0;
          b[4] = b[4] + c | 0;
          b[5] = b[5] + d | 0;
          b[6] = b[6] + l | 0;
          b[7] = b[7] + j | 0;
        },
        _doFinalize : function() {
          var f = this._data;
          var d = f.words;
          var b = 8 * this._nDataBytes;
          var c = 8 * f.sigBytes;
          return d[c >>> 5] |= 128 << 24 - c % 32, d[(c + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296), d[(c + 64 >>> 9 << 4) + 15] = b, f.sigBytes = 4 * d.length, this._process(), this._hash;
        },
        clone : function() {
          var _this = j.clone.call(this);
          return _this._hash = this._hash.clone(), _this;
        }
      });
      i.SHA256 = j._createHelper(m);
      i.HmacSHA256 = j._createHmacHelper(m);
    }(Math);
    mixin.exports = CryptoJS;
  }, {}],
  68 : [function(canCreateDiscussions, module) {
    var Player = (Math.min, function(data) {
      this.scene = data;
      this.sounds = {};
    });
    Player.prototype = {
      sounds : null,
      update : function() {
        var _api = createjs.Sound;
        var s = this.scene;
        var ss = s.settings;
        _api.setMute(s.state.paused || ss.soundsEnabled === false ? true : false);
      },
      setVolume : function(sound, vol) {
        if (this.sounds[sound]) {
          this.sounds[sound].volume = vol;
        }
      },
      muted : false,
      mute_all : function() {
        var sounds = this.sounds;
        var i;
        for (i in sounds) {
          if (sounds.hasOwnProperty(i)) {
            sounds[i].volume = 0;
          }
        }
        this.muted = true;
      },
      stop_all : function() {
        var sounds = this.sounds;
        var i;
        for (i in sounds) {
          if (sounds.hasOwnProperty(i)) {
            sounds[i].volume = 0;
            sounds[i].stop();
          }
        }
      },
      play : function(name, value) {
        if ((null === value || "undefined" == typeof value) && (value = 1), this.sounds[name]) {
          this.sounds[name].volume = value;
        } else {
          if (this.scene.settings.soundsEnabled) {
            var sound = createjs.Sound.play(name, {
              volume : value
            });
            var self = this;
            sound.addEventListener("complete", function() {
              self.sounds[name] = null;
            });
            this.sounds[name] = sound;
          }
        }
      },
      stop : function(id) {
        if (this.sounds[id]) {
          this.sounds[id].stop();
          this.sounds[id] = null;
        }
      },
      close : function() {
        this.sounds = null;
      }
    };
    module.exports = Player;
  }, {}],
  69 : [function(saveNotifs, module) {
    function App(data) {
      this.scene = data;
      this.settings = data.settings;
      this.player = false;
      this.build_interface();
      this.createPulseTween();
    }
    var TWEEN = saveNotifs("../../libs/tween");
    var self = App.prototype;
    self.scene = null;
    self.container = null;
    self.cached = false;
    self.build_interface = function() {
      var scale = this.scene.game.pixelRatio;
      var container = new createjs.Container;
      var i = "helsinki";
      var bar = new createjs.Shape;
      bar.graphics.setStrokeStyle(5, "round").beginStroke("rgba(242,144,66,1)").beginFill("rgba(242,144,66,0.5)").drawRoundRect(0, 0, 200, 60, 25);
      var text = new createjs.Text("00:00", "35px " + i, "#000000");
      text.textAlign = "center";
      text.textBaseline = "middle";
      text.x = 100;
      text.y = 30;
      container.addChild(bar);
      container.addChild(text);
      container.visible = false;
      container.scaleX = container.scaleY = scale / 2;
      this.timeText = text;
      this.container = container;
      this.scene.game.stage.addChild(container);
      this.center_container();
    };
    self.setPlayer = function(item) {
      this.player = item;
    };
    self.removePlayer = function() {
      this.player = false;
    };
    self.playerAddedTime = function(item) {
      if (this.player === item) {
        this.createPulseTween();
      }
    };
    self.createPulseTween = function() {
      var controller = this.container;
      var pixelRatio = this.scene.game.pixelRatio;
      var destScale = pixelRatio / 2;
      var from = {
        scale : destScale
      };
      var value = {
        scale : 1.2 * destScale
      };
      this.pulse = (new TWEEN.Tween(from)).to(value, 200).repeat(1).yoyo(true).easing(TWEEN.Easing.Cubic.InOut).onUpdate(function() {
        controller.scaleX = controller.scaleY = this.scale;
      }).start();
    };
    self.center_container = function() {
      var wh = this.scene.screen;
      var container = this.container;
      container.x = wh.width / 2 - 100 * container.scaleX;
      container.y = wh.height - 100 * container.scaleY;
    };
    self.update = function() {
      TWEEN.update();
      if (this.player && this.player._tempVehicleTicks > 0) {
        this.center_container();
        this.updateTime();
      } else {
        this.container.visible = false;
      }
    };
    self.updateTime = function() {
      var publicInfo = (this.container, this.timeText);
      var size = (this.player, this.player._tempVehicleTicks);
      var n = this.scene.settings.drawFPS;
      var s = size / n;
      s = s.toFixed(2);
      var title = "";
      if (10 > s) {
        title = "0";
      }
      title = title + s;
      publicInfo.text = title;
      this.container.visible = true;
    };
    self.close = function() {
      this.container = null;
      this.player = null;
      this.scene = null;
      this.settings = null;
      this.timeText = null;
    };
    module.exports = App;
  }, {
    "../../libs/tween" : 92
  }],
  70 : [function(require, asset) {
    var i = function(e, a) {
      this.vehicleInit(e);
      this.createMasses(a);
      this.createSprings();
      this.stopSounds();
      this.focalPoint = this.head;
    };
    asset.exports = i;
    var CircleParticle = require("../math/cartesian");
    var ent = require("./mass");
    var Index = require("./spring");
    var EventManager = require("./vehicle");
    var Thread = require("./canopy");
    var s = {
      BALLOON_ON : "balloon_on"
    };
    var self = i.prototype = new EventManager;
    self.vehicleName = "BALLOON";
    self.head = null;
    self.basket = null;
    self.masses = null;
    self.springs = null;
    self.slow = false;
    self.vehicleInit = self.init;
    self.crashed = false;
    self.createMasses = function(that) {
      this.masses = [];
      var t = new Thread(that.x, that.y - 10, this);
      t.radius = 30;
      var o = new ent;
      o.init(new CircleParticle(that.x, that.y + 35), this);
      o.friction = 0.1;
      this.masses.push(t);
      this.masses.push(o);
      this.head = this.masses[0];
      this.basket = this.masses[1];
      var metrics = this;
      this.masses[0].drive = this.head.drive = function() {
        metrics.explode();
      };
    };
    self.updateCameraFocalPoint = function() {
    };
    self.createSprings = function() {
      this.springs = [];
      var idx = new Index(this.head, this.basket, this);
      idx.springConstant = 0.2;
      idx.dampConstant = 0.2;
      idx.lrest = idx.leff = 45;
      this.springs.push(idx);
    };
    self.update = function() {
      if (this.crashed === false && this.updateSound(), this.explosion) {
        this.explosion.update();
      } else {
        this.head.wind = !this.basket.contact;
        this.slow = false;
        var springs = this.springs;
        var numClasses = springs.length;
        var i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        var _volumes = this.masses;
        var len = _volumes.length;
        var j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
        i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
      }
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        var sound = this.scene.sound;
        var player = this.gamepad;
        if (player.isButtonDown("up")) {
          sound.play(s.BALLOON_ON, 0.6);
        } else {
          if (!player.isButtonDown("up")) {
            sound.stop(s.BALLOON_ON);
          }
        }
      }
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.BALLOON_ON);
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw(1);
      } else {
        var context = this.scene.game.canvas.getContext("2d");
        if (this.settings.developerMode) {
          var s = this.masses;
          var i = s.length;
          var l = i - 1;
          for (; l >= 0; l--) {
            s[l].draw();
          }
        }
        context.globalAlpha = this.player._opacity;
        this.drawBalloon(context);
        context.globalAlpha = 1;
      }
    };
    self.drawBalloon = function(ctx) {
      var s = this.scene;
      var style = this.basket.pos.toScreen(s);
      var center = this.head.pos.toScreen(s);
      var zoom = s.camera.zoom;
      var width = center.x - style.x;
      var dy = center.y - style.y;
      var dx = -dy;
      var r = width;
      ctx.save();
      ctx.strokeStyle = "#999999";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(style.x + 0.1 * dx, style.y + 0.1 * r);
      ctx.lineTo(style.x + 0.5 * width + 0.4 * dx, style.y + 0.5 * dy + 0.4 * r);
      ctx.moveTo(style.x - 0.1 * dx, style.y - 0.1 * r);
      ctx.lineTo(style.x + 0.5 * width - 0.4 * dx, style.y + 0.5 * dy - 0.4 * r);
      ctx.moveTo(style.x + 0.1 * dx, style.y + 0.1 * r);
      ctx.lineTo(style.x + 0.36 * width + 0.2 * dx, style.y + 0.36 * dy + 0.2 * r);
      ctx.moveTo(style.x - 0.1 * dx, style.y - 0.1 * r);
      ctx.lineTo(style.x + 0.36 * width - 0.2 * dx, style.y + 0.36 * dy - 0.2 * r);
      ctx.closePath();
      ctx.stroke();
      this.head.draw(ctx);
      if (this.gamepad.isButtonDown("up")) {
        ctx.beginPath();
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 8 * zoom;
        ctx.moveTo(style.x, style.y);
        ctx.lineTo(style.x + 0.1 * width, style.y + 0.1 * dy);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = "#FFAA00";
        ctx.lineWidth = 3 * zoom;
        ctx.moveTo(style.x, style.y);
        ctx.lineTo(style.x + 0.1 * width, style.y + 0.1 * dy);
        ctx.closePath();
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.fillStyle = "#000000";
      ctx.moveTo(style.x + 0.1 * dx, style.y + 0.1 * r);
      ctx.lineTo(style.x - 0.1 * dx, style.y - 0.1 * r);
      ctx.lineTo(style.x - 0.22 * width - 0.1 * dx, style.y - 0.22 * dy - 0.1 * r);
      ctx.lineTo(style.x - 0.22 * width + 0.1 * dx, style.y - 0.22 * dy + 0.1 * r);
      ctx.lineTo(style.x + 0.1 * dx, style.y + 0.1 * r);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };
  }, {
    "../math/cartesian" : 14,
    "./canopy" : 73,
    "./mass" : 77,
    "./spring" : 83,
    "./vehicle" : 85
  }],
  71 : [function(require, asset) {
    function i(e, a) {
      this.vehicleInit(e);
      this.createMasses(a);
      this.createSprings();
      this.stopSounds();
    }
    var Auth = require("../math/cartesian");
    var EventDispatcher = require("./mass");
    var Panel = require("./wheel");
    var Tuple2 = require("./spring");
    var EventManager = require("./vehicle");
    var s = (Math.PI, Math.atan2, Math.min, {
      BLOB : "blob_sound"
    });
    var self = i.prototype = new EventManager;
    self.vehicleName = "Blob";
    self.vehicleInit = self.init;
    self.vehicleUpdate = self.update;
    self.vehicleDraw = self.draw;
    self.masses = null;
    self.springs = null;
    self.slow = false;
    self.createMasses = function(b) {
      var col_list = [];
      col_list.push(new Panel(new Auth(b.x + 15, b.y + 40), this));
      col_list.push(new Panel(new Auth(b.x + -15, b.y + 40), this));
      col_list.push(new Panel(new Auth(b.x + -15, b.y + 10), this));
      col_list.push(new Panel(new Auth(b.x + 15, b.y + 10), this));
      var self = new EventDispatcher;
      self.init(new Auth(0, 0), this);
      self.vel = new Auth(0, 0);
      this.m0 = col_list[0];
      this.m1 = col_list[1];
      this.m2 = col_list[2];
      this.m3 = col_list[3];
      this.head = self;
      this.masses = col_list;
      this.focalPoint = this.head;
    };
    self.createSprings = function() {
      var parts = this.masses;
      var value = [];
      parts = this.masses;
      value = [];
      var n = this.spring0 = new Tuple2(parts[0], parts[1], this);
      var h = this.spring1 = new Tuple2(parts[1], parts[2], this);
      var o = this.spring2 = new Tuple2(parts[2], parts[3], this);
      var r = this.spring3 = new Tuple2(parts[3], parts[0], this);
      var index = this.spring4 = new Tuple2(parts[0], parts[2], this);
      var task = this.spring5 = new Tuple2(parts[1], parts[3], this);
      value.push(n);
      value.push(h);
      value.push(o);
      value.push(r);
      value.push(index);
      value.push(task);
      var classKey;
      for (classKey in value) {
        value[classKey].springConstant = 0.2;
        value[classKey].dampConstant = 0.2;
      }
      this.springs = value;
    };
    self.update = function() {
      if (this.crashed === false && (this.updateSound(), this.control()), this.explosion) {
        this.explosion.update();
      } else {
        var positions = this.masses;
        var n = positions.length;
        var group = this.springs;
        var start = group.length;
        s = start - 1;
        for (; s >= 0; s--) {
          group[s].update();
        }
        m = n - 1;
        for (; m >= 0; m--) {
          positions[m].update();
        }
        if ((positions[0].contact || positions[1].contact || positions[2].contact || positions[3].contact) && (this.slow = false), !this.slow) {
          this.control();
          s = start - 1;
          for (; s >= 0; s--) {
            group[s].update();
          }
          m = n - 1;
          for (; m >= 0; m--) {
            positions[m].update();
          }
        }
        var tw = 0;
        var i = 0;
        m = 0;
        for (; m < n; m++) {
          tw = tw + positions[m].pos.x;
          i = i + positions[m].pos.y;
        }
        var curr = this.head;
        curr.pos.x = 0.25 * tw;
        curr.pos.y = 0.25 * i;
        curr.vel = positions[0].vel;
      }
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        var sound = this.scene.sound;
        sound.play(s.BLOB, 0.4);
      }
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.BLOB);
    };
    self.updateCameraFocalPoint = function() {
    };
    self.control = function() {
      var i;
      var trapId;
      var vec3 = this.player.getGamepad();
      var result = vec3.isButtonDown("up");
      var brake = vec3.isButtonDown("down");
      var left = vec3.isButtonDown("left");
      var anchor = vec3.isButtonDown("right");
      var e = vec3.isButtonDown("z");
      var onCompleteBindings = this.masses;
      var attempts = this.springs;
      var len = onCompleteBindings.length;
      var attemptsLength = attempts.length;
      var dir = this.dir;
      dir = anchor ? 1 : -1;
      var prevOffset = anchor || left ? 1 : 0;
      if (brake) {
        prevOffset = 0;
      }
      i = len - 1;
      for (; i >= 0; i--) {
        onCompleteBindings[i].motor += (prevOffset * dir * 1 - onCompleteBindings[i].motor) / 10;
        if (0 == prevOffset) {
          onCompleteBindings[i].motor = 0;
        }
        onCompleteBindings[i].brake = brake;
      }
      var angle = left ? 1 : 0;
      if (angle = angle + (anchor ? -1 : 0), attempts[4].rotate(angle / 9), attempts[5].rotate(angle / 9), e || result) {
        trapId = attemptsLength - 1;
        for (; trapId >= 0; trapId--) {
          attempts[trapId].contract(30, 10);
        }
      } else {
        trapId = attemptsLength - 1;
        for (; trapId >= 0; trapId--) {
          attempts[trapId].contract(0, 1.5);
        }
      }
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw(1);
      } else {
        var context = this.scene.game.canvas.getContext("2d");
        var curPosAndNor = this.masses;
        var s = this.scene;
        var zoom = s.camera.zoom;
        var r = curPosAndNor[0].pos.toScreen(s);
        var p2 = curPosAndNor[1].pos.toScreen(s);
        var line = curPosAndNor[2].pos.toScreen(s);
        var center = curPosAndNor[3].pos.toScreen(s);
        context.globalAlpha = this.player._opacity;
        context.beginPath();
        context.strokeStyle = "#000000";
        context.fillStyle = "#000000";
        context.lineWidth = 20 * zoom;
        context.lineCap = "round";
        context.moveTo(r.x, r.y);
        context.lineTo(p2.x, p2.y);
        context.lineTo(line.x, line.y);
        context.lineTo(center.x, center.y);
        context.lineTo(r.x, r.y);
        context.fill();
        context.stroke();
        context.globalAlpha = 1;
      }
    };
    asset.exports = i;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./spring" : 83,
    "./vehicle" : 85,
    "./wheel" : 86
  }],
  72 : [function(require, asset) {
    function i(a, i, e, s) {
      this.vehicleInit(a);
      this.createMasses(i, s);
      this.createSprings();
      this.updateCameraFocalPoint();
      this.stopSounds();
      if (-1 === e) {
        this.swap();
      }
    }
    asset.exports = i;
    var Point = require("../math/cartesian");
    var BPromise = require("./mass");
    var Set = require("./spring");
    var EventManager = require("./vehicle");
    var FieldObject = require("./wheel");
    var TagHourlyStat = require("./ragdoll");
    var coveredByRange = (Math.PI, Math.atan2);
    var nativeFloor = Math.floor;
    var nativeRandom = Math.random;
    var round = Math.min;
    var s = {
      BIKE_GROUND : "bike_ground",
      BIKE_AIR : "bike_air",
      BIKE_FALL_1 : "bike_fall_1",
      BIKE_FALL_2 : "bike_fall_2",
      BIKE_FALL_3 : "bike_fall_3"
    };
    var self = i.prototype = new EventManager;
    self.vehicleName = "BMX";
    self.vehicleInit = self.init;
    self.vehicleUpdate = self.update;
    self.masses = null;
    self.springs = null;
    self.cosmetics = null;
    self.slow = false;
    self.pedala = 0;
    self.cosmeticHead = null;
    self.cosmeticRearWheel = null;
    self.cosmeticFrontWheel = null;
    self.swapped = false;
    self.ragdoll = null;
    self.createMasses = function(d, e) {
      this.masses = [];
      var p = new BPromise;
      var f = new FieldObject(new Point(d.x + 21, d.y + 3), this);
      var obj = new FieldObject(new Point(d.x + -21, d.y + 3), this);
      p.init(new Point(d.x, d.y - 36), this);
      p.drive = this.createRagdoll.bind(this);
      obj.radius = 11.7;
      f.radius = 11.7;
      p.radius = 14;
      p.vel.equ(e);
      obj.vel.equ(e);
      f.vel.equ(e);
      this.masses.push(p);
      this.masses.push(obj);
      this.masses.push(f);
      this.head = p;
      this.frontWheel = f;
      this.rearWheel = obj;
    };
    self.createSprings = function() {
      this.springs = [];
      var obj = new Set(this.head, this.rearWheel, this);
      var options = new Set(this.rearWheel, this.frontWheel, this);
      var items = new Set(this.frontWheel, this.head, this);
      options.lrest = 42;
      options.leff = 42;
      options.springConstant = 0.35;
      options.dampConstant = 0.3;
      obj.lrest = 45;
      obj.leff = 45;
      obj.springConstant = 0.35;
      obj.dampConstant = 0.3;
      items.lrest = 45;
      items.leff = 45;
      items.springConstant = 0.35;
      items.dampConstant = 0.3;
      this.springs.push(obj);
      this.springs.push(options);
      this.springs.push(items);
      this.rearSpring = obj;
      this.chasse = options;
      this.frontSpring = items;
    };
    self.createRagdoll = function() {
      this.ragdoll = new TagHourlyStat(this.getStickMan(), this);
      this.ragdoll.zero(this.head.vel, this.rearWheel.vel);
      this.ragdoll.dir = this.dir;
      this.rearWheel.motor = 0;
      this.rearWheel.brake = false;
      this.frontWheel.brake = false;
      this.head.collide = false;
      this.updateCameraFocalPoint();
      if (this.player.isInFocus()) {
        this.playBailSound();
      }
      this.dead();
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.BIKE_AIR);
      sound.stop(s.BIKE_GROUND);
    };
    self.playBailSound = function() {
      var sound = this.scene.sound;
      var offset = round(this.speed / 50, 1);
      var i = nativeFloor(3 * nativeRandom()) + 1;
      switch(i) {
        case 1:
          sound.play(s.BIKE_FALL_1, offset);
          break;
        case 2:
          sound.play(s.BIKE_FALL_2, offset);
          break;
        case 3:
          sound.play(s.BIKE_FALL_3, offset);
      }
    };
    self.updateCameraFocalPoint = function() {
      this.focalPoint = this.ragdoll ? this.ragdoll.head : this.head;
    };
    self.getStickMan = function() {
      var s = this.dir;
      var e = this.head;
      var world = this.frontWheel;
      var particle = this.rearWheel;
      var bearingRad = this.pedala;
      var t = world.pos.sub(particle.pos);
      var instructionInfo = e.pos.sub(world.pos.add(particle.pos).factor(0.5));
      var p = new Point(t.y * s, -t.x * s);
      var self = {};
      self.head = particle.pos.add(t.factor(0.35)).add(instructionInfo.factor(1.2));
      self.lHand = self.rHand = particle.pos.add(t.factor(0.8)).add(p.factor(0.68));
      var a = self.head.sub(self.lHand);
      a = new Point(a.y * s, -a.x * s);
      self.lElbow = self.rElbow = self.head.add(self.lHand).factor(0.5).add(a.factor(130 / a.lenSqr()));
      self.waist = particle.pos.add(t.factor(0.2)).add(p.factor(0.5));
      var pos = new Point(6 * Math.cos(bearingRad), 6 * Math.sin(bearingRad));
      return self.lFoot = particle.pos.add(t.factor(0.4)).add(p.factor(0.05)).add(pos), a = self.waist.sub(self.lFoot), a = new Point(-a.y * s, a.x * s), self.lKnee = self.waist.add(self.lFoot).factor(0.5).add(a.factor(160 / a.lenSqr())), self.rFoot = particle.pos.add(t.factor(0.4)).add(p.factor(0.05)).sub(pos), a = self.waist.sub(self.rFoot), a = new Point(-a.y * s, a.x * s), self.rKnee = self.waist.add(self.rFoot).factor(0.5).add(a.factor(160 / a.lenSqr())), self;
    };
    self.update = function() {
      if (this.crashed === false && (this.updateSound(), this.control()), this.explosion) {
        this.explosion.update();
      } else {
        var springs = this.springs;
        var numClasses = springs.length;
        var i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        var _volumes = this.masses;
        var len = _volumes.length;
        var j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
        if (this.rearWheel.contact && this.frontWheel.contact && (this.slow = false), this.slow === false) {
          if (this.crashed === false) {
            this.control();
          }
          i = numClasses - 1;
          for (; i >= 0; i--) {
            springs[i].update();
          }
          j = len - 1;
          for (; j >= 0; j--) {
            _volumes[j].update();
          }
        }
        if (this.ragdoll) {
          this.ragdoll.update();
        } else {
          this.updateDrawHeadAngle();
        }
      }
      this.updateCameraFocalPoint();
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        this.updateSpeed();
        var offset = round(this.speed / 50, 1);
        var sound = this.scene.sound;
        if (this.rearWheel.contact || this.frontWheel.contact) {
          sound.play(s.BIKE_GROUND, offset);
          sound.stop(s.BIKE_AIR);
        } else {
          sound.play(s.BIKE_AIR, offset);
          sound.stop(s.BIKE_GROUND);
        }
      }
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.BIKE_AIR);
      sound.stop(s.BIKE_GROUND);
    };
    self.swap = function() {
      this.dir = -1 * this.dir;
      this.chasse.swap();
      var t = this.rearSpring.leff;
      this.rearSpring.leff = this.frontSpring.leff;
      this.frontSpring.leff = t;
    };
    self.control = function() {
      var assert = this.gamepad;
      var result = assert.isButtonDown("up");
      var down = assert.isButtonDown("down");
      var isBigEndian = (assert.isButtonDown("back"), assert.isButtonDown("left"));
      var up = assert.isButtonDown("right");
      var flagZ = assert.isButtonDown("z");
      var newPos = result ? 1 : 0;
      var self = this.rearWheel;
      self.motor += (newPos - self.motor) / 10;
      if (flagZ && !this.swapped) {
        this.swap();
        this.swapped = true;
      }
      if (!flagZ) {
        this.swapped = false;
      }
      if (result) {
        this.pedala += this.rearWheel.speed / 5;
      }
      self.brake = down;
      if (down) {
        this.frontSpring.contract(-10, 10);
      }
      this.frontWheel.brake = this.dir > 0 && up && down ? true : this.dir < 0 && isBigEndian && down ? true : false;
      var iInteger = isBigEndian ? 1 : 0;
      iInteger = iInteger + (up ? -1 : 0);
      this.rearSpring.contract(5 * iInteger * this.dir, 5);
      this.frontSpring.contract(5 * -iInteger * this.dir, 5);
      this.chasse.rotate(iInteger / 6);
      if (!iInteger && result) {
        this.rearSpring.contract(-7, 5);
        this.frontSpring.contract(7, 5);
      }
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw();
      } else {
        var ctx2 = this.scene.game.canvas.getContext("2d");
        if (ctx2.imageSmoothingEnabled = true, ctx2.webkitImageSmoothingEnabled = true, ctx2.mozImageSmoothingEnabled = true, this.settings.developerMode) {
          var s = this.masses;
          var i = s.length;
          var l = i - 1;
          for (; l >= 0; l--) {
            s[l].draw();
          }
        }
        this.drawBikeFrame();
      }
    };
    self.updateDrawHeadAngle = function() {
      var o = this.frontWheel.pos;
      var pos = this.rearWheel.pos;
      var i = o.x;
      var size = o.y;
      var length = pos.x;
      var row = pos.y;
      var start = i - length;
      var end = size - row;
      this.drawHeadAngle = -(coveredByRange(start, end) - Math.PI / 2);
    };
    self.drawBikeFrame = function() {
      var e = this.scene;
      var point = this.rearWheel.pos.toScreen(e);
      var center = this.frontWheel.pos.toScreen(e);
      var n = this.head.pos.toScreen(e);
      var OVERLAY_ALPHA = (e.game.pixelRatio, this.player._opacity);
      var a = center.sub(point);
      var position = new Point((center.y - point.y) * this.dir, (point.x - center.x) * this.dir);
      var bearingRad = this.pedala;
      var s = this.dir;
      var scale = e.camera.zoom;
      var ctx = e.game.canvas.getContext("2d");
      ctx.globalAlpha = OVERLAY_ALPHA;
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = 3 * scale;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      ctx.fillStyle = "rgba(200,200, 200, 0.2)";
      ctx.arc(center.x, center.y, 10.5 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(point.x, point.y, 10.5 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      var r1 = point.add(a.factor(0.3)).add(position.factor(0.25));
      var pos = point.add(a.factor(0.4)).add(position.factor(0.05));
      var outerPosition = point.add(a.factor(0.84)).add(position.factor(0.42));
      var currentVM = point.add(a.factor(0.84)).add(position.factor(0.37));
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.moveTo(point.x, point.y);
      ctx.lineTo(r1.x, r1.y);
      ctx.lineTo(outerPosition.x, outerPosition.y);
      ctx.moveTo(currentVM.x, currentVM.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.lineTo(point.x, point.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = Math.max(1 * scale, 0.5);
      ctx.arc(pos.x, pos.y, 3 * scale, 0, 2 * Math.PI, false);
      ctx.stroke();
      var p = new Point(6 * Math.cos(bearingRad) * scale, 6 * Math.sin(bearingRad) * scale);
      var m = pos.add(p);
      var p1 = pos.sub(p);
      ctx.beginPath();
      ctx.moveTo(m.x, m.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      var p2coord = point.add(a.factor(0.25)).add(position.factor(0.4));
      var tempLook = point.add(a.factor(0.17)).add(position.factor(0.38));
      var p3coord = point.add(a.factor(0.3)).add(position.factor(0.45));
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = 3 * scale;
      ctx.moveTo(tempLook.x, tempLook.y);
      ctx.lineTo(p3coord.x, p3coord.y);
      ctx.moveTo(pos.x, pos.y);
      ctx.lineTo(p2coord.x, p2coord.y);
      var mouthStart = point.add(a.factor(1)).add(position.factor(0));
      var p4coord = point.add(a.factor(0.97)).add(position.factor(0));
      var p1coord = point.add(a.factor(0.8)).add(position.factor(0.48));
      ctx.moveTo(mouthStart.x, mouthStart.y);
      ctx.lineTo(p4coord.x, p4coord.y);
      ctx.lineTo(p1coord.x, p1coord.y);
      var arrowEnd = point.add(a.factor(0.86)).add(position.factor(0.5));
      var endT = point.add(a.factor(0.82)).add(position.factor(0.65));
      var end = point.add(a.factor(0.78)).add(position.factor(0.67));
      if (ctx.moveTo(p1coord.x, p1coord.y), ctx.lineTo(arrowEnd.x, arrowEnd.y), ctx.lineTo(endT.x, endT.y), ctx.lineTo(end.x, end.y), ctx.stroke(), this.crashed) {
        if (this.ragdoll) {
          this.ragdoll.draw();
        }
      } else {
        position = n.sub(point.add(a.factor(0.5)));
        var e = r1.add(a.factor(-0.1)).add(position.factor(0.3));
        var p = m.sub(e);
        var offset = new Point(p.y * s, -p.x * s);
        offset = offset.factor(scale * scale);
        var p1coord = e.add(p.factor(0.5)).add(offset.factor(200 / p.lenSqr()));
        var p2coord = m.add(p.factor(0.12)).add(offset.factor(50 / p.lenSqr()));
        p = p1.sub(e);
        offset = new Point(p.y * s, -p.x * s);
        offset = offset.factor(scale * scale);
        var p3coord = e.add(p.factor(0.5)).add(offset.factor(200 / p.lenSqr()));
        var p4coord = p1.add(p.factor(0.12)).add(offset.factor(50 / p.lenSqr()));
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.lineWidth = 6 * scale;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p3coord.x, p3coord.y);
        ctx.lineTo(e.x, e.y);
        ctx.stroke();
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p4coord.x, p4coord.y);
        ctx.stroke();
        ctx.lineWidth = 6 * scale;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(p1coord.x, p1coord.y);
        ctx.lineTo(e.x, e.y);
        ctx.stroke();
        ctx.lineWidth = 6 * scale;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(p2coord.x, p2coord.y);
        ctx.stroke();
        var code = r1.add(a.factor(0.05)).add(position.factor(0.9));
        ctx.lineWidth = 8 * scale;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(code.x, code.y);
        ctx.stroke();
        var item = r1.add(a.factor(0.15)).add(position.factor(1.05));
        a = code.sub(end);
        position = new Point(a.y * s, -a.x * s);
        position = position.factor(scale * scale);
        var arrowEnd = end.add(a.factor(0.4)).add(position.factor(130 / a.lenSqr()));
        ctx.lineWidth = 5 * scale;
        ctx.beginPath();
        ctx.moveTo(code.x, code.y);
        ctx.lineTo(arrowEnd.x, arrowEnd.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        var to = this.cosmetics;
        var self = GameInventoryManager.getItem(to.head);
        var callback = this.drawHeadAngle;
        self.draw(ctx, item.x, item.y, callback, scale, this.dir);
        ctx.globalAlpha = 1;
      }
    };
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./ragdoll" : 82,
    "./spring" : 83,
    "./vehicle" : 85,
    "./wheel" : 86
  }],
  73 : [function(require, module) {
    function Sprite(name, target, id) {
      this.init(new Animation(name, target), id);
      this.radius = 10;
      this.collide = true;
      this.wind = true;
    }
    var NumericType = require("./mass");
    var Animation = require("../math/cartesian");
    Sprite.prototype = Object.create(NumericType.prototype);
    Sprite.prototype.drive = function(uv1u, uv1v) {
      var pos = this.pos;
      var xhair = this.vel;
      pos.x += 0.05 * uv1u * -uv1u * (uv1u * xhair.x + uv1v * xhair.y);
      this.contact = true;
    };
    Sprite.prototype.update = function() {
      var outerPos = (this.parent, this.vel);
      var pos = this.pos;
      var sprite = this.old;
      var pt = this.parent.gravity;
      var editor = this.parent.gamepad;
      var result = editor.isButtonDown("up");
      var leftExp = editor.isButtonDown("left");
      var isRightArray = editor.isButtonDown("right");
      if (0 !== pt.x || 0 !== pt.y) {
        outerPos.x = 0.9 * outerPos.x;
        outerPos.y = 0.99 * outerPos.y;
      }
      if (leftExp) {
        pos.x += -0.05;
      }
      if (isRightArray) {
        pos.x += 0.05;
      }
      if (0 !== pt.x || 0 !== pt.y) {
        pos.y += -0.1;
      }
      if (result) {
        pos.y += -0.5;
      }
      if (this.wind) {
        pos.x += 0.3;
      }
      pos.x += outerPos.x;
      pos.y += outerPos.y;
      contact = false;
      if (this.collide) {
        this.scene.track.collide(this);
      }
      if (0 !== pt.x || 0 !== pt.y) {
        outerPos.x = pos.x - sprite.x;
        outerPos.y = pos.y - sprite.y;
      }
      sprite.x = pos.x;
      sprite.y = pos.y;
    };
    Sprite.prototype.draw = function(context) {
      var res = this.parent.scene;
      var obj = this.pos.toScreen(res);
      var radius = this.radius * res.camera.zoom;
      context.beginPath();
      context.fillStyle = "#000000";
      context.arc(obj.x, obj.y, radius, 0, 2 * Math.PI, false);
      context.closePath();
      context.fill();
    };
    module.exports = Sprite;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77
  }],
  74 : [function(saveNotifs, context) {
    function init(obj, arg, data) {
      this.massInit(obj, arg);
      this.color = data;
      this.pos.x = obj.x + 5 * (parseStoreDir() - parseStoreDir());
      this.pos.y = obj.y + 5 * (parseStoreDir() - parseStoreDir());
      this.old.x = this.pos.x;
      this.old.y = this.pos.y;
      this.vel.y = 11 * (parseStoreDir() - parseStoreDir());
      this.vel.x = 11 * (parseStoreDir() - parseStoreDir());
      this.radius = 2 * parseStoreDir() * 5;
      this.angle = 6.2 * parseStoreDir();
      this.speed = 1 * parseStoreDir() - 1 * parseStoreDir();
      this.friction = 0.05;
    }
    var CropAreaRectangle = (saveNotifs("../math/cartesian"), saveNotifs("./mass"));
    var parseStoreDir = (saveNotifs("./spring"), Math.random);
    var pow = Math.pow;
    var min = Math.sqrt;
    var cos = Math.cos;
    var sin = Math.sin;
    var p = [1, 0.7, 0.8, 0.9, 0.5, 1, 0.7, 1];
    var self = init.prototype = new CropAreaRectangle;
    self.massInit = self.init;
    self.massUpdate = self.update;
    self.color = "black";
    self.drive = function(x, y) {
      var intrinsicDim = this.vel;
      var pos = this.pos;
      this.speed = (x * intrinsicDim.x + y * intrinsicDim.y) / this.radius;
      this.angle += this.speed;
      var speed = -(x * intrinsicDim.x + y * intrinsicDim.y) * this.friction;
      pos.x += x * speed;
      pos.y += y * speed;
      var scale = min(pow(x, 2) + pow(y, 2));
      if (scale > 0) {
        var width = -y / scale;
        var height = x / scale;
        var delta = 0.8 * (width * intrinsicDim.x + height * intrinsicDim.y);
        this.old.x += width * delta;
        this.old.y += height * delta;
      }
    };
    self.update = function() {
      {
        var scene = this.scene;
        scene.settings;
      }
      this.angle += this.speed;
      this.massUpdate();
    };
    self.draw = function() {
      var point = this.scene.screen;
      var camera = this.scene.camera;
      var x = point.realToScreen(this.pos.x, "x");
      var y = point.realToScreen(this.pos.y, "y");
      var minidx = 0;
      var zoom = camera.zoom;
      var angle = this.angle;
      var r = p[0] * zoom * this.radius;
      var right = x + r * cos(angle);
      var top = y + r * sin(angle);
      var ctx = this.scene.game.canvas.getContext("2d");
      ctx.lineWidth = 1 * zoom;
      ctx.strokeStyle = "#000000";
      ctx.beginPath();
      ctx.moveTo(right, top);
      ctx.fillStyle = this.color;
      for (; minidx++ < 8;) {
        r = p[minidx - 1] * zoom * this.radius;
        right = x + r * cos(angle + 6.283 * minidx / 8);
        top = y + r * sin(angle + 6.283 * minidx / 8);
        ctx.lineTo(right, top);
      }
      ctx.fill();
      ctx.stroke();
    };
    context.exports = init;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./spring" : 83
  }],
  75 : [function(require, context) {
    function init(options, data) {
      this.time = 20;
      this.gravity = new Vector2(0, 0.3);
      this.scene = data;
      this.createMasses(options);
      this.positionX = options.x;
      this.positionY = options.y;
    }
    var Vector2 = require("../math/cartesian");
    var ResumeFamilyName = (require("./mass"), require("./debris"));
    var draw_axis = (require("./spring"), Math.random);
    var cos = Math.cos;
    var sin = Math.sin;
    var proto = init.prototype;
    proto.vehicleInit = proto.init;
    proto.complete = false;
    proto.time = 0;
    proto.powerupsEnabled = false;
    proto.draw = function(value) {
      var t = this.time;
      var e = this.positionX;
      var val = this.positionY;
      var d = this.scene.camera.zoom;
      var point = this.scene.screen;
      var ctx = this.scene.game.canvas.getContext("2d");
      if (ctx.globalAlpha = value, t > 0) {
        t = t - 10;
        var y = point.realToScreen(e, "x");
        var a = point.realToScreen(val, "y");
        var p = 0;
        var theta = 6.2 * draw_axis();
        var r = t * d;
        var top = y + r * cos(theta);
        var b = a + r * sin(theta);
        ctx.lineWidth = 0;
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(top, b);
        ctx.fillStyle = "black";
        for (; p++ < 16;) {
          r = (t + 30 * draw_axis()) * d;
          top = y + r * cos(theta + 6.283 * p / 16);
          b = a + r * sin(theta + 6.283 * p / 16);
          ctx.lineTo(top, b);
        }
        ctx.fill();
        ctx.stroke();
      }
      var dots = this.masses;
      var i;
      for (i in dots) {
        dots[i].draw();
      }
      ctx.globalAlpha = 1;
      this.time = t;
    };
    proto.createMasses = function(item) {
      this.masses = [];
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
      this.masses.push(new ResumeFamilyName(item, this, "#000000"));
    };
    proto.update = function() {
      var playerIndicators = this.masses;
      var i;
      for (i in playerIndicators) {
        playerIndicators[i].update();
      }
    };
    context.exports = init;
  }, {
    "../math/cartesian" : 14,
    "./debris" : 74,
    "./mass" : 77,
    "./spring" : 83
  }],
  76 : [function(require, asset) {
    function i(a, e, i) {
      this.vehicleInit(a);
      this.createMasses(e);
      this.createSprings();
      this.createCockpit();
      this.updateCameraFocalPoint();
      this.stopSounds();
      if (-1 === i) {
        this.swap();
      }
    }
    var Date = require("../math/cartesian");
    var $ = require("./mass");
    var Color = require("./spring");
    var EventManager = require("./vehicle");
    var Value = require("./prop");
    var filter = (require("./ragdoll"), Math.PI, Math.atan2);
    var min = Math.min;
    var s = {
      HELICOPTER : "helicopter"
    };
    var self = i.prototype = new EventManager;
    self.vehicleName = "Helicopter";
    self.vehicleInit = self.init;
    self.vehicleUpdate = self.update;
    self.vehicleDraw = self.draw;
    self.masses = null;
    self.springs = null;
    self.slow = false;
    self.swapped = false;
    self.createCockpit = function() {
      var textedCanvas = document.createElement("canvas");
      this.canvasCockpit = textedCanvas;
    };
    self.drawCockpit = function() {
      var imgDataCanvas = this.canvasCockpit;
      var points = this.masses;
      var s = this.scene;
      var scale = s.camera.zoom;
      var radius = points[0].radius * scale * 0.9;
      var w = 50 * scale;
      var h = 50 * scale;
      imgDataCanvas.width = w;
      imgDataCanvas.height = h;
      var x = 0;
      var r = 0;
      var centerLineWidth = Math.max(2 * scale, 1);
      var ctx = imgDataCanvas.getContext("2d");
      ctx.save();
      ctx.translate(w / 2, h / 2);
      ctx.scale(1.3, 1);
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, 1.5 * Math.PI, false);
      ctx.lineTo(x, r);
      ctx.lineTo(x + radius, r);
      ctx.closePath();
      ctx.restore();
      ctx.fillStyle = "#000000";
      ctx.fill();
      ctx.lineWidth = centerLineWidth;
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.save();
      ctx.translate(w / 2, h / 2);
      ctx.scale(1.3, 1);
      ctx.beginPath();
      ctx.arc(x, r, radius, 0, 1.5 * Math.PI, true);
      ctx.restore();
      ctx.lineWidth = centerLineWidth;
      ctx.strokeStyle = "black";
      ctx.stroke();
    };
    self.createMasses = function(b) {
      var obj = [];
      obj.push(new Value(new Date(b.x + 0, b.y + 18), this));
      var service = new $;
      var r = new $;
      var field = new $;
      var h = new $;
      service.init(new Date(b.x + -17, b.y + 42), this);
      r.init(new Date(b.x + 17, b.y + 42), this);
      field.init(new Date(b.x + -40, b.y + 15), this);
      h.init(new Date(b.x + 40, b.y + 15), this);
      obj.push(service);
      obj.push(r);
      obj.push(field);
      obj.push(h);
      obj[0].radius = 18;
      obj[1].radius = 8;
      obj[2].radius = 8;
      obj[3].grav = false;
      obj[4].grav = obj[4].collide = false;
      obj[1].friction = 0.2;
      obj[2].friction = 0.2;
      this.head = obj[0];
      this.mass2 = obj[1];
      this.mass3 = obj[2];
      this.mass4 = obj[3];
      this.rotor = 0;
      this.rotor2 = 0;
      this.dir = 1;
      var metrics = this;
      obj[3].drive = this.head.drive = function() {
        metrics.explode();
      };
      this.focalPoint = obj[0];
      this.masses = obj;
    };
    self.createSprings = function() {
      var clr = this.masses;
      var pixels = [];
      pixels.push(new Color(clr[0], clr[1], this));
      pixels.push(new Color(clr[2], clr[0], this));
      pixels.push(new Color(clr[2], clr[1], this));
      pixels.push(new Color(clr[0], clr[3], this));
      pixels.push(new Color(clr[1], clr[3], this));
      pixels.push(new Color(clr[0], clr[4], this));
      pixels.push(new Color(clr[2], clr[4], this));
      this.spring1 = pixels[0];
      this.spring2 = pixels[1];
      this.spring3 = pixels[2];
      this.spring4 = pixels[3];
      this.spring5 = pixels[4];
      this.spring6 = pixels[5];
      this.spring7 = pixels[6];
      pixels[0].leff = pixels[4].lrest = 30;
      pixels[1].leff = pixels[4].lrest = 30;
      pixels[2].leff = pixels[4].lrest = 35;
      pixels[4].leff = pixels[4].lrest = 35;
      pixels[6].leff = pixels[4].lrest = 35;
      var i;
      for (i in pixels) {
        pixels[i].dampConstant = 0.4;
      }
      for (i in pixels) {
        pixels[i].springConstant = 0.5;
      }
      this.springs = pixels;
    };
    self.updateCameraFocalPoint = function() {
    };
    self.update = function() {
      if (this.crashed === false && (this.updateSound(), this.control()), this.explosion) {
        this.explosion.update();
      } else {
        var springs = this.springs;
        var numClasses = springs.length;
        var i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        var _volumes = this.masses;
        var len = _volumes.length;
        var j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
        if ((this.masses[1].contact || this.masses[2].contact) && (this.slow = false), this.slow === false) {
          if (this.crashed === false) {
            this.control();
          }
          i = numClasses - 1;
          for (; i >= 0; i--) {
            springs[i].update();
          }
          j = len - 1;
          for (; j >= 0; j--) {
            _volumes[j].update();
          }
        }
        this.updateCockpitAngle();
      }
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        var sound = this.scene.sound;
        var fn = min(this.head.motor, 1);
        sound.play(s.HELICOPTER, fn);
      }
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.HELICOPTER);
    };
    self.swap = function() {
      var dir = this.dir;
      var springs = this.springs;
      var d = this.masses;
      dir = -1 * dir;
      springs[2].swap();
      var target = new Date(0, 0);
      var r = new Date(0, 0);
      var v = new Date(0, 0);
      target.equ(d[3].pos);
      r.equ(d[3].old);
      v.equ(d[3].vel);
      d[3].pos.equ(d[4].pos);
      d[3].old.equ(d[4].old);
      d[3].vel.equ(d[4].vel);
      d[4].pos.equ(target);
      d[4].old.equ(r);
      d[4].vel.equ(v);
      this.dir = dir;
    };
    self.control = function() {
      var assert = this.player.getGamepad();
      var result = assert.isButtonDown("up");
      var i = (assert.isButtonDown("down"), assert.isButtonDown("back"));
      var left = assert.isButtonDown("left");
      var isRightArray = assert.isButtonDown("right");
      var flagZ = assert.isButtonDown("z");
      var list = this.masses;
      var pos = this.springs;
      if (flagZ && !this.swapped) {
        this.swap();
        this.swapped = true;
      }
      if (!flagZ) {
        this.swapped = false;
      }
      var b = list[1].pos.add(list[2].pos).factor(0.5);
      b = list[0].pos.sub(b);
      b = b.factor(1 / b.len());
      list[0].angle.equ(b);
      var method = result ? 1 : 0;
      list[0].motor += (method - list[0].motor) / 10;
      var angle = left ? 1 : 0;
      angle = angle + (isRightArray ? -1 : 0);
      pos[2].rotate(angle / 6);
      if (i) {
        this.scene.restartTrack = true;
      }
    };
    self.updateCockpitAngle = function() {
      var t = this.masses;
      var pos = t[0].pos;
      var xy = t[3].pos;
      var p = pos.x;
      var offset = pos.y;
      var x = xy.x;
      var y = xy.y;
      var a = p - x;
      var ratio = offset - y;
      this.cockpitAngle = -(filter(a, ratio) - Math.PI / 2);
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw(1);
      } else {
        var ctx = this.scene.game.canvas.getContext("2d");
        ctx.imageSmoothingEnabled = true;
        ctx.webkitImageSmoothingEnabled = true;
        ctx.mozImageSmoothingEnabled = true;
        ctx.globalAlpha = this.player._opacity;
        var shapes = this.masses;
        var y = this.dir;
        var argpp = this.rotor;
        var theta = this.rotor2;
        var s = this.scene;
        var scale = s.camera.zoom;
        var size = shapes[1].pos.add(shapes[2].pos).factor(0.5);
        size = shapes[0].pos.sub(size).factor(scale);
        var slopeV = new Date(-size.y * y, size.x * y);
        var line = shapes[0].pos.toScreen(s);
        argpp = argpp + (0.5 * shapes[0].motor + 0.05);
        if (argpp > 6.2831) {
          argpp = argpp - 6.2831;
        }
        theta = theta + 0.5;
        if (theta > 6.2831) {
          theta = theta - 6.2831;
        }
        this.rotor = argpp;
        this.rotor2 = theta;
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 5 * scale;
        ctx.beginPath();
        ctx.moveTo(line.x + 0.5 * size.x, line.y + 0.5 * size.y);
        ctx.lineTo(line.x + 0.8 * size.x, line.y + 0.8 * size.y);
        ctx.stroke();
        ctx.lineWidth = 3 * scale;
        ctx.beginPath();
        var aMag = 0.9 * Math.cos(argpp);
        ctx.moveTo(line.x + 0.9 * size.x + slopeV.x * aMag, line.y + 0.8 * size.y + slopeV.y * aMag);
        ctx.lineTo(line.x + 0.9 * size.x - slopeV.x * aMag, line.y + 0.8 * size.y - slopeV.y * aMag);
        ctx.stroke();
        var parse = shapes[1].pos.toScreen(s);
        var r = shapes[2].pos.toScreen(s);
        ctx.lineWidth = 4 * scale;
        ctx.stokeStyle = "#666666";
        ctx.beginPath();
        ctx.moveTo(parse.x - 0.2 * slopeV.x - 0.1 * size.x, parse.y - 0.2 * slopeV.y - 0.1 * size.y);
        ctx.lineTo(parse.x - 0.25 * size.x, parse.y - 0.25 * size.y);
        ctx.lineTo(r.x - 0.25 * size.x, r.y - 0.25 * size.y);
        ctx.lineTo(r.x + 0.2 * slopeV.x - 0.1 * size.x, r.y + 0.2 * slopeV.y - 0.1 * size.y);
        ctx.stroke();
        ctx.lineWidth = 3 * scale;
        ctx.beginPath();
        ctx.moveTo(parse.x - 0.2 * size.x, parse.y - 0.2 * size.y);
        ctx.lineTo(line.x, line.y);
        ctx.lineTo(r.x - 0.2 * size.x, r.y - 0.2 * size.y);
        ctx.stroke();
        ctx.lineWidth = 6 * scale;
        ctx.stokeStyle = "#000000";
        ctx.beginPath();
        var data = shapes[3].pos.toScreen(s);
        ctx.moveTo(line.x, line.y);
        ctx.lineTo(data.x, data.y);
        ctx.lineTo(line.x - 0.1 * size.x, line.y - 0.3 * size.y);
        ctx.stroke();
        ctx.lineWidth = 2 * scale;
        ctx.stokeStyle = "#000000";
        ctx.beginPath();
        var v = 7 * scale;
        var e = new Date(v * Math.sin(-theta), v * Math.cos(-theta));
        ctx.moveTo(data.x + e.x, data.y + e.y);
        ctx.lineTo(data.x - e.x, data.y - e.y);
        ctx.moveTo(data.x - e.y, data.y + e.x);
        ctx.lineTo(data.x + e.y, data.y - e.x);
        ctx.stroke();
        ctx.beginPath();
        ctx.lineWidth = 2 * scale;
        ctx.arc(data.x, data.y, shapes[3].radius * scale, 0, 2 * Math.PI, false);
        ctx.stroke();
        {
          line.x;
          line.y;
        }
        this.drawCockpit();
        var gradientImage = this.canvasCockpit;
        var w = gradientImage.width;
        var h = gradientImage.height;
        var x = line.x + 5 * scale * this.dir;
        var height = line.y + 2 * scale;
        var i = 0;
        var wh = 0;
        var width = w;
        var oh = h;
        var imageOffsetX = i * scale - width / 2;
        var imageOffsetY = wh * scale - oh / 2;
        var rotation = this.cockpitAngle;
        var isVertical = -1 === y;
        var to = this.cosmetics;
        var context = GameInventoryManager.getItem(to.head);
        var callback = this.cockpitAngle;
        context.draw(ctx, x + 5 * scale * y, height - 5 * scale, callback, 0.7 * scale, y);
        ctx.translate(x, height);
        ctx.rotate(rotation);
        if (isVertical) {
          ctx.scale(1, -1);
        }
        ctx.drawImage(gradientImage, imageOffsetX, imageOffsetY, width, oh);
        if (isVertical) {
          ctx.scale(1, -1);
        }
        ctx.rotate(-rotation);
        ctx.translate(-x, -height);
        ctx.globalAlpha = 1;
      }
    };
    asset.exports = i;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./prop" : 81,
    "./ragdoll" : 82,
    "./spring" : 83,
    "./vehicle" : 85
  }],
  77 : [function(saveNotifs, blob) {
    function data() {
    }
    var Vec3 = saveNotifs("../math/cartesian");
    data.prototype = {
      pos : null,
      old : null,
      vel : null,
      parent : null,
      radius : 0,
      friction : 0,
      collide : false,
      contact : false,
      scene : null,
      drawPos : null,
      init : function(target, node) {
        this.pos = new Vec3;
        this.old = new Vec3;
        this.vel = new Vec3(0, 0);
        this.drawPos = new Vec3(0, 0);
        this.radius = 10;
        this.friction = 0;
        this.parent = node;
        this.collide = true;
        this.contact = false;
        this.scene = node.scene;
        this.pos.equ(target);
        this.old.equ(target);
      },
      drive : function(x, y) {
        var friction = this.friction;
        var resolutionScale = -(x * this.vel.x + y * this.vel.y) * friction;
        x = x * resolutionScale;
        y = y * resolutionScale;
        this.pos.x += x;
        this.pos.y += y;
        this.contact = true;
      },
      update : function() {
        var args = this.vel;
        args.inc(this.parent.gravity);
        var pt = this.parent.gravity;
        if (0 != pt.x || 0 != pt.y) {
          args.x = 0.99 * args.x;
          args.y = 0.99 * args.y;
        }
        this.pos.inc(this.vel);
        this.contact = false;
        if (this.collide) {
          this.scene.track.collide(this);
        }
        args.x = this.pos.x - this.old.x;
        args.y = this.pos.y - this.old.y;
        this.old.equ(this.pos);
      },
      draw : function() {
        var obj = this.pos.toScreen(this.scene);
        var ctx = this.scene.game.canvas.getContext("2d");
        var SCALE = (this.radius, this.scene.camera.zoom);
        ctx.beginPath();
        ctx.fillStyle = "rgba(0,0,0,1)";
        ctx.arc(obj.x, obj.y, this.radius * SCALE, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.closePath();
      }
    };
    blob.exports = data;
  }, {
    "../math/cartesian" : 14
  }],
  78 : [function(require, asset) {
    var i = function(v, i, s, e) {
      this.color = "rgba(0,0,0,1)";
      this.vehicleInit(v);
      this.createMasses(i, e);
      this.createSprings();
      this.updateCameraFocalPoint();
      this.stopSounds();
      if (-1 === s) {
        this.swap();
      }
    };
    asset.exports = i;
    var Vector = require("../math/cartesian");
    var VRObject = require("./mass");
    var Set = require("./spring");
    var EventManager = require("./vehicle");
    var Box = require("./wheel");
    var TagHourlyStat = require("./ragdoll");
    var coveredByRange = (require("../cosmetics/heads/head"), require("../cosmetics/heads/forward_cap"), Math.atan2);
    var round = Math.min;
    var nativeFloor = Math.floor;
    var nativeRandom = Math.random;
    var s = {
      BIKE_GROUND : "bike_ground",
      BIKE_AIR : "bike_air",
      BIKE_FALL_1 : "bike_fall_1",
      BIKE_FALL_2 : "bike_fall_2",
      BIKE_FALL_3 : "bike_fall_3"
    };
    var self = i.prototype = new EventManager;
    self.vehicleName = "MTB";
    self.vehicleInit = self.init;
    self.vehicleUpdate = self.update;
    self.vehicleControl = self.control;
    self.vehicleDraw = self.draw;
    self.masses = null;
    self.springs = null;
    self.cosmetics = null;
    self.slow = false;
    self.pedala = 0;
    self.swapped = false;
    self.ragdoll = null;
    self.crashed = false;
    self.createMasses = function(b, m) {
      this.masses = [];
      var obj = new VRObject;
      var rect = new Box(new Vector(b.x + 23, b.y), this);
      var settings = new Box(new Vector(b.x + -23, b.y), this);
      obj.init(new Vector(b.x + 2, b.y + -38), this);
      obj.drive = this.createRagdoll.bind(this);
      settings.radius = 14;
      rect.radius = 14;
      obj.radius = 14;
      obj.vel.equ(m);
      settings.vel.equ(m);
      rect.vel.equ(m);
      this.masses.push(obj);
      this.masses.push(settings);
      this.masses.push(rect);
      this.head = obj;
      this.frontWheel = rect;
      this.rearWheel = settings;
    };
    self.createSprings = function() {
      this.springs = [];
      var obj = new Set(this.head, this.rearWheel, this);
      var items = new Set(this.rearWheel, this.frontWheel, this);
      var options = new Set(this.frontWheel, this.head, this);
      items.lrest = 45;
      items.leff = 45;
      items.springConstant = 0.2;
      items.dampConstant = 0.3;
      obj.lrest = 47;
      obj.leff = 47;
      obj.springConstant = 0.2;
      obj.dampConstant = 0.3;
      options.lrest = 45;
      options.leff = 45;
      options.springConstant = 0.2;
      options.dampConstant = 0.3;
      this.springs.push(obj);
      this.springs.push(items);
      this.springs.push(options);
      this.rearSpring = obj;
      this.chasse = items;
      this.frontSpring = options;
    };
    self.createRagdoll = function() {
      this.ragdoll = new TagHourlyStat(this.getStickMan(), this);
      this.ragdoll.zero(this.head.vel, this.rearWheel.vel);
      this.ragdoll.dir = this.dir;
      this.rearWheel.motor = 0;
      this.rearWheel.brake = false;
      this.frontWheel.brake = false;
      this.head.collide = false;
      if (this.player.isInFocus()) {
        this.playBailSound();
      }
      this.dead();
    };
    self.playBailSound = function() {
      var sound = this.scene.sound;
      var offset = round(this.speed / 50, 1);
      var i = nativeFloor(3 * nativeRandom()) + 1;
      switch(i) {
        case 1:
          sound.play(s.BIKE_FALL_1, offset);
          break;
        case 2:
          sound.play(s.BIKE_FALL_2, offset);
          break;
        case 3:
          sound.play(s.BIKE_FALL_3, offset);
      }
    };
    self.updateCameraFocalPoint = function() {
      this.focalPoint = this.ragdoll ? this.ragdoll.head : this.head;
    };
    self.getStickMan = function() {
      var s = this.dir;
      var e = this.head;
      var world = this.frontWheel;
      var particle = this.rearWheel;
      var bearingRad = this.pedala;
      var a = world.pos.sub(particle.pos);
      var furthestExtent = e.pos.sub(world.pos.add(particle.pos).factor(0.5));
      var offset = new Vector(a.y * s, -a.x * s);
      var that = {};
      that.head = particle.pos.add(a.factor(0.35)).add(furthestExtent.factor(1.2));
      that.lHand = that.rHand = particle.pos.add(a.factor(0.8)).add(offset.factor(0.68));
      var p = that.head.sub(that.lHand);
      p = new Vector(p.y * s, -p.x * s);
      that.lElbow = that.rElbow = that.head.add(that.lHand).factor(0.5).add(p.factor(130 / p.lenSqr()));
      that.waist = particle.pos.add(a.factor(0.2)).add(offset.factor(0.5));
      var end = new Vector(6 * Math.cos(bearingRad), 6 * Math.sin(bearingRad));
      return that.lFoot = particle.pos.add(a.factor(0.4)).add(offset.factor(0.05)).add(end), p = that.waist.sub(that.lFoot), p = new Vector(-p.y * s, p.x * s), that.lKnee = that.waist.add(that.lFoot).factor(0.5).add(p.factor(160 / p.lenSqr())), that.rFoot = particle.pos.add(a.factor(0.4)).add(offset.factor(0.05)).sub(end), p = that.waist.sub(that.rFoot), p = new Vector(-p.y * s, p.x * s), that.rKnee = that.waist.add(that.rFoot).factor(0.5).add(p.factor(160 / p.lenSqr())), that;
    };
    self.update = function() {
      if (this.crashed === false && (this.updateSound(), this.control()), this.explosion) {
        this.explosion.update();
      } else {
        var springs = this.springs;
        var numClasses = springs.length;
        var i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        var _volumes = this.masses;
        var len = _volumes.length;
        var j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
        if (this.rearWheel.contact && this.frontWheel.contact && (this.slow = false), this.slow === false) {
          if (this.crashed === false) {
            this.control();
          }
          i = numClasses - 1;
          for (; i >= 0; i--) {
            springs[i].update();
          }
          j = len - 1;
          for (; j >= 0; j--) {
            _volumes[j].update();
          }
        }
        if (this.ragdoll) {
          this.ragdoll.update();
        } else {
          this.updateDrawHeadAngle();
        }
      }
      this.updateCameraFocalPoint();
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        this.updateSpeed();
        var offset = round(this.speed / 50, 1);
        var sound = this.scene.sound;
        if (this.rearWheel.contact || this.frontWheel.contact) {
          sound.play(s.BIKE_GROUND, offset);
          sound.stop(s.BIKE_AIR);
        } else {
          sound.play(s.BIKE_AIR, offset);
          sound.stop(s.BIKE_GROUND);
        }
      }
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.BIKE_AIR);
      sound.stop(s.BIKE_GROUND);
    };
    self.updateDrawHeadAngle = function() {
      var o = this.frontWheel.pos;
      var pos = this.rearWheel.pos;
      var i = o.x;
      var size = o.y;
      var length = pos.x;
      var row = pos.y;
      var start = i - length;
      var end = size - row;
      this.drawHeadAngle = -(coveredByRange(start, end) - Math.PI / 2);
    };
    self.swap = function() {
      this.dir = -1 * this.dir;
      this.chasse.swap();
      var t = this.rearSpring.leff;
      this.rearSpring.leff = this.frontSpring.leff;
      this.frontSpring.leff = t;
    };
    self.control = function() {
      var assert = this.gamepad;
      var result = assert.isButtonDown("up");
      var down = assert.isButtonDown("down");
      var isBigEndian = (assert.isButtonDown("back"), assert.isButtonDown("left"));
      var up = assert.isButtonDown("right");
      var flagZ = assert.isButtonDown("z");
      var newPos = result ? 1 : 0;
      var self = this.rearWheel;
      self.motor += (newPos - self.motor) / 10;
      if (flagZ && !this.swapped) {
        this.swap();
        this.swapped = true;
      }
      if (!flagZ) {
        this.swapped = false;
      }
      if (result) {
        this.pedala += this.rearWheel.speed / 5;
      }
      self.brake = down;
      this.frontWheel.brake = this.dir > 0 && up && down ? true : this.dir < 0 && isBigEndian && down ? true : false;
      var iInteger = isBigEndian ? 1 : 0;
      iInteger = iInteger + (up ? -1 : 0);
      this.rearSpring.contract(5 * iInteger * this.dir, 5);
      this.frontSpring.contract(5 * -iInteger * this.dir, 5);
      this.chasse.rotate(iInteger / 8);
      if (!iInteger && result) {
        this.rearSpring.contract(-7, 5);
        this.frontSpring.contract(7, 5);
      }
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw(1);
      } else {
        var ctx = this.scene.game.canvas.getContext("2d");
        if (ctx.imageSmoothingEnabled = true, ctx.mozImageSmoothingEnabled = true, ctx.oImageSmoothingEnabled = true, ctx.webkitImageSmoothingEnabled = true, this.settings.developerMode) {
          var s = this.masses;
          var i = s.length;
          var l = i - 1;
          for (; l >= 0; l--) {
            s[l].draw();
          }
        }
        this.drawBikeFrame();
      }
    };
    self.drawBikeFrame = function() {
      var e = this.scene;
      var d = this.frontWheel.pos.toScreen(e);
      var self = this.rearWheel.pos.toScreen(e);
      var md = this.head.pos.toScreen(e);
      var scale = (e.game.pixelRatio, e.camera.zoom);
      var ctx = e.game.canvas.getContext("2d");
      var opacity = this.player._opacity;
      var result = d.sub(self);
      var origin = new Vector((d.y - self.y) * this.dir, (self.x - d.x) * this.dir);
      var projection = result.factor(0.5);
      self.addOut(projection, projection);
      md.subOut(projection, projection);
      ctx.globalAlpha = opacity;
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 3 * scale;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      ctx.fillStyle = "rgba(200,200, 200,0.2)";
      ctx.arc(d.x, d.y, 12.5 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(self.x, self.y, 12.5 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.strokeStyle = "rgba(153, 153, 153,1)";
      ctx.fillStyle = "rgba(204, 204, 204,1)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(d.x, d.y, 6 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(self.x, self.y, 6 * scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 5 * scale;
      ctx.moveTo(self.x, self.y);
      ctx.lineTo(self.x + 0.4 * result.x + 0.05 * origin.x, self.y + 0.4 * result.y + 0.05 * origin.y);
      ctx.moveTo(self.x + 0.72 * result.x + 0.64 * projection.x, self.y + 0.72 * result.y + 0.64 * projection.y);
      ctx.lineTo(self.x + 0.46 * result.x + 0.4 * projection.x, self.y + 0.46 * result.y + 0.4 * projection.y);
      ctx.lineTo(self.x + 0.4 * result.x + 0.05 * origin.x, self.y + 0.4 * result.y + 0.05 * origin.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 2 * scale;
      ctx.strokeStyle = "#000000";
      ctx.moveTo(self.x + 0.72 * result.x + 0.64 * projection.x, self.y + 0.72 * result.y + 0.64 * projection.y);
      ctx.lineTo(self.x + 0.43 * result.x + 0.05 * origin.x, self.y + 0.43 * result.y + 0.05 * origin.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 1 * scale;
      ctx.moveTo(self.x + 0.46 * result.x + 0.4 * projection.x, self.y + 0.46 * result.y + 0.4 * projection.y);
      ctx.lineTo(self.x + 0.28 * result.x + 0.5 * projection.x, self.y + 0.28 * result.y + 0.5 * projection.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 2 * scale;
      ctx.moveTo(self.x + 0.45 * result.x + 0.3 * projection.x, self.y + 0.45 * result.y + 0.3 * projection.y);
      ctx.lineTo(self.x + 0.3 * result.x + 0.4 * projection.x, self.y + 0.3 * result.y + 0.4 * projection.y);
      ctx.lineTo(self.x + 0.25 * result.x + 0.6 * projection.x, self.y + 0.25 * result.y + 0.6 * projection.y);
      ctx.moveTo(self.x + 0.17 * result.x + 0.6 * projection.x, self.y + 0.17 * result.y + 0.6 * projection.y);
      ctx.lineTo(self.x + 0.3 * result.x + 0.6 * projection.x, self.y + 0.3 * result.y + 0.6 * projection.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 3 * scale;
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(self.x + 0.71 * result.x + 0.73 * projection.x, self.y + 0.71 * result.y + 0.73 * projection.y);
      ctx.lineTo(self.x + 0.73 * result.x + 0.77 * projection.x, self.y + 0.73 * result.y + 0.77 * projection.y);
      ctx.lineTo(self.x + 0.7 * result.x + 0.8 * projection.x, self.y + 0.7 * result.y + 0.8 * projection.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 1 * scale;
      var offset = new Vector(6 * Math.cos(this.pedala) * scale, 6 * Math.sin(this.pedala) * scale);
      if (ctx.moveTo(self.x + 0.43 * result.x + 0.05 * origin.x + offset.x, self.y + 0.43 * result.y + 0.05 * origin.y + offset.y), ctx.lineTo(self.x + 0.43 * result.x + 0.05 * origin.x - offset.x, self.y + 0.43 * result.y + 0.05 * origin.y - offset.y), ctx.stroke(), this.crashed) {
        if (this.ragdoll) {
          this.ragdoll.draw();
        }
      } else {
        result.factorOut(0.5, origin);
        self.addOut(origin, origin);
        md.subOut(origin, origin);
        var line = result.factor(0.3);
        line.x = self.x + line.x + 0.25 * origin.x;
        line.y = self.y + line.y + 0.25 * origin.y;
        var d = result.factor(0.4);
        d.x = self.x + d.x + 0.05 * origin.x;
        d.y = self.y + d.y + 0.05 * origin.y;
        var a = d.add(offset);
        var pos = d.sub(offset);
        var c = result.factor(0.67);
        c.x = self.x + c.x + 0.8 * origin.x;
        c.y = self.y + c.y + 0.8 * origin.y;
        var point = result.factor(-0.05);
        point.x = line.x + point.x + 0.42 * origin.x;
        point.y = line.y + point.y + 0.42 * origin.y;
        var t = a.sub(point);
        var steps = t.lenSqr();
        projection.x = t.y * this.dir;
        projection.y = -t.x * this.dir;
        projection.factorSelf(scale * scale);
        var bounds = t.factor(0.5);
        bounds.x = point.x + bounds.x + projection.x * (200 / t.lenSqr());
        bounds.y = point.y + bounds.y + projection.y * (200 / t.lenSqr());
        var b = t.factor(0.12);
        b.x = a.x + b.x + projection.x * (50 / steps);
        b.y = a.y + b.y + projection.y * (50 / steps);
        pos.subOut(point, t);
        steps = t.lenSqr();
        projection.x = t.y * this.dir;
        projection.y = -t.x * this.dir;
        projection.factorSelf(scale * scale);
        var nextPoint = t.factor(0.5);
        nextPoint.x = point.x + nextPoint.x + projection.x * (200 / steps);
        nextPoint.y = point.y + nextPoint.y + projection.y * (200 / steps);
        var opt = t.factor(0.12);
        opt.x = pos.x + opt.x + projection.x * (50 / steps);
        opt.y = pos.y + opt.y + projection.y * (50 / steps);
        ctx.strokeStyle = "rgba(0,0,0," + 0.5 * opacity + ")";
        ctx.lineWidth = 6 * scale;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(nextPoint.x, nextPoint.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(opt.x, opt.y);
        ctx.stroke();
        ctx.lineWidth = 6 * scale;
        ctx.strokeStyle = "#000000";
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(bounds.x, bounds.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        var options = result.factor(0.1);
        options.x = line.x + options.x + 0.95 * origin.x;
        options.y = line.y + options.y + 0.95 * origin.y;
        ctx.lineWidth = 8 * scale;
        ctx.beginPath();
        ctx.moveTo(point.x, point.y);
        ctx.lineTo(options.x, options.y);
        ctx.stroke();
        var p = result.factor(0.2);
        p.x = line.x + p.x + 1.09 * origin.x;
        p.y = line.y + p.y + 1.09 * origin.y;
        ctx.beginPath();
        ctx.lineWidth = 2 * scale;
        options.subOut(c, result);
        var ze = result.lenSqr();
        origin.x = result.y * this.dir;
        origin.y = -result.x * this.dir;
        origin.factorSelf(scale * scale);
        var shadow = result.factor(0.3);
        shadow.x = c.x + shadow.x + origin.x * (80 / ze);
        shadow.y = c.y + shadow.y + origin.y * (80 / ze);
        ctx.lineWidth = 5 * scale;
        ctx.beginPath();
        ctx.moveTo(options.x, options.y);
        ctx.lineTo(shadow.x, shadow.y);
        ctx.lineTo(c.x, c.y);
        ctx.stroke();
        var to = this.cosmetics;
        var s = GameInventoryManager.getItem(to.head);
        var data = this.drawHeadAngle;
        s.draw(ctx, p.x, p.y, data, scale, this.dir);
        ctx.globalAlpha = 1;
      }
    };
  }, {
    "../cosmetics/heads/forward_cap" : 10,
    "../cosmetics/heads/head" : 11,
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./ragdoll" : 82,
    "./spring" : 83,
    "./vehicle" : 85,
    "./wheel" : 86
  }],
  79 : [function(require, module) {
    var self = function(options, value) {
      this.id = nextProfileItemId++;
      this._scene = options;
      this._game = options.game;
      this._user = value;
      this._settings = options.settings;
      var vehicles = options.settings.startVehicle;
      if (options.settings.track) {
        vehicles = options.settings.track.vehicle;
      }
      this._baseVehicleType = vehicles;
      this._gamepad = new BaseOverlay(options);
      this._ghost = false;
      this._color = value.color ? value.color : "#000000";
      this.setDefaults();
      this.createBaseVehicle(new Error(0, 35), 1, new Error(0, 0));
    };
    module.exports = self;
    var Error = require("../math/cartesian");
    var BaseOverlay = require("../utils/gamepad");
    var Uri = require("./explosion");
    var formats = require("./bmx");
    var View = require("./helicopter");
    var error = require("./truck");
    var union = require("./mtb");
    var number = require("./balloon");
    var intersect = require("./blob");
    var msqrt = Math.sqrt;
    var pow = Math.pow;
    var log2 = (Math.min, Math.max);
    var types = {};
    types.BMX = formats;
    types.MTB = union;
    types.HELI = View;
    types.TRUCK = error;
    types.HELI = View;
    types.BALLOON = number;
    types.BLOB = intersect;
    var nextProfileItemId = 0;
    var googleImageSize = function equals(result, value) {
      var name;
      for (name in value) {
        try {
          result[name] = value[name].constructor == Object ? equals(result[name], value[name]) : value[name];
        } catch (s) {
          result[name] = value[name];
        }
      }
      return result;
    };
    self.prototype.getCheckpointCount = function() {
      return this._checkpoints.length;
    };
    self.prototype.setDefaults = function() {
      this._baseVehicle = false;
      this._tempVehicleType = null;
      this._tempVehicle = false;
      this._tempVehicleTicks = 0;
      this._temp_vehicle_options = null;
      this._addCheckpoint = false;
      this._checkpoints = [];
      this._crashed = false;
      this._effect = false;
      this._effectTicks = 0;
      this._opacity = 1;
      this.complete = false;
      this._powerupsConsumed = {
        checkpoints : [],
        targets : [],
        misc : []
      };
    };
    self.prototype.hasCheckpoints = function() {
      return this._checkpoints.length > 0;
    };
    self.prototype.setColor = function(value) {
      this._color = value;
    };
    self.prototype.dead = function() {
      if (this._crashed = true, this._ghost === false) {
        var e = this._scene;
        var settings = e.settings;
        var description = e.message;
        e.state.playerAlive = this.isAlive();
        if (this._checkpoints.length > 0) {
          if (settings.mobile) {
            description.show("Tap to go to checkpoint!", false, "#000000", "#FFFFFF");
          } else {
            description.show("Press Enter For Checkpoint", false, "#000000", "#FFFFFF");
          }
        } else {
          if (settings.mobile) {
            description.show("Tap to Restart!", false, "#000000", "#FFFFFF");
          } else {
            description.show("Press Enter To Restart", false, "#000000", "#FFFFFF");
          }
        }
      }
    };
    self.prototype.setAsGhost = function() {
      this._ghost = true;
    };
    self.prototype.isGhost = function() {
      return this._ghost;
    };
    self.prototype.isAlive = function() {
      return !this._crashed;
    };
    self.prototype.getTargetsHit = function() {
      return this._powerupsConsumed.targets.length;
    };
    self.prototype.getGamepad = function() {
      return this._gamepad;
    };
    self.prototype.setBaseVehicle = function(p2) {
      this._baseVehicleType = p2;
      this.reset();
    };
    self.prototype.createBaseVehicle = function(clickRepeater, e, islongclick) {
      if (this._tempVehicle) {
        this._tempVehicle.stopSounds();
      }
      this._baseVehicle = new types[this._baseVehicleType](this, clickRepeater, e, islongclick);
      this._tempVehicle = false;
      this._tempVehicleType = false;
      this._tempVehicleTicks = 0;
    };
    self.prototype.setTempVehicle = function(NAME, next, i, val) {
      if (this._temp_vehicle_options && this._temp_vehicle_options.type === NAME) {
        next = this._temp_vehicle_options.ticks + next;
      }
      this._temp_vehicle_options = {
        type : NAME,
        ticks : next,
        position : i,
        direction : val
      };
    };
    self.prototype.createTempVehicle = function(type, end, base, filter) {
      if (this._temp_vehicle_options) {
        var options = this._temp_vehicle_options;
        type = options.type;
        end = options.ticks;
        base = options.position;
        filter = options.direction;
        this._temp_vehicle_options = null;
      }
      if (this._tempVehicleType === type) {
        this._tempVehicleTicks += end;
      } else {
        this.getActiveVehicle().stopSounds();
        this._effect = new Uri(base, this._scene);
        this._effectTicks = 45;
        this._tempVehicleType = type;
        this._tempVehicle = new types[type](this, base, filter);
        this._tempVehicleTicks = end;
      }
    };
    self.prototype.update = function() {
      if (this.complete === false) {
        var prevPageButtonSprite = this._baseVehicle;
        if (this._temp_vehicle_options) {
          this.createTempVehicle();
        }
        if (this._tempVehicleTicks > 0) {
          prevPageButtonSprite = this._tempVehicle;
          if (this._crashed === false) {
            this._tempVehicleTicks--;
          }
          if (this._tempVehicleTicks <= 0 && this._crashed === false) {
            this._effectTicks = 45;
            this._effect = new Uri(this._tempVehicle.focalPoint.pos, this._scene);
            this.createBaseVehicle(this._tempVehicle.focalPoint.pos, this._tempVehicle.dir, this._tempVehicle.masses[0].vel);
            prevPageButtonSprite = this._baseVehicle;
          }
        }
        if (this._effectTicks > 0) {
          this._effectTicks--;
          this._effect.update();
        }
        prevPageButtonSprite.update();
        if (this._addCheckpoint) {
          this._createCheckpoint();
          this._addCheckpoint = false;
        }
      }
    };
    self.prototype.isInFocus = function() {
      var camera = this._scene.camera;
      var e = false;
      return camera.playerFocus && camera.playerFocus === this && (e = true), e;
    };
    self.prototype.updateOpacity = function() {
      var opacity = 1;
      var camera = this._scene.camera;
      if (camera.playerFocus && camera.playerFocus !== this) {
        var flatness_db = this.getDistanceBetweenPlayers(camera.playerFocus);
        if (1200 > flatness_db) {
          opacity = Math.min(flatness_db / 500, 1);
        }
      }
      this._opacity = opacity;
    };
    self.prototype.drawName = function() {
      var s = this._scene;
      var parBgColor = (s.settings, this._color);
      var tempPathText = this._user.d_name;
      var base = s.game;
      var zoom = s.camera.zoom;
      var p = base.pixelRatio;
      var canvas = base.canvas;
      var ctx = canvas.getContext("2d");
      var opacity = this._opacity;
      var model = this.getActiveVehicle();
      var center = model.focalPoint.pos.toScreen(s);
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.fillStyle = parBgColor;
      ctx.moveTo(center.x, center.y - 40 * zoom);
      ctx.lineTo(center.x - 5 * zoom, center.y - 50 * zoom);
      ctx.lineTo(center.x + 5 * zoom, center.y - 50 * zoom);
      ctx.lineTo(center.x, center.y - 40 * zoom);
      ctx.fill();
      var textsize = 9 * p * log2(zoom, 1);
      ctx.font = textsize + "pt helsinki";
      ctx.textAlign = "center";
      ctx.fillStyle = parBgColor;
      ctx.fillText(tempPathText, center.x, center.y - 60 * zoom);
      ctx.globalAlpha = 1;
    };
    self.prototype.draw = function() {
      this.updateOpacity();
      var barline = this._baseVehicle;
      if (this._tempVehicleTicks > 0) {
        barline = this._tempVehicle;
      }
      if (this._effectTicks > 0) {
        this._effect.draw(this._effectTicks / 100);
      }
      barline.draw();
      if (this.isGhost()) {
        this.drawName();
      }
    };
    self.prototype.checkKeys = function() {
      var self = this._gamepad;
      var e = this._ghost;
      var scene = this._scene;
      if (e === false && (self.areKeysDown() && !this._crashed && scene.play(), self.isButtonDown("restart") && (scene.restartTrack = true, self.setButtonUp("restart")), (self.isButtonDown("up") || self.isButtonDown("down") || self.isButtonDown("left") || self.isButtonDown("right")) && scene.camera.focusOnMainPlayer()), self.isButtonDown("enter") && (this.gotoCheckpoint(), self.setButtonUp("enter")), self.isButtonDown("backspace")) {
        var backspace = self.getButtonDownOccurances("backspace");
        this.removeCheckpoint(backspace);
        self.setButtonUp("backspace");
      }
    };
    self.prototype.getDistanceBetweenPlayers = function(posnum) {
      var childCard = posnum.getActiveVehicle();
      var model = this.getActiveVehicle();
      var base = childCard.focalPoint.pos.x - model.focalPoint.pos.x;
      var height = childCard.focalPoint.pos.y - model.focalPoint.pos.y;
      return msqrt(pow(base, 2) + pow(height, 2));
    };
    self.prototype.getActiveVehicle = function() {
      var t = this._baseVehicle;
      return this._tempVehicleTicks > 0 && (t = this._tempVehicle), t;
    };
    self.prototype._createCheckpoint = function() {
      var t = {};
      if (this._tempVehicleTicks > 0) {
        t._tempVehicleType = this._tempVehicleType;
        t._tempVehicle = JSON.stringify(this._tempVehicle, this._snapshotFilter);
        t._tempVehicleTicks = this._tempVehicleTicks;
      } else {
        t._baseVehicleType = this._baseVehicleType;
        t._baseVehicle = JSON.stringify(this._baseVehicle, this._snapshotFilter);
      }
      t._powerupsConsumed = JSON.stringify(this._powerupsConsumed);
      t._crashed = this._crashed;
      this._checkpoints.push(t);
    };
    self.prototype._snapshotFilter = function(type, default_alpha) {
      switch(type) {
        case "parent":
        case "player":
        case "scene":
        case "settings":
        case "masses":
        case "springs":
        case "focalPoint":
        case "gamepad":
          return void 0;
        case "explosion":
          return false;
        default:
          return default_alpha;
      }
    };
    self.prototype.setCheckpointOnUpdate = function() {
      this._addCheckpoint = true;
    };
    self.prototype.crashed = function() {
      this._crashed = true;
    };
    self.prototype.gotoCheckpoint = function() {
      var snapshot = this._gamepad;
      var nodes = snapshot.replaying;
      var self = this._scene;
      if (this._checkpoints.length > 0) {
        var requestV1 = this._checkpoints[this._checkpoints.length - 1];
        if (requestV1._tempVehicle) {
          this._baseVehicle.stopSounds();
          var input = this._tempVehicle;
          if (this._tempVehicleType !== requestV1._tempVehicleType) {
            input = new types[requestV1._tempVehicleType](this, {
              x : 0,
              y : 0
            });
          }
          var size = JSON.parse(requestV1._tempVehicle);
          googleImageSize(input, size);
          this._tempVehicle = input;
          this._tempVehicleType = requestV1._tempVehicleType;
          this._tempVehicleTicks = requestV1._tempVehicleTicks;
          input.updateCameraFocalPoint();
        } else {
          input = this._baseVehicle;
          size = JSON.parse(requestV1._baseVehicle);
          googleImageSize(input, size);
          if (this._tempVehicle) {
            this._tempVehicle.stopSounds();
          }
          this._baseVehicle = input;
          this._tempVehicleTicks = 0;
          this._tempVehicleType = false;
          input.updateCameraFocalPoint();
        }
        if (this._powerupsConsumed = JSON.parse(requestV1._powerupsConsumed), this._crashed = requestV1._crashed, nodes === false) {
          var o = self.settings;
          self.state.playerAlive = this.isAlive();
          if (self.settings.mobile) {
            self.message.show("Tap to resume", 5, "#826cdc", "#FFFFFF");
          } else {
            self.message.show("Press Backspace To Go Back Further", 5, "#826cdc", "#FFFFFF");
          }
          self.track.updatePowerupState(this);
          if (o.waitAtCheckpoints) {
            self.state.playing = false;
          }
          self.camera.focusOnMainPlayer();
        }
        if (self.camera.playerFocus === this) {
          self.camera.fastforward();
        }
      } else {
        if (nodes === false) {
          this.restartScene();
        }
      }
    };
    self.prototype.restartScene = function() {
      var snapshot = this._gamepad;
      var nodes = snapshot.replaying;
      if (nodes === false) {
        this._scene.restartTrack = true;
      }
    };
    self.prototype.removeCheckpoint = function(name) {
      if (this._checkpoints.length > 1) {
        var MODULE_NAME = 0;
        for (; name > MODULE_NAME; MODULE_NAME++) {
          this._checkpoints.pop();
        }
        this.gotoCheckpoint();
      } else {
        this.restartScene();
      }
    };
    self.prototype.close = function() {
      this.id = null;
      this._scene = null;
      this._game = null;
      this._user = null;
      this._settings = null;
      this._baseVehicleType = null;
      this._gamepad.close();
      this._gamepad = null;
      this._baseVehicle = null;
      this._tempVehicleType = null;
      this._tempVehicle = null;
      this._tempVehicleTicks = null;
      this._addCheckpoint = null;
      this._checkpoints = null;
      this._crashed = null;
      this._effect = null;
      this._effectTicks = null;
      this._powerupsConsumed = null;
    };
    self.prototype.reset = function() {
      if (this._tempVehicle) {
        this._tempVehicle.stopSounds();
      }
      this._baseVehicle.stopSounds();
      this.setDefaults();
      this.createBaseVehicle(new Error(0, 35), 1, new Error(0, 0));
      this._gamepad.reset();
      this._scene.state.playerAlive = this.isAlive();
    };
  }, {
    "../math/cartesian" : 14,
    "../utils/gamepad" : 60,
    "./balloon" : 70,
    "./blob" : 71,
    "./bmx" : 72,
    "./explosion" : 75,
    "./helicopter" : 76,
    "./mtb" : 78,
    "./truck" : 84
  }],
  80 : [function(saveNotifs, module) {
    var self = function(data) {
      this.scene = data;
      this.game = data.game;
      this.settings = data.settings;
      this.firstPlayer = null;
      this._players = [];
      this._playerLookup = {};
    };
    module.exports = self;
    var AsteroidBelt = saveNotifs("./player");
    self.prototype.update = function() {
      var chYxis = this._players;
      var len = chYxis.length;
      var i = 0;
      for (; len > i; i++) {
        chYxis[i].update();
      }
    };
    self.prototype.mutePlayers = function() {
      var onCompleteBindings = this._players;
      var len = onCompleteBindings.length;
      var i = 0;
      for (; len > i; i++) {
        var s = onCompleteBindings[i].getActiveVehicle();
        s.stopSounds();
      }
    };
    self.prototype.updateGamepads = function() {
      var onCompleteBindings = this._players;
      var len = onCompleteBindings.length;
      var i = 0;
      for (; len > i; i++) {
        onCompleteBindings[i]._gamepad.update();
      }
    };
    self.prototype.createPlayer = function(callback, options) {
      return new AsteroidBelt(this.scene, options);
    };
    self.prototype.addPlayer = function(p) {
      this._players.push(p);
      this._playerLookup[p.id] = p;
    };
    self.prototype.checkKeys = function() {
      var onCompleteBindings = this._players;
      var len = onCompleteBindings.length;
      var i = 0;
      for (; len > i; i++) {
        onCompleteBindings[i].checkKeys();
      }
    };
    self.prototype.draw = function() {
      var s = this._players;
      var i = s.length;
      var l = 0;
      for (; i > l; l++) {
        s[l].draw();
      }
    };
    self.prototype.getPlayerByIndex = function(newOwner) {
      return this._players[newOwner];
    };
    self.prototype.getPlayerById = function(playerId) {
      return this._playerLookup[playerId];
    };
    self.prototype.getPlayerCount = function() {
      return this._players.length;
    };
    self.prototype.reset = function() {
      var forms = this._players;
      var len = forms.length;
      var i = 0;
      for (; len > i; i++) {
        forms[i].reset();
      }
    };
    self.prototype.clear = function() {
      this._players = [];
      this._playerLookup = {};
      this._players.push(this.firstPlayer);
      this._playerLookup[this.firstPlayer.id] = this.firstPlayer;
    };
    self.prototype._closePlayers = function() {
      var conns = this._players;
      var l = conns.length;
      var i = 0;
      for (; l > i; i++) {
        conns[i].close();
      }
    };
    self.prototype.close = function() {
      this._closePlayers();
      this._players = null;
      this.firstPlayer = null;
      this._playerLookup = null;
      this.scene = null;
      this.game = null;
      this.settings = null;
    };
  }, {
    "./player" : 79
  }],
  81 : [function(require, exports) {
    function initialize(a, b) {
      this.init(a, b);
      this.motor = 0;
      this.angle = new Transitionable(0, 0);
      this.radius = 10;
      this.speed = 0;
    }
    var Transitionable = require("../math/cartesian");
    var AbstractFileManager = require("./mass");
    var o = initialize.prototype = new AbstractFileManager;
    o.motor = 0;
    o.angle = 0;
    o.speed = 0;
    o.update = function() {
      var args = this.vel;
      var zoom = this.angle;
      var pos = this.pos;
      var a = this.old;
      var zoomRatio = this.motor;
      args.y += 0;
      args.inc(zoom.factor(2 * zoomRatio));
      args = args.factor(0.99);
      pos.inc(args);
      this.contact = false;
      if (this.collide) {
        this.scene.track.collide(this);
      }
      this.vel = pos.sub(a);
      a.equ(pos);
    };
    exports.exports = initialize;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77
  }],
  82 : [function(require, module) {
    function f(val, data) {
      this.parent = data;
      var c;
      var a;
      var x;
      var img;
      var result;
      var self;
      var key;
      var b;
      var value;
      var val;
      var obj = [];
      var root = [];
      var error = new Error(0, 0);
      c = new Buffer;
      a = new Buffer;
      x = new Buffer;
      img = new Buffer;
      self = new Buffer;
      result = new Buffer;
      key = new Buffer;
      b = new Buffer;
      value = new Buffer;
      val = new Buffer;
      c.init(error, data);
      a.init(error, data);
      x.init(error, data);
      img.init(error, data);
      self.init(error, data);
      result.init(error, data);
      key.init(error, data);
      b.init(error, data);
      value.init(error, data);
      val.init(error, data);
      obj.push(c);
      obj.push(a);
      obj.push(x);
      obj.push(img);
      obj.push(self);
      obj.push(result);
      obj.push(key);
      obj.push(b);
      obj.push(value);
      obj.push(val);
      root.push(new Node(c, a, this));
      root.push(new Node(c, x, this));
      root.push(new Node(x, self, this));
      root.push(new Node(c, img, this));
      root.push(new Node(img, result, this));
      root.push(new Node(a, key, this));
      root.push(new Node(key, value, this));
      root.push(new Node(a, b, this));
      root.push(new Node(b, val, this));
      var i;
      for (i in obj) {
        obj[i].radius = 3;
      }
      for (i in obj) {
        obj[i].friction = 0.05;
      }
      c.radius = a.radius = 8;
      for (i in root) {
        root[i].springConstant = 0.4;
      }
      for (i in root) {
        root[i].dampConstant = 0.7;
      }
      this.masses = obj;
      this.springs = root;
      this.head = c;
      this.waist = a;
      this.lElbow = x;
      this.rElbow = img;
      this.rHand = result;
      this.lHand = self;
      this.lKnee = key;
      this.rKnee = b;
      this.lFoot = value;
      this.rFoot = val;
      for (i in val) {
        this[i].pos.equ(val[i]);
      }
    }
    var Error = require("../math/cartesian");
    var Buffer = require("./mass");
    var Node = require("./spring");
    var C = require("./vehicle");
    var atan2 = Math.atan2;
    f.prototype = new C;
    f.prototype.init = f.prototype.initialize;
    f.prototype.parent = null;
    f.prototype.zero = function(v, a) {
      v = v.factor(0.7);
      a = a.factor(0.7);
      var newEventHandlers = this.springs;
      var teleports = this.masses;
      var i;
      for (i in newEventHandlers) {
        var r = newEventHandlers[i].m2.pos.sub(newEventHandlers[i].m1.pos).len();
        newEventHandlers[i].lrest = r;
        newEventHandlers[i].leff = r;
      }
      i = 1;
      for (; 4 >= i; i++) {
        newEventHandlers[i].lrest = 13;
        newEventHandlers[i].leff = 13;
      }
      for (i in newEventHandlers) {
        if (newEventHandlers[i].leff > 20) {
          newEventHandlers[i].lrest = 20;
          newEventHandlers[i].leff = 20;
        }
      }
      var gamestate = [this.head, this.lElbow, this.rElbow, this.lHand, this.rHand];
      var d = [this.waist, this.lKnee, this.rKnee, this.lFoot, this.rFoot];
      for (i in gamestate) {
        gamestate[i].old = gamestate[i].pos.sub(v);
      }
      for (i in d) {
        d[i].old = d[i].pos.sub(a);
      }
      for (i in teleports) {
        teleports[i].vel.equ(teleports[i].pos.sub(teleports[i].old));
        teleports[i].vel.x += 1 * (Math.random() - Math.random());
        teleports[i].vel.y += 1 * (Math.random() - Math.random());
      }
    };
    f.prototype.draw = function() {
      var node = this.head;
      var edge = this.waist;
      var precomps = this.lElbow;
      var subsynset = this.rElbow;
      var xCumPos = this.rHand;
      var healthBorderBtn = this.lHand;
      var settings = this.lKnee;
      var self = this.rKnee;
      var resultbm = this.lFoot;
      var body = this.rFoot;
      var data = this.parent.scene;
      var config = data.camera;
      var dpr = config.zoom;
      var ctx = data.game.canvas.getContext("2d");
      var f = (this.dir, this.parent.alpha);
      ctx.strokeStyle = "rgba(0,0,0," + f + ")";
      ctx.lineWidth = 5 * dpr;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      var point = node.pos.toScreen(data);
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      var dest = precomps.pos.toScreen(data);
      ctx.lineTo(dest.x, dest.y);
      var b = healthBorderBtn.pos.toScreen(data);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(0,0,0," + 0.5 * f + ")";
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      var xMax2d = subsynset.pos.toScreen(data);
      ctx.lineTo(xMax2d.x, xMax2d.y);
      var buttFrom = xCumPos.pos.toScreen(data);
      ctx.lineTo(buttFrom.x, buttFrom.y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(0,0,0," + f + ")";
      ctx.lineWidth = 8 * dpr;
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      var center = edge.pos.toScreen(data);
      ctx.lineTo(center.x, center.y);
      ctx.stroke();
      ctx.lineWidth = 5 * dpr;
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      var buttTo = settings.pos.toScreen(data);
      ctx.lineTo(buttTo.x, buttTo.y);
      var item = resultbm.pos.toScreen(data);
      ctx.lineTo(item.x, item.y);
      var opt = settings.pos.sub(edge.pos).normalize();
      opt = opt.factor(4).add(resultbm.pos);
      var to = opt.toScreen(data);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(0,0,0," + 0.5 * f + ")";
      ctx.lineWidth = 5 * dpr;
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      var ip = self.pos.toScreen(data);
      ctx.lineTo(ip.x, ip.y);
      var options = self.pos.sub(edge.pos).normalize();
      options = options.factor(4).add(body.pos);
      var code = body.pos.toScreen(data);
      ctx.lineTo(code.x, code.y);
      var p1 = options.toScreen(data);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      point.inc(point.sub(center).factor(0.25));
      ctx.lineWidth = 1 * dpr;
      ctx.strokeStyle = "rgba(0,0,0," + f + ")";
      ctx.fillStyle = "rgba(255,255,255," + f + ")";
      ctx.beginPath();
      ctx.arc(point.x, point.y, 5 * dpr, 0, 1.99999 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.strokeStyle = "rgba(0,0,0," + f + ")";
      ctx.lineWidth = 0.5 * dpr;
      ctx.beginPath();
      var obj = this.parent.cosmetics;
      var child = GameInventoryManager.getItem(obj.head);
      var callback = this.drawHeadAngle;
      child.draw(ctx, point.x, point.y, callback, dpr, this.dir, 1);
    };
    f.prototype.update = function() {
      var i = (this.springs, this.masses, this.springs.length - 1);
      for (; i >= 0; i--) {
        this.springs[i].update();
      }
      var type = this.masses.length - 1;
      for (; type >= 0; type--) {
        this.masses[type].update();
      }
      this.updateDrawHeadAngle();
    };
    f.prototype.updateDrawHeadAngle = function() {
      var s;
      var pos;
      if (this.dir < 0) {
        pos = this.head.pos;
        s = this.waist.pos;
      } else {
        s = this.head.pos;
        pos = this.waist.pos;
      }
      var p = s.x;
      var cy = s.y;
      var left = pos.x;
      var r = pos.y;
      var x = p - left;
      var y = cy - r;
      this.drawHeadAngle = -(atan2(x, y) + Math.PI);
    };
    module.exports = f;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./spring" : 83,
    "./vehicle" : 85
  }],
  83 : [function(__webpack_require__, u) {
    var Buffer = __webpack_require__("../math/cartesian");
    var o = function(e, str, value) {
      this.m1 = e;
      this.m2 = str;
      this.parent = value;
      this.lrest = 40;
      this.leff = 40;
      this.dampConstant = 0.5;
      this.springConstant = 0.7;
    };
    o.prototype = {
      m1 : null,
      m2 : null,
      parent : null,
      lrest : 40,
      leff : 40,
      dampConstant : 0,
      springConstant : 0,
      swap : function() {
        var r = new Buffer;
        var self = this.m1;
        var obj = this.m2;
        r.equ(self.pos);
        self.pos.equ(obj.pos);
        obj.pos.equ(r);
        r.equ(self.old);
        self.old.equ(obj.old);
        obj.old.equ(r);
        r.equ(self.vel);
        self.vel.equ(obj.vel);
        obj.vel.equ(r);
        var angle = self.angle;
        self.angle = obj.angle;
        obj.angle = angle;
      },
      update : function() {
        var attr = new Buffer(0, 0);
        var node = this.m1;
        var self = this.m2;
        var p = node.pos;
        var pos = self.pos;
        var bounds = node.vel;
        var rect = self.vel;
        attr.x = pos.x - p.x;
        attr.y = pos.y - p.y;
        var sizeThreshold = attr.len();
        if (!(1 > sizeThreshold)) {
          var ratio = 1 / sizeThreshold;
          attr.x *= ratio;
          attr.y *= ratio;
          var _PTM_RATIO = (sizeThreshold - this.leff) * this.springConstant;
          var transform = {
            x : attr.x * _PTM_RATIO,
            y : attr.y * _PTM_RATIO
          };
          var cos = rect.x - bounds.x;
          var sin = rect.y - bounds.y;
          var w = cos * attr.x + sin * attr.y;
          var radius = w * this.dampConstant;
          var tx = attr.x * radius;
          var ty = attr.y * radius;
          transform.x += tx;
          transform.y += ty;
          rect.x += -transform.x;
          rect.y += -transform.y;
          bounds.x += transform.x;
          bounds.y += transform.y;
        }
      },
      rotate : function(i) {
        var prevLevelVitorc = this.m1;
        var owningPlayer = this.m2;
        var newMax = owningPlayer.pos.x - prevLevelVitorc.pos.x;
        var n = owningPlayer.pos.y - prevLevelVitorc.pos.y;
        var rate = -n / this.leff;
        var m = newMax / this.leff;
        prevLevelVitorc.pos.x += rate * i;
        prevLevelVitorc.pos.y += m * i;
        owningPlayer.pos.x += rate * -i;
        owningPlayer.pos.y += m * -i;
      },
      contract : function(value, args) {
        this.leff += (this.lrest - value - this.leff) / args;
      },
      setMasses : function(formatters, customFormatters) {
        this.m1 = formatters;
        this.m2 = customFormatters;
      }
    };
    u.exports = o;
  }, {
    "../math/cartesian" : 14
  }],
  84 : [function(require, asset) {
    var i = function(a, e, i) {
      this.vehicleInit(a);
      this.createMasses(e);
      this.createSprings();
      this.stopSounds();
      this.updateCameraFocalPoint();
      if (-1 === i) {
        this.swap();
      }
    };
    asset.exports = i;
    var Logger = require("../math/cartesian");
    var UrdfVisual = require("./mass");
    var Color = require("./spring");
    var EventManager = require("./vehicle");
    var Storage = require("./wheel");
    var atan = Math.atan2;
    var min = Math.min;
    var checkIndicatorNodeWidth = (Math.floor, Math.random, Math.sqrt);
    var pow = Math.pow;
    var s = (Math.abs, {
      TRUCK_GROUND : "truck_idle"
    });
    var self = i.prototype = new EventManager;
    self.vehicleName = "TRUCK";
    self.vehicleInit = self.init;
    self.vehicleUpdate = self.update;
    self.vehicleControl = self.control;
    self.vehicleDraw = self.draw;
    self.masses = null;
    self.springs = null;
    self.cosmetics = null;
    self.slow = false;
    self.pedala = 0;
    self.swapped = false;
    self.crashed = false;
    self.createMasses = function(b) {
      this.masses = [];
      this.masses.push(new UrdfVisual);
      this.masses.push(new UrdfVisual);
      this.masses[0].init(new Logger(b.x - 15, b.y + 7), this);
      this.masses[1].init(new Logger(b.x + 15, b.y + 7), this);
      this.masses[0].friction = 0.1;
      this.masses[1].friction = 0.1;
      this.masses.push(new Storage(new Logger(b.x - 20, b.y + 35), this));
      this.masses.push(new Storage(new Logger(b.x + 20, b.y + 35), this));
      this.masses[2].radius = this.masses[3].radius = 14;
      this.masses[0].radius = this.masses[1].radius = 7;
      this.head = this.masses[0];
      this.backMass = this.masses[1];
      this.rearWheel = this.masses[2];
      this.frontWheel = this.masses[3];
    };
    self.createSprings = function() {
      this.springs = [];
      var clr = this.masses;
      this.springs.push(new Color(clr[0], clr[1], this));
      this.springs.push(new Color(clr[0], clr[2], this));
      this.springs.push(new Color(clr[1], clr[3], this));
      this.springs.push(new Color(clr[0], clr[3], this));
      this.springs.push(new Color(clr[1], clr[2], this));
      this.springs.push(new Color(clr[2], clr[3], this));
      this.springs[0].leff = this.springs[0].lrest = 30;
      this.springs[1].leff = this.springs[1].lrest = 30;
      this.springs[2].leff = this.springs[2].lrest = 30;
      this.springs[3].leff = this.springs[3].lrest = 45;
      this.springs[4].leff = this.springs[4].lrest = 45;
      var i;
      for (i in this.springs) {
        this.springs[i].springConstant = 0.3;
      }
    };
    self.updateCameraFocalPoint = function() {
    };
    self.update = function() {
      if (this.crashed === false && (this.updateSound(), this.control()), this.explosion) {
        this.explosion.update();
      } else {
        var springs = this.springs;
        var numClasses = springs.length;
        var i = numClasses - 1;
        for (; i >= 0; i--) {
          springs[i].update();
        }
        var _volumes = this.masses;
        var len = _volumes.length;
        var j = len - 1;
        for (; j >= 0; j--) {
          _volumes[j].update();
        }
        if (this.rearWheel.contact && this.frontWheel.contact && (this.slow = false), this.slow === false) {
          if (this.crashed === false) {
            this.control();
          }
          i = numClasses - 1;
          for (; i >= 0; i--) {
            springs[i].update();
          }
          j = len - 1;
          for (; j >= 0; j--) {
            _volumes[j].update();
          }
        }
        this.updateDrawHeadAngle();
        this.updateCameraFocalPoint();
      }
    };
    self.updateSound = function() {
      if (this.player.isInFocus()) {
        var sound = this.scene.sound;
        if (this.rearWheel.contact) {
          var end = min(this.rearWheel.motor, 1);
          sound.play(s.TRUCK_GROUND, end);
        } else {
          if (this.frontWheel.contact) {
            end = min(this.frontWheel.motor, 1);
            sound.play(s.TRUCK_GROUND, end);
          } else {
            sound.stop(s.TRUCK_GROUND);
          }
        }
      }
    };
    self.updateCameraFocalPoint = function() {
      this.focalPoint = 1 === this.dir ? this.head : this.backMass;
    };
    self.stopSounds = function() {
      var sound = this.scene.sound;
      sound.stop(s.TRUCK_GROUND);
    };
    self.updateDrawHeadAngle = function() {
      var pos = this.frontWheel.pos;
      var left = this.rearWheel.pos;
      var x = pos.x;
      var start = pos.y;
      var a = left.x;
      var max = left.y;
      var t = x - a;
      var n = start - max;
      this.drawHeadAngle = -(atan(t, n) - Math.PI / 2);
    };
    self.swap = function() {
      this.dir = -1 * this.dir;
      this.springs[0].swap();
      this.springs[5].swap();
    };
    self.control = function() {
      var vec3 = this.gamepad;
      var baseView = vec3.isButtonDown("up");
      var down = vec3.isButtonDown("down");
      var left = vec3.isButtonDown("left");
      var isRightArray = vec3.isButtonDown("right");
      var flagZ = vec3.isButtonDown("z");
      if (flagZ && !this.swapped) {
        this.swap();
        this.swapped = true;
      }
      if (!flagZ) {
        this.swapped = false;
      }
      var zoomLevel = baseView ? 1 : 0;
      var o = this.rearWheel;
      var self = this.frontWheel;
      o.motor += (0.8 * zoomLevel - o.motor) / 10;
      self.motor += (0.8 * zoomLevel - self.motor) / 10;
      o.brake = down;
      self.brake = down;
      var angle = left ? 1 : 0;
      angle = angle + (isRightArray ? -1 : 0);
      var pos = this.springs;
      pos[0].rotate(angle / 8);
      pos[5].rotate(angle / 8);
    };
    self.draw = function() {
      if (this.explosion) {
        this.explosion.draw(1);
      } else {
        var context = this.scene.game.canvas.getContext("2d");
        if (context.imageSmoothingEnabled = true, context.mozImageSmoothingEnabled = true, context.oImageSmoothingEnabled = true, context.webkitImageSmoothingEnabled = true, this.settings.developerMode) {
          var s = this.masses;
          var i = s.length;
          var l = i - 1;
          for (; l >= 0; l--) {
            s[l].draw();
          }
        }
        context.globalAlpha = this.player._opacity;
        this.drawTruck(context);
        context.globalAlpha = 1;
      }
    };
    self.drawTruck = function(ctx) {
      var e = this.scene;
      var z = e.camera.zoom;
      var to = this.cosmetics;
      var layer = GameInventoryManager.getItem(to.head);
      var callback = this.drawHeadAngle;
      var h = this.dir;
      var pointerAbs = this.frontWheel.pos.toScreen(e);
      var absoluteMousePosition = this.rearWheel.pos.toScreen(e);
      var p = this.head.pos.toScreen(e);
      var drop = this.backMass.pos.toScreen(e);
      var i = (this.masses[1].pos.x - this.masses[0].pos.x) * z;
      var ratio = (this.masses[1].pos.y - this.masses[0].pos.y) * z;
      var Z = (0.5 * (this.masses[0].pos.x + this.masses[1].pos.x) - 0.5 * (this.masses[2].pos.x + this.masses[3].pos.x)) * z;
      var z2 = (0.5 * (this.masses[0].pos.y + this.masses[1].pos.y) - 0.5 * (this.masses[2].pos.y + this.masses[3].pos.y)) * z;
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 3 * z;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      var base = drop.x - p.x;
      var height = drop.y - p.y;
      var width = checkIndicatorNodeWidth(pow(base, 2) + pow(height, 2));
      var x = base / width;
      var s = height / width;
      layer.draw(ctx, drop.x - 0.5 * x * z * 20, drop.y - s * z * 20 * 0.5, callback, 0.45 * z, h);
      ctx.strokeStyle = "#444444";
      ctx.beginPath();
      ctx.moveTo(p.x - 0.4 * i - 0.9 * Z, p.y - 0.4 * ratio - 0.9 * z2);
      ctx.lineTo(p.x + 0.8 * i - 0.9 * Z, p.y + 0.8 * ratio - 0.9 * z2);
      ctx.stroke();
      ctx.closePath();
      ctx.save();
      ctx.fillStyle = "#777777";
      ctx.beginPath();
      ctx.moveTo(p.x - 0.4 * i - 0.7 * Z, p.y - 0.4 * ratio - 0.7 * z2);
      ctx.lineTo(p.x - 0.4 * i - 0.7 * Z, p.y - 0.4 * ratio - 0.7 * z2);
      ctx.lineTo(p.x + 1.4 * i - 0.7 * Z, p.y + 1.4 * ratio - 0.7 * z2);
      ctx.lineTo(p.x + 1.35 * i - 0.2 * Z, p.y + 1.35 * ratio - 0.2 * z2);
      ctx.lineTo(p.x + 0.9 * i - 0.1 * Z, p.y + 0.9 * ratio - 0.1 * z2);
      ctx.lineTo(p.x + 0.5 * i - 0.1 * Z, p.y + 0.5 * ratio - 0.1 * z2);
      ctx.lineTo(p.x + 0.5 * i + 0.2 * Z, p.y + 0.5 * ratio + 0.2 * z2);
      ctx.lineTo(p.x - 0.35 * i + 0.2 * Z, p.y - 0.35 * ratio + 0.2 * z2);
      ctx.closePath();
      ctx.fill();
      ctx.save();
      ctx.lineWidth = 2 * z;
      ctx.strokeStyle = "#444444";
      ctx.beginPath();
      ctx.moveTo(p.x - 0.4 * i - 0.7 * Z, p.y - 0.4 * ratio - 0.7 * z2);
      ctx.lineTo(p.x - 0.35 * i + 0.2 * Z, p.y - 0.35 * ratio + 0.2 * z2);
      ctx.lineTo(p.x + 0.8 * i + 0.2 * Z, p.y + 0.8 * ratio + 0.2 * z2);
      ctx.lineTo(p.x + 0.9 * i - 0.1 * Z, p.y + 0.9 * ratio - 0.1 * z2);
      ctx.lineTo(p.x + 1.35 * i - 0.2 * Z, p.y + 1.35 * ratio - 0.2 * z2);
      ctx.lineTo(p.x + 1.4 * i - 0.7 * Z, p.y + 1.4 * ratio - 0.7 * z2);
      ctx.lineTo(p.x - 0.4 * i - 0.7 * Z, p.y - 0.4 * ratio - 0.7 * z2);
      ctx.closePath();
      ctx.stroke();
      ctx.strokeStyle = "#444444";
      ctx.lineWidth = z;
      ctx.beginPath();
      ctx.moveTo(p.x + 0.5 * i - 0.1 * Z, p.y + 0.5 * ratio - 0.1 * z2);
      ctx.lineTo(p.x + 0.9 * i - 0.1 * Z, p.y + 0.9 * ratio - 0.1 * z2);
      ctx.lineTo(p.x + 0.8 * i + 0.2 * Z, p.y + 0.8 * ratio + 0.2 * z2);
      ctx.lineTo(p.x + 0.5 * i + 0.2 * Z, p.y + 0.5 * ratio + 0.2 * z2);
      ctx.lineTo(p.x + 0.5 * i - 0.1 * Z, p.y + 0.5 * ratio - 0.1 * z2);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      this.tire(ctx, absoluteMousePosition.x, absoluteMousePosition.y, 10 * z, z, this.rearWheel.angle);
      ctx.closePath();
      ctx.beginPath();
      this.tire(ctx, pointerAbs.x, pointerAbs.y, 10 * z, z, this.frontWheel.angle);
      ctx.closePath();
      ctx.restore();
    };
    self.tire = function(ctx, radius, y, offset, scale, pos) {
      ctx.beginPath();
      ctx.arc(radius, y, 10 * scale, 0, 2 * Math.PI, false);
      ctx.fillStyle = "#888888";
      ctx.fill();
      ctx.lineWidth = 5.9 * scale;
      ctx.strokeStyle = "#000000";
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = 2 * scale;
      ctx.strokeStyle = "0x000000";
      a = 0;
      offset = offset + 3 * scale;
      for (; a++ < 8;) {
        ctx.moveTo(radius + offset * Math.cos(pos + 6.283 * a / 8), y + offset * Math.sin(pos + 6.283 * a / 8));
        ctx.lineTo(radius + offset * Math.cos(pos + 6.283 * (a + 0.5) / 8), y + offset * Math.sin(pos + 6.283 * (a + 0.5) / 8));
      }
      ctx.stroke();
      ctx.closePath();
      ctx.beginPath();
      ctx.lineWidth = 2 * scale;
      ctx.strokeStyle = "0x000000";
      a = 0;
      offset = offset + -9 * scale;
      for (; a++ < 5;) {
        ctx.moveTo(radius + offset * Math.cos(pos + 6.283 * a / 5), y + offset * Math.sin(pos + 6.283 * a / 5));
        ctx.lineTo(radius + offset * Math.cos(pos + 6.283 * (a + 0.2) / 5), y + offset * Math.sin(pos + 6.283 * (a + 0.2) / 5));
      }
      ctx.closePath();
      ctx.stroke();
    };
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77,
    "./spring" : 83,
    "./vehicle" : 85,
    "./wheel" : 86
  }],
  85 : [function(require, module) {
    var $ = function() {
    };
    module.exports = $;
    {
      var Vector2 = require("../math/cartesian");
      var Topology = (require("../utils/gamepad"), require("./explosion"));
      var get = (Math.sqrt, Math.pow, Math.abs);
      var $ = (Math.min, Math.floor, Math.round);
      Math.random;
    }
    $.prototype.init = function(obj) {
      this.player = obj;
      this.scene = obj._scene;
      this.gamepad = obj._gamepad;
      this.settings = obj._settings;
      this.gravity = new Vector2(0, 0.3);
      this.complete = false;
      this.alive = true;
      this.crashed = false;
      this.dir = 1;
      this.ghost = false;
      this.ragdoll = false;
      this.explosion = false;
      this.speed = 0;
      this.powerupsEnabled = true;
      this.createCosmetics();
    };
    $.prototype.explode = function() {
      this.scene.sound.play("bomb_sound", 1);
      this.explosion = new Topology(this.masses[0].pos, this.scene);
      this.dead();
    };
    $.prototype.createCosmetics = function() {
      var result = this.player._user;
      var persistedDto = result.cosmetics;
      this.cosmetics = persistedDto;
    };
    $.prototype.updateSpeed = function() {
      this.speed = get($(this.focalPoint.vel.x + this.focalPoint.vel.y));
    };
    $.prototype.close = function() {
      this.scene = null;
      this.settings = null;
      this.gravity = null;
      this.speed = null;
      this.cosmetics = null;
      this.explosion = null;
      this.ragdoll = null;
      this.ghost = null;
      this.crashed = null;
      this.alive = null;
      this.gamepad = null;
    };
    $.prototype.dead = function() {
      this.stopSounds();
      this.player.dead();
      this.crashed = true;
      this.alive = false;
    };
    $.prototype.moveVehicle = function(left, top) {
      var d = this.masses;
      var numActivities = d.length;
      var i = numActivities - 1;
      for (; i >= 0; i--) {
        d[i].pos.x = d[i].pos.x + left;
        d[i].pos.y = d[i].pos.y + top;
        d[i].old.x = d[i].old.x + left;
        d[i].old.y = d[i].old.y + top;
      }
    };
    $.prototype.stopSounds = function() {
    };
  }, {
    "../math/cartesian" : 14,
    "../utils/gamepad" : 60,
    "./explosion" : 75
  }],
  86 : [function(saveNotifs, module) {
    function Sprite(element, id) {
      this.init(element, id);
      this.motor = 0;
      this.brake = false;
      this.angle = 0;
      this.speed = 0;
      this.rotationSpeed = 0;
    }
    var CropAreaRectangle = (saveNotifs("../math/cartesian"), saveNotifs("./mass"));
    var self = Sprite.prototype = new CropAreaRectangle;
    self.motor = 0;
    self.brake = false;
    self.angle = 0;
    self.speed = 0;
    self.drive = function(amount, size) {
      var pos = this.pos;
      var width = this.motor * this.parent.dir;
      var x = width * amount;
      var yOffset = width * size;
      if (pos.x += x, pos.y += yOffset, this.brake) {
        var scale = 0.3 * -(amount * this.vel.x + size * this.vel.y);
        var count = amount * scale;
        var lineHeight = size * scale;
        pos.x += count;
        pos.y += lineHeight;
      }
      this.speed = (amount * this.vel.x + size * this.vel.y) / this.radius;
      this.rotationSpeed = this.speed;
      this.angle += this.speed;
      this.contact = true;
    };
    self.massUpdate = self.update;
    self.update = function() {
      var rect = this.parent.gravity;
      var pos = this.pos;
      var elpos = this.old;
      var offset = this.vel;
      offset.x += rect.x;
      offset.y += rect.y;
      if (0 != rect.x || 0 != rect.y) {
        offset.x = 0.99 * offset.x;
        offset.y = 0.99 * offset.y;
      }
      pos.x += offset.x;
      pos.y += offset.y;
      this.contact = false;
      if (this.collide) {
        this.scene.track.collide(this);
      }
      offset.x = pos.x - elpos.x;
      offset.y = pos.y - elpos.y;
      this.old.equ(this.pos);
      this.rotationSpeed = 0.999 * this.rotationSpeed;
    };
    module.exports = Sprite;
  }, {
    "../math/cartesian" : 14,
    "./mass" : 77
  }],
  87 : [function(require, module) {
    function View(data) {
      var settings = data.settings;
      this.settings = settings;
      this.scene = data;
      this.zoom = settings.cameraStartZoom * data.game.pixelRatio;
      this.desiredZoom = settings.cameraStartZoom * data.game.pixelRatio;
      this.zooming = false;
      this.position = new Vector(0, 0);
      this.zoomPercentage = this.getZoomAsPercentage();
      this.zoomPoint = false;
    }
    var Vector = require("../math/cartesian");
    var min = Math.round;
    var mathAbs = Math.abs;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    View.prototype = {
      settings : null,
      scene : null,
      zoom : 1,
      position : null,
      desiredZoom : 1,
      zoomPercentage : 0,
      focusIndex : 0,
      playerFocus : null,
      focusOnNextPlayer : function() {
        var t = this.scene.playerManager.getPlayerCount();
        this.focusIndex = (this.focusIndex + 1) % t;
        this.focusOnPlayer();
      },
      focusOnPlayer : function() {
        var self = this.scene;
        var session = self.playerManager;
        var i = session.getPlayerCount();
        if (i <= this.focusIndex) {
          this.focusIndex = 0;
        }
        var item = session.getPlayerByIndex(this.focusIndex);
        if (this.playerFocus !== item) {
          var n = this.playerFocus;
          if (this.playerFocus = item, self.vehicleTimer.setPlayer(item), n) {
            var diffVector = item.getDistanceBetweenPlayers(n);
            if (diffVector > 1500) {
              this.fastforward();
            }
          } else {
            this.fastforward();
          }
        }
      },
      focusOnMainPlayer : function() {
        if (!(0 === this.focusIndex && this.playerFocus)) {
          this.focusIndex = 0;
          this.focusOnPlayer();
        }
      },
      update : function() {
        if (this.playerFocus) {
          var model = this.playerFocus.getActiveVehicle();
          var prevLevelVitorc = model.focalPoint;
          var bounds = this.position;
          var factor = 3;
          var base = prevLevelVitorc.pos.x - bounds.x;
          var height = prevLevelVitorc.pos.y - bounds.y;
          var sqrt8 = sqrt(pow(base, 2) + pow(height, 2));
          if (sqrt8 > 1500) {
            factor = 1;
          }
          bounds.x += (prevLevelVitorc.pos.x - bounds.x) / factor;
          bounds.y += (prevLevelVitorc.pos.y - bounds.y) / factor;
        }
      },
      updateZoom : function() {
        var z = this.zoom;
        var currentZoom = this.desiredZoom;
        if (z !== currentZoom) {
          this.scene.loading = true;
          this._performZoom();
          if (this.zoom === this.desiredZoom) {
            this.zoomComplete();
          }
        }
      },
      zoomToPoint : function(pixelRatio) {
        var _ref = (this.zoom, this.scene);
        var image = _ref.screen;
        var currentPosition = this.position;
        var size = this.zoomPoint;
        var y = image.toReal(size.x, "x");
        var top = image.toReal(size.y, "y");
        var ratio = size.x / image.width;
        var gridUnit = size.y / image.height;
        var h = image.width / pixelRatio;
        var height = image.height / pixelRatio;
        currentPosition.x = y - h * ratio + h / 2;
        currentPosition.y = top - height * gridUnit + height / 2;
      },
      _performZoom : function() {
        var scene = this.scene;
        var zoom = (scene.screen, this.position, this.zoom);
        var z = this.desiredZoom;
        var diff = z - zoom;
        var zoomOffset = diff / 3;
        zoom = zoom + zoomOffset;
        if (mathAbs(diff) < 0.05) {
          zoom = z;
        }
        if (this.zoomPoint) {
          this.zoomToPoint(zoom);
        }
        this.zoom = zoom;
      },
      zoomComplete : function() {
        this.scene.redraw();
        this.zooming = false;
        this.scene.loading = false;
      },
      setZoom : function(p_zoom, p_animation) {
        var scene = this.scene;
        this.desiredZoom = min(p_zoom * scene.game.pixelRatio * 10) / 10;
        this.zooming = true;
        if (this.desiredZoom === this.zoom) {
          this.zooming = false;
          this.scene.state.loading = false;
        }
        this.zoomPoint = false;
        if (null === this.playerFocus && p_animation) {
          this.zoomPoint = p_animation;
        }
        this.zoomPercentage = this.getZoomAsPercentage();
        scene.stateChanged();
      },
      resetZoom : function() {
        var zoom = this.settings.cameraStartZoom;
        this.setZoom(zoom);
      },
      getZoomAsPercentage : function() {
        var settings = this.scene.settings;
        var e = this.desiredZoom / this.scene.game.pixelRatio / settings.cameraStartZoom * 100;
        return 0 | e;
      },
      increaseZoom : function() {
        var settings = this.scene.settings;
        var left_grip_selector = settings.cameraSensitivity;
        var viewWidth = this.desiredZoom + 2 * left_grip_selector;
        var ratio = this.scene.game.pixelRatio;
        var zoom = settings.cameraZoomMax;
        var newWidth = zoom * ratio;
        this.setZoom(viewWidth / ratio);
        if (this.desiredZoom > newWidth) {
          this.setZoom(zoom);
        }
      },
      decreaseZoom : function() {
        var settings = this.scene.settings;
        var left_grip_selector = settings.cameraSensitivity;
        var viewWidth = this.desiredZoom - 2 * left_grip_selector;
        var ratio = this.scene.game.pixelRatio;
        var zoom = settings.cameraZoomMin;
        var newWidth = zoom * ratio;
        this.setZoom(viewWidth / ratio);
        if (this.desiredZoom < newWidth) {
          this.setZoom(zoom);
        }
      },
      unfocus : function() {
        this.playerFocus = null;
        this.scene.vehicleTimer.removePlayer();
      },
      fastforward : function() {
        if (this.playerFocus) {
          var model = this.playerFocus.getActiveVehicle();
          var prevLevelVitorc = model.focalPoint;
          this.position.x = prevLevelVitorc.pos.x;
          this.position.y = prevLevelVitorc.pos.y;
        }
      },
      close : function() {
        this.zoom = null;
        this.scene = null;
        this.position = null;
        this.playerFocus = null;
      }
    };
    module.exports = View;
  }, {
    "../math/cartesian" : 14
  }],
  88 : [function(require, module) {
    function render(data) {
      this.scene = data;
      this.game = data.game;
      this.size = new Vector(0, 0);
      this.center = new Vector(0, 0);
      this.setScreen();
    }
    var Vector = require("../math/cartesian");
    render.prototype = {
      game : null,
      scene : null,
      size : null,
      center : null,
      width : 0,
      height : 0,
      setScreen : function() {
        var width = this.game.width;
        var height = this.game.height;
        this.width = width;
        this.height = height;
        this.size.x = width;
        this.size.y = height;
        this.center.x = width / 2;
        this.center.y = height / 2;
      },
      update : function() {
        var previous = this.game;
        if (previous.width !== this.width || previous.height !== this.height) {
          this.setScreen();
        }
      },
      realToScreen : function(b, i) {
        var scene = this.scene;
        var camera = scene.camera;
        var canvas = scene.screen;
        return (b - camera.position[i]) * camera.zoom + canvas.center[i];
      },
      toReal : function(percent, i) {
        var game = this.scene;
        var camera = game.camera;
        var screen = game.screen;
        return (percent - screen.center[i]) / camera.zoom + camera.position[i];
      },
      close : function() {
        this.width = null;
        this.height = null;
        this.center = null;
        this.size = null;
        this.game = null;
        this.scene = null;
      }
    };
    module.exports = render;
  }, {
    "../math/cartesian" : 14
  }],
  
  91 : [function() {
    !function() {
      if ("undefined" == typeof window.performance && (window.performance = {}), !window.performance.now) {
        var t_start = Date.now();
        if (performance.timing && performance.timing.navigationStart) {
          t_start = performance.timing.navigationStart;
        }
        window.performance.now = function() {
          return Date.now() - t_start;
        };
      }
    }();
  }, {}],
  
}, {}, [2]);
